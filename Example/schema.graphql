schema {
  query: Query
  mutation: Mutation
}

"The node interface is implemented by entities that have a global unique identifier."
interface Node {
  id: ID!
}

"GraphQL api that expose all TrackMan Golf data"
type Query {
  "Fetches an object given its ID."
  node("ID of the object." id: ID!): Node
  "Lookup nodes by a list of IDs."
  nodes("The list of node IDs." ids: [ID!]!): [Node]!
  "Return all personal data on a profile"
  me: Me
  "Retrieve the tournaments based on arguments"
  tournaments(tournamentDbIds: [String!]): [Tournament] @deprecated(reason: "Use PublicTools.getTournamentsByDbId")
  publicTools: publicTools
  "Retrieve the invitations based on arguments"
  invitations(invitationDbIds: [String!]): [Invitation] @deprecated(reason: "Use tournament.participants")
  "Return all facilities that the current user\/token have access to"
  facilities(skip: Int take: Int names: [String!] includeDeleted: Boolean! = false): FacilityTypeCollectionSegment
  "Return all locations that the current user\/token have access to"
  locations(near: LatLonInputType maxRadius: Float countryCode: [String!] stateCode: [String!] search: String updatedSince: DateTime includeDeletedLocations: Boolean isVisibleOnLocator: Boolean = true skip: Int take: Int): LocationInterfaceTypeCollectionSegment
  "Return course metadata"
  courses(names: [String] courseIdentifiers: [String] updatedSince: DateTime language: String skip: Int take: Int): CourseTypeCollectionSegment
  leaderboards: GlobalLeaderboards
  "Return system info"
  systemInfo: SystemInfo
  "Person information"
  persons: Persons
  "Range related data"
  range: RangeRootQueryType
  adminTools: AdminTools
  "Return all personal data on a profile"
  applicationData(client: ApplicationClients! clientVersion: String language: String! = "en-US" deviceId: String layoutKind: String layoutVersion: String facilityId: String serialNo: String hardwareType: String bayId: String): ApplicationDataInterface
  "Return all domains that the current user\/token have access to"
  domains(skip: Int take: Int "Return all domains that the current user\/token have access to based on the ids provided. If no ids are provided, all domains are returned. The ids can be of type Facility, Location or Domain." ids: [ID!] "Return all domains that the current user\/token have access to based on the permissions provided. If no permissions are provided, all domains are returned." permissions: [String!]): DomainUserAdminTypeCollectionSegment
}

"Mutations for Users"
type Mutation {
  "Mutations on a Activity"
  activity(id: ID!): ActivityMutation
  "Mutations on a Facility"
  facility(id: ID!): FacilityMutation
  "Create a new Facility"
  createFacility(id: String name: String! description: String address: AddressInput! phoneNumber: String! shopPhoneNumber: String email: EmailAddress! tags: [LocationUrlTags] urls: [UrlInput] "Overwrite default world location" worldLocation: LatLonInputType): Facility
  "Mutations on a Facility Location"
  location(id: ID!): LocationMutation
  "Mutations on a Tournament"
  tournament(id: ID!): TournamentMutationInterface
  "Mutations on a Me"
  me: MeMutation
  "Accepting a consent (TrackMan\/Partner\/Facility consent)"
  acceptConsent(input: AcceptConsentInput!): AcceptConsentPayload!
  "Revoking a consent (TrackMan\/Partner\/Facility consent)"
  revokeConsent(input: RevokeConsentInput!): RevokeConsentPayload!
  "Add or update the application properties for the user"
  setUserProperties(input: SetUserPropertiesInput!): SetUserPropertiesPayload!
  "Notification mutations"
  notifications: NotificationMutations
  "Mutations on a sponsor campaign"
  sponsorCampaign(id: ID!): SponsorCampaignMutations
  "Mutations on a sponsor campaign"
  sponsorCampaignV2(id: ID!): SponsorCampaignMutationInterfaceType
  "Mutations on a sponsor"
  sponsor(id: ID!): SponsorMutations
  "Mutations on a Domain"
  domain(id: ID!): DomainUserAdminMutation
  "Mutations on a partner"
  partner(id: ID!): PartnerMutations
  "Third-Party providers integration mutations"
  integrations: FacilityIntegrationsMutations
  "Mutations on a InfoScreen"
  infoScreen(id: ID!): InfoScreenId
  "Mutations on a InfoScreen Page"
  infoScreenPage(id: ID!): InfoScreenPageId
  "Mutations on a InfoScreen Page Item"
  infoScreenPageItem(id: ID!): InfoScreenPageItemId
  "Duplicate an existing info screen"
  duplicateInfoScreen(input: DuplicateInfoScreenInput!): DuplicateInfoScreenPayload!
  "Mutations available for out different applications eg. TPS or Range applications."
  applicationData(client: ApplicationClients! clientVersion: String language: String! = "en-US" deviceId: String layoutKind: String layoutVersion: String facilityId: String serialNo: String hardwareType: String bayId: String): ApplicationDataMutationInterfaceType
  "Mutations on a Person"
  adminPerson(id: ID!): IdValue
  "Mutations for admin tools"
  adminTools: AdminToolMutationType
  "Mutations for payments"
  payment: PaymentMutationsType
  "Mark the scorecard activity as hidden"
  hideScorecardActivity(scorecardId: String! playerIds: [String]): Boolean!
  createOAuthClientApplication(input: CreateOAuthClientApplicationInput): CreateOAuthClientApplicationPayload!
  createServiceAccount(input: CreateServiceAccountInput): CreateServiceAccountPayload!
  "Add a net on a range"
  addRangeNet(input: AddRangeNetInput!): AddRangeNetPayload!
  "Update a net on a range"
  updateRangeNet(input: UpdateRangeNetInput!): UpdateRangeNetPayload!
  "Remove a net from a range"
  removeRangeNets(input: RemoveRangeNetsInput!): RemoveRangeNetsPayload!
  "Enable a list of nets"
  enableRangeNets(input: EnableRangeNetsInput!): EnableRangeNetsPayload!
  "Disable a list of nets"
  disableRangeNets(input: DisableRangeNetsInput!): DisableRangeNetsPayload!
  "Delete a draft version of net and return to the previous published version"
  revertRangeNet(input: RevertRangeNetInput!): RevertRangeNetPayload!
  "Add a range target"
  addRangeTarget(input: AddRangeTargetInput!): AddRangeTargetPayload!
  "update a range target"
  updateRangeTarget(input: UpdateRangeTargetInput!): UpdateRangeTargetPayload!
  "Delete a list of range targets"
  removeRangeTargets(input: RemoveRangeTargetsInput!): RemoveRangeTargetsPayload!
  "enable a list of range targets"
  enableRangeTargets(input: EnableRangeTargetsInput!): EnableRangeTargetsPayload!
  "Disable a list of range targets"
  disableRangeTargets(input: DisableRangeTargetsInput!): DisableRangeTargetsPayload!
  "Update the color of a list of range targets"
  changeRangeTargetsColor(input: ChangeRangeTargetsColorInput!): ChangeRangeTargetsColorPayload!
  "Update the target type of a list of range targets"
  changeRangeTargetsType(input: ChangeRangeTargetsTypeInput!): ChangeRangeTargetsTypePayload!
  "Show or hide targets"
  changeRangeTargetsVisibility(input: ChangeRangeTargetsVisibilityInput!): ChangeRangeTargetsVisibilityPayload!
  "Delete a draft version of a range target and return to the previous published version"
  revertRangeTarget(input: RevertRangeTargetInput!): RevertRangeTargetPayload!
  "Add a range section"
  addRangeSection(input: AddRangeSectionInput!): AddRangeSectionPayload!
  "update a range section"
  updateRangeSection(input: UpdateRangeSectionInput!): UpdateRangeSectionPayload!
  "Delete a list of range sections"
  removeRangeSections(input: RemoveRangeSectionsInput!): RemoveRangeSectionsPayload!
  "Add a range bay"
  addRangeBay(input: AddRangeBayInput!): AddRangeBayPayload!
  "update a range bay"
  updateRangeBay(input: UpdateRangeBayInput!): UpdateRangeBayPayload!
  "Update the kiosk only status of a list of bays"
  changeRangeBayKioskOnlyFlag(input: ChangeRangeBayKioskOnlyFlagInput!): ChangeRangeBayKioskOnlyFlagPayload!
  "Update the availability of a list of bays"
  changeRangeBayAvailability(input: ChangeRangeBayAvailabilityInput!): ChangeRangeBayAvailabilityPayload!
  "Delete a list of range bays"
  removeRangeBays(input: RemoveRangeBaysInput!): RemoveRangeBaysPayload!
  "Enable a list of bays"
  enableRangeBays(input: EnableRangeBaysInput!): EnableRangeBaysPayload!
  "Disable a list of bays"
  disableRangeBays(input: DisableRangeBaysInput!): DisableRangeBaysPayload!
  "Delete a draft version of bays and return to the previous published version"
  revertRangeBay(input: RevertRangeBayInput!): RevertRangeBayPayload!
  "Add a launchArea"
  addRangeLaunchArea(input: AddRangeLaunchAreaInput!): AddRangeLaunchAreaPayload!
  "update a launchArea"
  updateRangeLaunchArea(input: UpdateRangeLaunchAreaInput!): UpdateRangeLaunchAreaPayload!
  "Remove a list of launchAreas"
  removeRangeLaunchAreas(input: RemoveRangeLaunchAreasInput!): RemoveRangeLaunchAreasPayload!
  "Enable a list of launchAreas"
  enableRangeLaunchAreas(input: EnableRangeLaunchAreasInput!): EnableRangeLaunchAreasPayload!
  "Disable a list of launchAreas"
  disableRangeLaunchAreas(input: DisableRangeLaunchAreasInput!): DisableRangeLaunchAreasPayload!
  "Delete a draft version of launchAreas and return to the previous published version"
  revertRangeLaunchArea(input: RevertRangeLaunchAreaInput!): RevertRangeLaunchAreaPayload!
  "Add a radar"
  addRangeRadar(input: AddRangeRadarInput!): AddRangeRadarPayload!
  "update a radar"
  updateRangeRadar(input: UpdateRangeRadarInput!): UpdateRangeRadarPayload!
  "Delete a list of radars"
  removeRangeRadar(input: RemoveRangeRadarInput!): RemoveRangeRadarPayload!
  "Enable a list of range radars"
  enableRangeRadars(input: EnableRangeRadarsInput!): EnableRangeRadarsPayload!
  "Disable radars"
  disableRangeRadars(input: DisableRangeRadarsInput!): DisableRangeRadarsPayload!
  "Delete a draft version of radars and return to the previous published version"
  revertRangeRadar(input: RevertRangeRadarInput!): RevertRangeRadarPayload!
  "Publishing range site configuration"
  publishRangeConfiguration(input: PublishRangeConfigurationInput!): PublishRangeConfigurationPayload!
}

"The description of the facility"
type Location implements LocationInterfaceType & TagsInterfaceTypeOfLocationTagsType & KeyValuesInterfaceType & Node {
  "The time the resource was created"
  createdAt: DateTime!
  "The internal database id"
  dbId: String
  "The time the resource was last updated"
  lastUpdatedAt: DateTime!
  "The list of tags"
  tags: [LocationUrlTags!]
  "Has any tags"
  hasTag(tag: LocationUrlTags!): Boolean
  "The list of key values"
  keyValues: [KeyValue!]
  "The list of key values added"
  keyValue(key: String!): String
  "Has any key value been added"
  hasKeyValue(key: String!): Boolean
  "The name of the facility"
  name: NonEmptyString
  "Is this location also a facility"
  isDefaultLocation: Boolean
  description("Format to convert the markdown to" as: MkDownTypes = MKDOWN): String
  "The primary email to the facility"
  email: String
  "The time zone where the facility is located"
  timezone: String
  "The address of the facility"
  address: Address
  "The primary phone number to the facility"
  phoneNumber: String
  "The phone number of the shop on the facility"
  shopPhoneNumber: String
  "The url of the facilities logo image"
  url(kind: LocationUrlKinds!): URL
  "The facility kind"
  kind: FacilityKind
  "The GPS position of the facility"
  worldLocation: LatLon
  "Is this the default world location"
  isDefaultWorldLocation: Boolean
  "The Opening Hours of the location"
  openingHours: OpeningHours
  "The distance to the facility from the search point 'near'"
  distance: Float
  "Indicate that a facility is deleted"
  isDeleted: Boolean
  "Returns paid events. If the list is empty, all available events will be returned. If the list list has one or more event ids, only those will be returned."
  paidEvents(tournamentIds: [String]! eventIds: [String]): [paidEvents]
  "Returns a list of all flags"
  paidEventFlags: [PaidEventFlag]
  "Returns a list of all tickets for an event and it's status. User must have FacilityManager role."
  paidEventTicketStatus(tournamentIds: String!): [paidTickets]
  id: ID!
  "The facility that owns this location"
  Facility: Facility
  "Bays available for this location"
  bays(types: BayTypes = ALL): [BayInterface!]
  applicationProperties(appIdentifiers: [String!] specifiedLevel: ApplicationPropertyLevelsEnumType): [ApplicationProperty]
  "Range-related entities available for this location"
  range: RangeLocationType!
  "the flags available for this location"
  paymentFlags: [PaidEventFlag]
  "Indicates if the location can be used for payment"
  isConfiguredForPayment: Boolean
}

"An indoor simulator bay"
type SimulatorBay implements BayInterface & Node {
  id: ID!
  dbId: String
  "Indicate if the bay is an indoor simulator bay or a bay in a driving range"
  kind: BayKind
  "The name of the bay"
  name: String
  "The bay description"
  description: String
  "The serial number of the radar in the bay"
  serialNumber: String
  "The Device Id of TPS in the bay"
  deviceId: String
  "The facility that the bay is located in"
  facility: Facility
  "The location the bay is in"
  location: LocationInterfaceType
  "A numeric identifier for the bay"
  bayNumber: Int
  "Indicates the availability status of the bay"
  availability: BayAvailability!
  "Activity information for this bay"
  activities: BayIndoorActivities!
  "Indicates whether the bay is currently occupied"
  isOccupied: Boolean!
  "Indicates whether the bay is currently offline"
  isOffline: Boolean!
  "Indicates whether the bay is currently part of one of the enabled bay setups"
  isEnabled: Boolean!
  "The list of bookings for this bay"
  bookings: BayBookings!
  "The software version for this bay"
  softwareVersion: String
  "The current session for this bay"
  session: BayIndoorSession
  "Storage information for this bay"
  storage: [BayStorageInfo]
  "Information about display screen for this bay"
  display: [BayScreenInfo]
  "Information about graphics for this bay"
  graphics: [BayGraphicsInfo]
  "Information about the bay if it is locked"
  isLocked: Boolean
  "Strokes information for this bay"
  strokes: BayStrokes!
  applicationProperties(appIdentifiers: [String!] specifiedLevel: ApplicationPropertyLevelsEnumType): [ApplicationProperty]
}

"A bay on a driving range"
type RangeBay implements BayInterface & Node {
  "The global object identification"
  id: ID!
  dbId: String
  "Indicate if the bay is an indoor simulator bay or a bay in a driving range"
  kind: BayKind
  "The name of the bay"
  name: String
  "The bay description"
  description: String
  "The numeric bay identifier"
  bayNumber: Int
  "The section of the bay"
  section: Section
  "The facility that the bay is located in"
  facility: Facility
  "The location the bay is located in"
  location: LocationInterfaceType
  annotations: [KeyValue!]
  "Indicates the availability status of the bay"
  availability: BayAvailability!
  "Activity information for this bay"
  activities: BayRangeActivities!
  "Indicates whether the bay is currently offline"
  isOffline: Boolean!
  "Indicates whether the bay is only available in kiosk screens"
  isKioskOnly: Boolean!
  "Indicates whether the bay is a dynamic bay"
  isDynamic: Boolean!
  "Indicates whether the bay is currently part of one of the enabled bay setups"
  isEnabled: Boolean!
  "Booking information for this bay"
  bookings: BayBookings!
  "Safety border net incident information for this bay"
  netIncidents: BayNetIncidents!
  "Strokes information for this bay"
  strokes: BayStrokes!
  "Returns version information about the draft and published version of the bay"
  versionInfo: RangeBayVersionInfo!
  applicationProperties(appIdentifiers: [String!] specifiedLevel: ApplicationPropertyLevelsEnumType): [ApplicationProperty]
}

"Activity information for a Driving Range bay"
type RangeBayActivity implements BayActivityInterface & Node {
  id: ID!
  "The activity type"
  type: String!
  "The kind of the activity"
  kind: ActivityKind
  "The start time of the activity"
  startTime: DateTime!
  "The list of players currently occupying the bay"
  players: [BayPlayer]!
  "The list of strokes currently in the ongoing activity"
  strokes: StrokeList!
  "Safety border net incident information for this activity"
  netIncidents: BayRangeActivityNetIncidents
}

type SessionActivity implements PlayerActivity & Node & SessionActivityInterface {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  sessionId: String
  strokes(clubs: [ClubEnum!]): [Stroke!]
  aggregatedMeasurement(clubs: [ClubEnum!] useNormalizedMeasurement: Boolean = false): AggregatedMeasurement
  strokeCount: Int!
}

"Represents a booking"
type Booking implements Node {
  id: ID!
  "The optional Id of the booking as represented in an external booking provider"
  externalBookingId: String
  "A correlation Id to track a user session across multiple bookings"
  correlationId: String
  "A UTC date of the start time of the booking"
  startDate: DateTime!
  "A UTC date of the end time of the booking"
  endDate: DateTime!
  "An alias for the user that makes the booking"
  userAlias: String
  "The bay of the booking"
  bay: BayInterface
}

type VirtualRangeSessionActivity implements PlayerActivity & Node & SessionActivityInterface {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  sessionId: String
  strokes(clubs: [ClubEnum!]): [Stroke!]
  aggregatedMeasurement(clubs: [ClubEnum!] useNormalizedMeasurement: Boolean = false): AggregatedMeasurement
  strokeCount: Int!
}

type PerformancePuttingSessionActivity implements PlayerActivity & Node & SessionActivityInterface {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  sessionId: String
  strokes(clubs: [ClubEnum!]): [Stroke!]
  aggregatedMeasurement(clubs: [ClubEnum!] useNormalizedMeasurement: Boolean = false): AggregatedMeasurement
  strokeCount: Int!
}

type SimulatorSessionActivity implements PlayerActivity & Node & SessionActivityInterface {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  sessionId: String
  strokes(clubs: [ClubEnum!]): [Stroke!]
  aggregatedMeasurement(clubs: [ClubEnum!] useNormalizedMeasurement: Boolean = false): AggregatedMeasurement
  strokeCount: Int!
}

type ShotAnalysisSessionActivity implements PlayerActivity & Node & SessionActivityInterface {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  sessionId: String
  strokes(clubs: [ClubEnum!]): [Stroke!]
  aggregatedMeasurement(clubs: [ClubEnum!] useNormalizedMeasurement: Boolean = false): AggregatedMeasurement
  strokeCount: Int!
}

type TracySessionActivity implements PlayerActivity & Node & SessionActivityInterface {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  sessionId: String
  strokes(clubs: [ClubEnum!]): [Stroke!]
  aggregatedMeasurement(clubs: [ClubEnum!] useNormalizedMeasurement: Boolean = false): AggregatedMeasurement
  strokeCount: Int!
}

type DynamicReportActivity implements PlayerActivity & Node {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  reportId: String
  mailId: String
  type: String
  subject: String
  reportLink: URL
}

type CombineTestActivity implements PlayerActivity & SessionActivityInterface & Node {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  longestDrive: Float!
  maxClubSpeed: Float!
  score: Float!
  bestDeci: Int!
  numberOfStrokesAboveBestDeci: Int!
  dynamicReportPath: URL
  "\r\n                        The estimated Hcp based on the Combine Test Score. \r\n                        Note: positive numbers should be displayed as is, negative numbers should be displayed as +, so: -4 should be displayed as '+4' and 7 should be displayed as '7'.\r\n                        -5 should be displayed as '+5 or below' and 36 should be displayed as '36 or above'"
  estimatedHcp: Float
  "The unit of the Combine Test"
  unit: String
  "The best target of the Combine Test"
  bestTarget: String
  "Combine test result"
  testResult: TestResult
  strokes(clubs: [ClubEnum!]): [Stroke!]
  aggregatedMeasurement(clubs: [ClubEnum!] useNormalizedMeasurement: Boolean = false): AggregatedMeasurement
}

type TestActivity implements PlayerActivity & SessionActivityInterface & Node {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  avgScore: Float!
  dynamicReportPath: URL
  name: String
  "Test result"
  testResult: TestResult
  strokes(clubs: [ClubEnum!]): [Stroke!]
  aggregatedMeasurement(clubs: [ClubEnum!] useNormalizedMeasurement: Boolean = false): AggregatedMeasurement
}

type ScreencastActivity implements PlayerActivity & Node {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  thumbnailUrl: URL
  videoUrl: URL
  subject: String
}

type VideoActivityType implements PlayerActivity & Node {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  sessionId: UUID!
  videoId: UUID!
  measurementId: UUID!
  thumbnailUrl: URL
  videoUrl: URL
}

type RangePracticeActivity implements PlayerActivity & RangeActivityInterface & Node {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  "Strokes"
  strokes: [RangeStroke!]
  siteAssetInfo: [SiteAssetInfo!]
  siteMetadata: DrivingRangesMetadata
  "OldPlayerId is used when a temp player have been merged on the server but you still would like to use the old Id in the leaderboard"
  oldPlayerId: UUID
  activityEvents: [ActivityEvent!]
  location: ActivityLocation
  "The number of strokes that was hit in the session"
  numberOfStrokes: Int
  "The clubs that was used in the session"
  clubs: [String!]
  "The targets that was used in the session"
  usedTargets: [Target]
}

"The activity is created when a Simulator Course have been played"
type CoursePlayActivity implements PlayerActivity & Node {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  "The scorecard for the played round"
  scorecard: Scorecard
  "The game type used when playing the round"
  gameType: String
  "The gross score of the currently played holes"
  grossScore: Int
  "The net score of the currently played holes"
  netScore: Int
  "The stableford points of the completed round"
  stablefordPoints: Int
  "The number of gross strokes up or down compared to par on currently played holes"
  toPar: Int
  "The number of net strokes up or down compared to par on currently played holes"
  netToPar: Int
  "The stableford up or down compared to par on currently played holes"
  stablefordToPar: Int
  "Match play score"
  matchScore: Int
  "Skins play score"
  skinsScore: Int
  "The number of holes to play"
  numberOfHolesToPlay: Int!
  "Played until this hole number"
  thruHole: Int!
  "The game settings"
  gameSettings: GameSettings
  "This round is a in a tournament"
  isInTournament: Boolean
  "This round is a in a tournament"
  tournament: Tournament
  "The course that the round was played on"
  course: Course
  "The state of the players round"
  state: CoursePlayStateEnum
}

"The activity is created when a Simulator Closest To The Pin game have been played"
type ClosestToThePinActivity implements PlayerActivity & Node {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
}

type RangeFindMyDistanceActivity implements PlayerActivity & RangeActivityInterface & Node {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  "Strokes"
  strokes: [RangeStroke!]
  siteAssetInfo: [SiteAssetInfo!]
  siteMetadata: DrivingRangesMetadata
  "OldPlayerId is used when a temp player have been merged on the server but you still would like to use the old Id in the leaderboard"
  oldPlayerId: UUID
  activityEvents: [ActivityEvent!]
  location: ActivityLocation
  "The number of strokes that was hit in the session"
  numberOfStrokes: Int
  "The clubs that was used in the session"
  clubs: [String!]
  strokesDistancesPerClub: [KeyValuePairOfStringAndDouble__!]
}

type RangeBullsEyeActivity implements RangeGameActivityInterface & PlayerActivity & RangeActivityInterface & Node {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  "Strokes"
  strokes: [RangeStroke!]
  siteAssetInfo: [SiteAssetInfo!]
  siteMetadata: DrivingRangesMetadata
  "OldPlayerId is used when a temp player have been merged on the server but you still would like to use the old Id in the leaderboard"
  oldPlayerId: UUID
  activityEvents: [ActivityEvent!]
  location: ActivityLocation
  "The game ended tie"
  didEndInTie: Boolean
  "You won the game"
  youWon: Boolean
  "You was placed on this position. Note that it's a string so Tie is marked as T6"
  youPlaced: String
  "Game leader-board"
  leaderboard: [RangeLeaderboardRecord!]
}

type RangeHitItActivity implements RangeGameActivityInterface & PlayerActivity & RangeActivityInterface & Node {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  "Strokes"
  strokes: [RangeStroke!]
  siteAssetInfo: [SiteAssetInfo!]
  siteMetadata: DrivingRangesMetadata
  "OldPlayerId is used when a temp player have been merged on the server but you still would like to use the old Id in the leaderboard"
  oldPlayerId: UUID
  activityEvents: [ActivityEvent!]
  location: ActivityLocation
  "The game ended tie"
  didEndInTie: Boolean
  "You won the game"
  youWon: Boolean
  "You was placed on this position. Note that it's a string so Tie is marked as T6"
  youPlaced: String
  "Game leader-board"
  leaderboard: [RangeLeaderboardRecord!]
}

type RangeCaptureTheFlagActivity implements RangeGameActivityInterface & PlayerActivity & RangeActivityInterface & Node {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  "Strokes"
  strokes: [RangeStroke!]
  siteAssetInfo: [SiteAssetInfo!]
  siteMetadata: DrivingRangesMetadata
  "OldPlayerId is used when a temp player have been merged on the server but you still would like to use the old Id in the leaderboard"
  oldPlayerId: UUID
  activityEvents: [ActivityEvent!]
  location: ActivityLocation
  "The game ended tie"
  didEndInTie: Boolean
  "You won the game"
  youWon: Boolean
  "You was placed on this position. Note that it's a string so Tie is marked as T6"
  youPlaced: String
  "Game leader-board"
  leaderboard: [RangeLeaderboardRecord!]
}

type RangeVirtualGolfPlayActivity implements PlayerActivity & RangeActivityInterface & Node {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  "Strokes"
  strokes: [RangeStroke!]
  siteAssetInfo: [SiteAssetInfo!]
  siteMetadata: DrivingRangesMetadata
  "OldPlayerId is used when a temp player have been merged on the server but you still would like to use the old Id in the leaderboard"
  oldPlayerId: UUID
  activityEvents: [ActivityEvent!]
  location: ActivityLocation
}

type RangeVirtualGolfPracticeActivity implements PlayerActivity & RangeActivityInterface & Node {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  "Strokes"
  strokes: [RangeStroke!]
  siteAssetInfo: [SiteAssetInfo!]
  siteMetadata: DrivingRangesMetadata
  "OldPlayerId is used when a temp player have been merged on the server but you still would like to use the old Id in the leaderboard"
  oldPlayerId: UUID
  activityEvents: [ActivityEvent!]
  location: ActivityLocation
}

type PdfReportActivity implements PlayerActivity & Node {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  reportId: String
  mailId: String
  reportKind: String
  subject: String
  message: String
  reportPath: URL
}

type EventReportActivity implements PlayerActivity & Node {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  eventId: String
  mailId: String
  subject: String
  reportPath: URL
}

type NoteActivity implements PlayerActivity & Node {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  note: String
}

type PerformanceCenterActivity implements PlayerActivity & Node {
  id: ID!
  "Date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  "Report id"
  reportId: String
  "Performance Center report type"
  type: String
  "Number of targets"
  targetCount: Int
  "Total number of strokes"
  strokeCount: Int
  "Average number of strokes gained"
  averageStrokesGained: Float
  "Performance Center report"
  report: PerformanceCenterQuickPlayReport
}

"Mutations on a Tournament"
type CourseTournamentMutation implements TournamentMutationInterface & MediaAssetsMutationInterface & PaymentMutationInterface {
  "Delete the tournament"
  delete: Boolean
  "Ends the tournament"
  endTournament: Tournament
  "Change the name of the tournament"
  changeName(name: String!): Tournament
  "Change the description of the tournament"
  changeDescription(description: String): Tournament
  "Change the logo of the tournament"
  changeLogo(logoUrl: Url!): Tournament
  "Change the units used when playing the tournament"
  changeGameUnit(unit: GameUnit): Tournament
  "Set flag indicating that this is an indoor tournament"
  setIsIndoor(isIndoor: Boolean!): Tournament
  "Set flag indicating that this is a range tournament"
  setIsRange(isRange: Boolean!): Tournament
  "Set the tournament availability"
  setAvailability(availability: TournamentAvailability! makeAvailableForAllBays: Boolean): Tournament
  "Publish the draft as published"
  publish: Tournament
  "Un-publish the published version"
  unPublish: Tournament
  "Move a tournament and all it's round to a new starting date and time"
  moveStartTime(newStartTime: DateTime!): Tournament
  "The round default mutations"
  roundDefaults: TournamentRoundDefaultsMutation
  "Invite by emails"
  invite(emails: [String!]!): Boolean
  "Join the tournament"
  join: Invitation
  "Join a player to the tournament without the player having to accept an invitation"
  joinPlayer(playerId: String email: String): Invitation
  "Accept invitation"
  acceptInvitation(invitationIds: [ID!]): Invitation
  "Decline invitation"
  declineInvitation(invitationIds: [ID!]): Invitation
  "Withdraw invitation"
  withdrawInvitation(invitationIds: [ID!]): Invitation
  "Resend invitation"
  reInvite(invitationIds: [ID!]): Invitation
  "Add a sponsor to the tournament"
  addSponsor(sponsorId: String!): Tournament
  "Remove a sponsor from the tournament"
  removeSponsor(sponsorId: String!): Tournament
  "Replace the sponsor from the tournament with another sponsor"
  replaceSponsor(oldSponsorId: String! newSponsorId: String!): Tournament
  "Add or remove tags to the tournament"
  updateTags(addTags: [String] removeTags: [String]): Tournament
  "Method for updating the key values collections on the tournament"
  setKeyValues(addKeyValues: [KeyValueInput] removeKeyValues: [String!]): Tournament
  "Add or remove geo filters to the tournament"
  updateGeoFilters(field: GeoFilterFields addIncludedValues: [String] removeIncludedValues: [String] addExcludedValues: [String] removeExcludedValues: [String]): Tournament
  "Add default requirements for participation to the tournament.Only use 'templateOwner' argument if assigning template from a specific user, otherwise leave blank to use the Trackman global template."
  addParticipantRequirementsFromDefaultTemplate(templateOwner: String): Tournament
  "Update requirements for participation to the tournament.Not passing a value for a criteria will remove it, ie. even if you do not change an existing criteriait must still be provided in order to keep it."
  updateParticipantRequirements(description: String age: ageInput gender: genderInput handicapRange: handicapRangeInput trackmanHandicap: trackmanHandicapInput category: categoryInput): Tournament
  "Remove requirements for participation from the tournament"
  removeParticipantRequirements: Tournament
  "Update group for participation in the tournament. Renaming an existing group will delete the old group and create a new one.Not passing a value for a criteria will remove it, ie. even if you do not change an existing criteriait must still be provided in order to keep it."
  updateParticipantGroup(name: String! description: String age: ageInput gender: genderInput handicapRange: handicapRangeInput trackmanHandicap: trackmanHandicapInput category: categoryInput): Tournament
  "Remove a participant group from the tournament"
  removeParticipantGroup(name: String!): Tournament
  "Remove all participant groups from the tournament"
  removeAllParticipantGroups: Tournament
  "Add or remove which locations this tournament is available."
  setLocations(addLocations: [NonEmptyString] removeLocations: [NonEmptyString] setLocations: [NonEmptyString] selectAll: Boolean): Tournament @deprecated(reason: "No longer supported.")
  "Reset the MaxScoreMethod for all rounds in the order of merit tournament to Default."
  resetMaxScoringMethodForAllRounds: Tournament
  "Add default image to the tournament"
  addDefaultImage(mediaId: ID!): MediaAssetsInterface
  "Add media assets to the tournament"
  addMediaAssets(mediaId: ID! mediaAssetKind: [MediaAssetKind]!): MediaAssetsInterface
  "Remove media assets from the tournament"
  removeMediaAssets(mediaAssetKind: [MediaAssetKind!]!): MediaAssetsInterface
  "Remove all media assets, and fallback to default media assets"
  resetMediaAssets: MediaAssetsInterface
  "Enable payment for the tournament. Payment needs to be configured for each location where the tournament is available."
  enablePayment: Tournament
  "Disable payment for the tournament. Please note that the existing payment configuration will be deleted."
  disablePayment: Tournament
  "change the start time of the sign up"
  changeSignUpStartTime(signUpStartTime: DateTime): Tournament
  "change the end time of the sign up"
  changeSignUpEndTime(signUpEndTime: DateTime): Tournament
  "change the payment configuration of a location"
  changeLocationPaymentConfiguration(locationId: ID! fee: NonNegativeFloat flags: [Int]): Tournament
  "add a location to this tournament"
  addLocation(locationId: ID!): Tournament
  "remove a location from this tournament"
  removeLocation(locationId: ID!): Tournament
  "select all facility locations for this tournament"
  selectAllLocations: Tournament
  "deSelect all facility locations for this tournament"
  deSelectAllLocations: Tournament
  "filter out the locations that are not configured for payment"
  filterOutLocationsNotConfiguredForPayment: Tournament
  "Change the game type of the tournament"
  changeGameType(gameType: GameTypes!): Tournament
  "Change the game format for the TEAM tournament. Available formats are: Scramble, Better ball, Alternate shot (Foursome) and Greensomes"
  changeGameFormat(gameFormat: GameFormats!): Tournament
  "Change the mulligan settings of the tournament"
  changeMulliganSettings(mulliganSettings: Mulligans!): Tournament
  "Change the attempts per round of the tournament"
  changeAttemptsPerRound(attemptsPerRound: Int!): Tournament
  "Change the number of bottom rounds of the tournament to ignore"
  changeIgnoreBottomRounds(ignoreBottomRounds: Int!): Tournament
  "Change the handicap settings for the tournament"
  changeHcpSettings(hcpType: HcpKind): Tournament
  "Change the number of players allowed in a team for team tournaments. Currently only 2 or 4 player teams are allowed - depending on the game format"
  changeTeamSize(teamSize: Int!): Tournament
  "Set if you are allow to play ahead in the tournament"
  setAllowPlayAhead(allowPlayAhead: Boolean!): Tournament
  "Add a round to a multi round tournament"
  addRound: TournamentRound
  "Get a round-mutation by round number"
  roundByNo(roundNumber: Int!): TournamentRoundMutation
  "Get a round-mutation by round Id"
  roundById(roundId: ID!): TournamentRoundMutation
}

"Mutations on a Tournament"
type CtpTournamentMutation implements TournamentMutationInterface & MediaAssetsMutationInterface & PaymentMutationInterface {
  "Delete the tournament"
  delete: Boolean
  "Ends the tournament"
  endTournament: Tournament
  "Change the name of the tournament"
  changeName(name: String!): Tournament
  "Change the description of the tournament"
  changeDescription(description: String): Tournament
  "Change the logo of the tournament"
  changeLogo(logoUrl: Url!): Tournament
  "Change the units used when playing the tournament"
  changeGameUnit(unit: GameUnit): Tournament
  "Set flag indicating that this is an indoor tournament"
  setIsIndoor(isIndoor: Boolean!): Tournament
  "Set flag indicating that this is a range tournament"
  setIsRange(isRange: Boolean!): Tournament
  "Set the tournament availability"
  setAvailability(availability: TournamentAvailability! makeAvailableForAllBays: Boolean): Tournament
  "Publish the draft as published"
  publish: Tournament
  "Un-publish the published version"
  unPublish: Tournament
  "Move a tournament and all it's round to a new starting date and time"
  moveStartTime(newStartTime: DateTime!): Tournament
  "The round default mutations"
  roundDefaults: TournamentRoundDefaultsMutation
  "Invite by emails"
  invite(emails: [String!]!): Boolean
  "Join the tournament"
  join: Invitation
  "Join a player to the tournament without the player having to accept an invitation"
  joinPlayer(playerId: String email: String): Invitation
  "Accept invitation"
  acceptInvitation(invitationIds: [ID!]): Invitation
  "Decline invitation"
  declineInvitation(invitationIds: [ID!]): Invitation
  "Withdraw invitation"
  withdrawInvitation(invitationIds: [ID!]): Invitation
  "Resend invitation"
  reInvite(invitationIds: [ID!]): Invitation
  "Add a sponsor to the tournament"
  addSponsor(sponsorId: String!): Tournament
  "Remove a sponsor from the tournament"
  removeSponsor(sponsorId: String!): Tournament
  "Replace the sponsor from the tournament with another sponsor"
  replaceSponsor(oldSponsorId: String! newSponsorId: String!): Tournament
  "Add or remove tags to the tournament"
  updateTags(addTags: [String] removeTags: [String]): Tournament
  "Method for updating the key values collections on the tournament"
  setKeyValues(addKeyValues: [KeyValueInput] removeKeyValues: [String!]): Tournament
  "Add or remove geo filters to the tournament"
  updateGeoFilters(field: GeoFilterFields addIncludedValues: [String] removeIncludedValues: [String] addExcludedValues: [String] removeExcludedValues: [String]): Tournament
  "Add default requirements for participation to the tournament.Only use 'templateOwner' argument if assigning template from a specific user, otherwise leave blank to use the Trackman global template."
  addParticipantRequirementsFromDefaultTemplate(templateOwner: String): Tournament
  "Update requirements for participation to the tournament.Not passing a value for a criteria will remove it, ie. even if you do not change an existing criteriait must still be provided in order to keep it."
  updateParticipantRequirements(description: String age: ageInput gender: genderInput handicapRange: handicapRangeInput trackmanHandicap: trackmanHandicapInput category: categoryInput): Tournament
  "Remove requirements for participation from the tournament"
  removeParticipantRequirements: Tournament
  "Update group for participation in the tournament. Renaming an existing group will delete the old group and create a new one.Not passing a value for a criteria will remove it, ie. even if you do not change an existing criteriait must still be provided in order to keep it."
  updateParticipantGroup(name: String! description: String age: ageInput gender: genderInput handicapRange: handicapRangeInput trackmanHandicap: trackmanHandicapInput category: categoryInput): Tournament
  "Remove a participant group from the tournament"
  removeParticipantGroup(name: String!): Tournament
  "Remove all participant groups from the tournament"
  removeAllParticipantGroups: Tournament
  "Add or remove which locations this tournament is available."
  setLocations(addLocations: [NonEmptyString] removeLocations: [NonEmptyString] setLocations: [NonEmptyString] selectAll: Boolean): Tournament @deprecated(reason: "No longer supported.")
  "Reset the MaxScoreMethod for all rounds in the order of merit tournament to Default."
  resetMaxScoringMethodForAllRounds: Tournament
  "Add default image to the tournament"
  addDefaultImage(mediaId: ID!): MediaAssetsInterface
  "Add media assets to the tournament"
  addMediaAssets(mediaId: ID! mediaAssetKind: [MediaAssetKind]!): MediaAssetsInterface
  "Remove media assets from the tournament"
  removeMediaAssets(mediaAssetKind: [MediaAssetKind!]!): MediaAssetsInterface
  "Remove all media assets, and fallback to default media assets"
  resetMediaAssets: MediaAssetsInterface
  "Enable payment for the tournament. Payment needs to be configured for each location where the tournament is available."
  enablePayment: Tournament
  "Disable payment for the tournament. Please note that the existing payment configuration will be deleted."
  disablePayment: Tournament
  "change the start time of the sign up"
  changeSignUpStartTime(signUpStartTime: DateTime): Tournament
  "change the end time of the sign up"
  changeSignUpEndTime(signUpEndTime: DateTime): Tournament
  "change the payment configuration of a location"
  changeLocationPaymentConfiguration(locationId: ID! fee: NonNegativeFloat flags: [Int]): Tournament
  "add a location to this tournament"
  addLocation(locationId: ID!): Tournament
  "remove a location from this tournament"
  removeLocation(locationId: ID!): Tournament
  "select all facility locations for this tournament"
  selectAllLocations: Tournament
  "deSelect all facility locations for this tournament"
  deSelectAllLocations: Tournament
  "filter out the locations that are not configured for payment"
  filterOutLocationsNotConfiguredForPayment: Tournament
  "Change if the tournament has an end date"
  changeHasEndDate(hasEndDate: Boolean!): ClosestToPinTournament @deprecated(reason: "Use changeDates instead")
  "Change the end date of the tournament"
  changeEndDate(endDate: DateTime!): ClosestToPinTournament @deprecated(reason: "Use changeDates instead")
  "Change the start- and\/or end date of the tournament. Must be in UTC time."
  changeDates(startDate: DateTime! endDate: DateTime): ClosestToPinTournament
  "Change the attempts per round of the tournament"
  changeAttemptsPerHole(attemptsPerHole: Int!): ClosestToPinTournament
  "Allow or Disallow participants to improve the score on the leaderboard"
  changeAllowMultipleTournamentAttempts(allowMultipleTournamentAttempts: Boolean!): ClosestToPinTournament
  "Change the holes played in the tournament"
  changeHoles(holes: [Int]!): ClosestToPinTournament
  "Change the holes played in the tournament"
  changeMaleTee(maleTee: String!): ClosestToPinTournament
  "Change the holes played in the tournament"
  changeFemaleTee(femaleTee: String!): ClosestToPinTournament
  "Change the units used when playing the tournament"
  changePinDifficulty(pinDifficulty: Pin!): ClosestToPinTournament
  "Change the firmness of the green for the tournament"
  changeGreenFirmness(greenFirmness: Firmness!): ClosestToPinTournament
  "Change the green stimp for the tournament"
  changeGreenStimp(greenStimp: Stimp!): ClosestToPinTournament
  "Change the wind for the tournament"
  changeWind(wind: WindMode!): ClosestToPinTournament
  "Change the course for the tournament"
  changeCourse(course: String! courseInstanceId: String): ClosestToPinTournament
  "Change the course for the tournament"
  changeLighting(lighting: Lighting!): ClosestToPinTournament
}

"Mutations on a Tournament"
type LongestDriveTournamentMutation implements TournamentMutationInterface & MediaAssetsMutationInterface & PaymentMutationInterface {
  "Delete the tournament"
  delete: Boolean
  "Ends the tournament"
  endTournament: Tournament
  "Change the name of the tournament"
  changeName(name: String!): Tournament
  "Change the description of the tournament"
  changeDescription(description: String): Tournament
  "Change the logo of the tournament"
  changeLogo(logoUrl: Url!): Tournament
  "Change the units used when playing the tournament"
  changeGameUnit(unit: GameUnit): Tournament
  "Set flag indicating that this is an indoor tournament"
  setIsIndoor(isIndoor: Boolean!): Tournament
  "Set flag indicating that this is a range tournament"
  setIsRange(isRange: Boolean!): Tournament
  "Set the tournament availability"
  setAvailability(availability: TournamentAvailability! makeAvailableForAllBays: Boolean): Tournament
  "Publish the draft as published"
  publish: Tournament
  "Un-publish the published version"
  unPublish: Tournament
  "Move a tournament and all it's round to a new starting date and time"
  moveStartTime(newStartTime: DateTime!): Tournament
  "The round default mutations"
  roundDefaults: TournamentRoundDefaultsMutation
  "Invite by emails"
  invite(emails: [String!]!): Boolean
  "Join the tournament"
  join: Invitation
  "Join a player to the tournament without the player having to accept an invitation"
  joinPlayer(playerId: String email: String): Invitation
  "Accept invitation"
  acceptInvitation(invitationIds: [ID!]): Invitation
  "Decline invitation"
  declineInvitation(invitationIds: [ID!]): Invitation
  "Withdraw invitation"
  withdrawInvitation(invitationIds: [ID!]): Invitation
  "Resend invitation"
  reInvite(invitationIds: [ID!]): Invitation
  "Add a sponsor to the tournament"
  addSponsor(sponsorId: String!): Tournament
  "Remove a sponsor from the tournament"
  removeSponsor(sponsorId: String!): Tournament
  "Replace the sponsor from the tournament with another sponsor"
  replaceSponsor(oldSponsorId: String! newSponsorId: String!): Tournament
  "Add or remove tags to the tournament"
  updateTags(addTags: [String] removeTags: [String]): Tournament
  "Method for updating the key values collections on the tournament"
  setKeyValues(addKeyValues: [KeyValueInput] removeKeyValues: [String!]): Tournament
  "Add or remove geo filters to the tournament"
  updateGeoFilters(field: GeoFilterFields addIncludedValues: [String] removeIncludedValues: [String] addExcludedValues: [String] removeExcludedValues: [String]): Tournament
  "Add default requirements for participation to the tournament.Only use 'templateOwner' argument if assigning template from a specific user, otherwise leave blank to use the Trackman global template."
  addParticipantRequirementsFromDefaultTemplate(templateOwner: String): Tournament
  "Update requirements for participation to the tournament.Not passing a value for a criteria will remove it, ie. even if you do not change an existing criteriait must still be provided in order to keep it."
  updateParticipantRequirements(description: String age: ageInput gender: genderInput handicapRange: handicapRangeInput trackmanHandicap: trackmanHandicapInput category: categoryInput): Tournament
  "Remove requirements for participation from the tournament"
  removeParticipantRequirements: Tournament
  "Update group for participation in the tournament. Renaming an existing group will delete the old group and create a new one.Not passing a value for a criteria will remove it, ie. even if you do not change an existing criteriait must still be provided in order to keep it."
  updateParticipantGroup(name: String! description: String age: ageInput gender: genderInput handicapRange: handicapRangeInput trackmanHandicap: trackmanHandicapInput category: categoryInput): Tournament
  "Remove a participant group from the tournament"
  removeParticipantGroup(name: String!): Tournament
  "Remove all participant groups from the tournament"
  removeAllParticipantGroups: Tournament
  "Add or remove which locations this tournament is available."
  setLocations(addLocations: [NonEmptyString] removeLocations: [NonEmptyString] setLocations: [NonEmptyString] selectAll: Boolean): Tournament @deprecated(reason: "No longer supported.")
  "Reset the MaxScoreMethod for all rounds in the order of merit tournament to Default."
  resetMaxScoringMethodForAllRounds: Tournament
  "Add default image to the tournament"
  addDefaultImage(mediaId: ID!): MediaAssetsInterface
  "Add media assets to the tournament"
  addMediaAssets(mediaId: ID! mediaAssetKind: [MediaAssetKind]!): MediaAssetsInterface
  "Remove media assets from the tournament"
  removeMediaAssets(mediaAssetKind: [MediaAssetKind!]!): MediaAssetsInterface
  "Remove all media assets, and fallback to default media assets"
  resetMediaAssets: MediaAssetsInterface
  "Enable payment for the tournament. Payment needs to be configured for each location where the tournament is available."
  enablePayment: Tournament
  "Disable payment for the tournament. Please note that the existing payment configuration will be deleted."
  disablePayment: Tournament
  "change the start time of the sign up"
  changeSignUpStartTime(signUpStartTime: DateTime): Tournament
  "change the end time of the sign up"
  changeSignUpEndTime(signUpEndTime: DateTime): Tournament
  "change the payment configuration of a location"
  changeLocationPaymentConfiguration(locationId: ID! fee: NonNegativeFloat flags: [Int]): Tournament
  "add a location to this tournament"
  addLocation(locationId: ID!): Tournament
  "remove a location from this tournament"
  removeLocation(locationId: ID!): Tournament
  "select all facility locations for this tournament"
  selectAllLocations: Tournament
  "deSelect all facility locations for this tournament"
  deSelectAllLocations: Tournament
  "filter out the locations that are not configured for payment"
  filterOutLocationsNotConfiguredForPayment: Tournament
  "Change if the tournament has an end date"
  changeHasEndDate(hasEndDate: Boolean!): LongestDriveTournament @deprecated(reason: "Use changeDates instead")
  "Change the end date of the tournament"
  changeEndDate(endDate: DateTime!): LongestDriveTournament @deprecated(reason: "Use changeDates instead")
  "Change the start- and\/or end date of the tournament. Must be in UTC time."
  changeDates(startDate: DateTime! endDate: DateTime): LongestDriveTournament
  "Allow or disallow participants to improve the score on the leaderboard"
  changeAllowMultipleTournamentAttempts(allowMultipleTournamentAttempts: Boolean!): LongestDriveTournament
  "Change the number of shots per round of the tournament"
  changeShotsPerRound(shotsPerRound: Int!): LongestDriveTournament
  "Change the time limit of the tournament"
  changeTimeLimit(timeLimit: TimeSpan!): LongestDriveTournament
  "Change the firmness of the fairway for the tournament"
  changeFairwayFirmness(fairwayFirmness: Firmness!): LongestDriveTournament
  "Change the width of the fairway for the tournament"
  changeFairwayWidth(fairwayWidth: Int!): LongestDriveTournament
  "Change the difficulty of the tournament"
  changeDifficulty(difficulty: longestDriveTournamentDifficulty!): LongestDriveTournament
  "Change the distance type of the tournament"
  changeDistanceType(distanceType: tournamentDistanceType!): LongestDriveTournament
  "Turn on or off the conversion to use normalized values"
  changeConversion(converted: Boolean!): LongestDriveTournament
  "Change the number of rounds of the tournament"
  changeNumberOfRounds(numberOfRounds: Int!): LongestDriveTournament
  "Allows to extend or reduce the grace period of the tournament leaderboard, to include or exclude records backed up after the tournament has ended, but which were played in the correct date range."
  changeLeaderboardGracePeriod(syncGracePeriodInMinutes: Int!): LongestDriveTournament
}

"Mutations on a Tournament"
type BullsEyeTournamentMutation implements TournamentMutationInterface & MediaAssetsMutationInterface & PaymentMutationInterface {
  "Delete the tournament"
  delete: Boolean
  "Ends the tournament"
  endTournament: Tournament
  "Change the name of the tournament"
  changeName(name: String!): Tournament
  "Change the description of the tournament"
  changeDescription(description: String): Tournament
  "Change the logo of the tournament"
  changeLogo(logoUrl: Url!): Tournament
  "Change the units used when playing the tournament"
  changeGameUnit(unit: GameUnit): Tournament
  "Set flag indicating that this is an indoor tournament"
  setIsIndoor(isIndoor: Boolean!): Tournament
  "Set flag indicating that this is a range tournament"
  setIsRange(isRange: Boolean!): Tournament
  "Set the tournament availability"
  setAvailability(availability: TournamentAvailability! makeAvailableForAllBays: Boolean): Tournament
  "Publish the draft as published"
  publish: Tournament
  "Un-publish the published version"
  unPublish: Tournament
  "Move a tournament and all it's round to a new starting date and time"
  moveStartTime(newStartTime: DateTime!): Tournament
  "The round default mutations"
  roundDefaults: TournamentRoundDefaultsMutation
  "Invite by emails"
  invite(emails: [String!]!): Boolean
  "Join the tournament"
  join: Invitation
  "Join a player to the tournament without the player having to accept an invitation"
  joinPlayer(playerId: String email: String): Invitation
  "Accept invitation"
  acceptInvitation(invitationIds: [ID!]): Invitation
  "Decline invitation"
  declineInvitation(invitationIds: [ID!]): Invitation
  "Withdraw invitation"
  withdrawInvitation(invitationIds: [ID!]): Invitation
  "Resend invitation"
  reInvite(invitationIds: [ID!]): Invitation
  "Add a sponsor to the tournament"
  addSponsor(sponsorId: String!): Tournament
  "Remove a sponsor from the tournament"
  removeSponsor(sponsorId: String!): Tournament
  "Replace the sponsor from the tournament with another sponsor"
  replaceSponsor(oldSponsorId: String! newSponsorId: String!): Tournament
  "Add or remove tags to the tournament"
  updateTags(addTags: [String] removeTags: [String]): Tournament
  "Method for updating the key values collections on the tournament"
  setKeyValues(addKeyValues: [KeyValueInput] removeKeyValues: [String!]): Tournament
  "Add or remove geo filters to the tournament"
  updateGeoFilters(field: GeoFilterFields addIncludedValues: [String] removeIncludedValues: [String] addExcludedValues: [String] removeExcludedValues: [String]): Tournament
  "Add default requirements for participation to the tournament.Only use 'templateOwner' argument if assigning template from a specific user, otherwise leave blank to use the Trackman global template."
  addParticipantRequirementsFromDefaultTemplate(templateOwner: String): Tournament
  "Update requirements for participation to the tournament.Not passing a value for a criteria will remove it, ie. even if you do not change an existing criteriait must still be provided in order to keep it."
  updateParticipantRequirements(description: String age: ageInput gender: genderInput handicapRange: handicapRangeInput trackmanHandicap: trackmanHandicapInput category: categoryInput): Tournament
  "Remove requirements for participation from the tournament"
  removeParticipantRequirements: Tournament
  "Update group for participation in the tournament. Renaming an existing group will delete the old group and create a new one.Not passing a value for a criteria will remove it, ie. even if you do not change an existing criteriait must still be provided in order to keep it."
  updateParticipantGroup(name: String! description: String age: ageInput gender: genderInput handicapRange: handicapRangeInput trackmanHandicap: trackmanHandicapInput category: categoryInput): Tournament
  "Remove a participant group from the tournament"
  removeParticipantGroup(name: String!): Tournament
  "Remove all participant groups from the tournament"
  removeAllParticipantGroups: Tournament
  "Add or remove which locations this tournament is available."
  setLocations(addLocations: [NonEmptyString] removeLocations: [NonEmptyString] setLocations: [NonEmptyString] selectAll: Boolean): Tournament @deprecated(reason: "No longer supported.")
  "Reset the MaxScoreMethod for all rounds in the order of merit tournament to Default."
  resetMaxScoringMethodForAllRounds: Tournament
  "Add default image to the tournament"
  addDefaultImage(mediaId: ID!): MediaAssetsInterface
  "Add media assets to the tournament"
  addMediaAssets(mediaId: ID! mediaAssetKind: [MediaAssetKind]!): MediaAssetsInterface
  "Remove media assets from the tournament"
  removeMediaAssets(mediaAssetKind: [MediaAssetKind!]!): MediaAssetsInterface
  "Remove all media assets, and fallback to default media assets"
  resetMediaAssets: MediaAssetsInterface
  "Enable payment for the tournament. Payment needs to be configured for each location where the tournament is available."
  enablePayment: Tournament
  "Disable payment for the tournament. Please note that the existing payment configuration will be deleted."
  disablePayment: Tournament
  "change the start time of the sign up"
  changeSignUpStartTime(signUpStartTime: DateTime): Tournament
  "change the end time of the sign up"
  changeSignUpEndTime(signUpEndTime: DateTime): Tournament
  "change the payment configuration of a location"
  changeLocationPaymentConfiguration(locationId: ID! fee: NonNegativeFloat flags: [Int]): Tournament
  "add a location to this tournament"
  addLocation(locationId: ID!): Tournament
  "remove a location from this tournament"
  removeLocation(locationId: ID!): Tournament
  "select all facility locations for this tournament"
  selectAllLocations: Tournament
  "deSelect all facility locations for this tournament"
  deSelectAllLocations: Tournament
  "filter out the locations that are not configured for payment"
  filterOutLocationsNotConfiguredForPayment: Tournament
  "Change if tournament has end date"
  changeHasEndDate(hasEndDate: Boolean!): BullsEyeTournament @deprecated(reason: "Use changeDates instead")
  "Change the end date of the tournament"
  changeEndDate(endDate: DateTime!): BullsEyeTournament @deprecated(reason: "Use changeDates instead")
  "Change the start- and\/or end date of the tournament. Must be in UTC time."
  changeDates(startDate: DateTime! endDate: DateTime): BullsEyeTournament
  "Allow or disallow participants to improve the score on the leaderboard"
  changeAllowMultipleTournamentAttempts(allowMultipleTournamentAttempts: Boolean!): BullsEyeTournament
  "Change the distance type of the tournament"
  changeDistanceType(distanceType: tournamentDistanceType!): BullsEyeTournament
  "Change the number of rounds of the tournament"
  changeNumberOfRounds(numberOfRounds: Int!): BullsEyeTournament
  "Change the number of shots per round of the tournament"
  changeShotsPerRound(shotsPerRound: Int!): BullsEyeTournament
  "Allows to extend or reduce the grace period of the tournament leaderboard, to include or exclude records backed up after the tournament has ended, but which were played in the correct date range."
  changeLeaderboardGracePeriod(syncGracePeriodInMinutes: Int!): BullsEyeTournament
}

"The tournament description"
type OrderOfMeritTournament implements CourseTournament & Tournament & KeyValuesInterfaceType & MediaAssetsInterface & TagsInterfaceTypeOfStringType & Node {
  "The time the resource was created"
  createdAt: DateTime!
  "The internal database id"
  dbId: String
  "The time the resource was last updated"
  lastUpdatedAt: DateTime!
  "The facility that owns the resource"
  facility: Facility
  "The list of key values"
  keyValues: [KeyValue!]
  "The list of key values added"
  keyValue(key: String!): String
  "Has any key value been added"
  hasKeyValue(key: String!): Boolean
  "The list of media assets"
  mediaAssets: [MediaAsset!]
  "The list of tags"
  tags: [String!]
  "Has any tags"
  hasTag(tag: String!): Boolean
  id: ID!
  "Verify that the tournament is ready to get published"
  isPublishable: Boolean
  "Get version info about the draft and the published version of the tournament"
  versionInfo: VersionInfo
  "The tournament type"
  type: TournamentTypes
  "Where the tournament is available"
  availability: TournamentAvailability
  "If true the tournament can get played everywhere if the participant is invited. If false it can only get played in tha facility that have created it"
  availableEverywhere: Boolean!
  "The background image for the tournament"
  backgroundImage: URL
  "The logo for the tournament"
  logo: URL
  description("Format to convert the markdown to" as: MkDownTypes = MKDOWN): String
  "The start date and time for the tournament"
  startDate: DateTime!
  "The end date and time for the tournament"
  endDate: DateTime
  "Check if there is an end date for the tournament"
  hasEndDate: Boolean!
  "The name of the tournament"
  name: String
  "The tournament settings"
  settings: TournamentSettings
  "The unit system used when playing the tournament."
  unit: GameUnit
  "The tournament is available on the listed facilities"
  availableOn: [Facility!]
  "Lists with all the teams in the tournament"
  teams: Teams
  "Lists with all the participants"
  participants: Invitations
  "My invitation for this tournament"
  invitation: Invitation
  locations: TournamentLocations
  "The sponsors for this tournament."
  sponsors: [Sponsor]
  "The state of the tournament. The three states are not started, started and completed"
  tournamentState: TournamentState
  "A flag indicating that the tournament is featured in our applications"
  isFeatured: Boolean
  "A flag indicating that this is an indoor tournament"
  isIndoor: Boolean
  "A flag indicating that this is a range tournament"
  isRange: Boolean
  "A flag indicating that this is a team tournament"
  isTeam: Boolean
  "The list of products this tournament is a part of"
  products: [userHasPaid]
  participantGroups: [ParticipantGroup]
  participantRequirements: ParticipantGroup
  "The settings that applies for all teams participating in this tournament"
  teamSettings: TournamentTeamSettingsType
  "Geo location filters for this tournament"
  geoFilters: TournamentGeoFilterType
  "A flag indicating whether any of the rounds in an order of merit tournament has non default max scoring."
  anyRoundHasNonDefaultMaxScoringMethod: Boolean
  "Participant progress in the tournament"
  participantProgress(particpantIds: [[ID]!]! roundIds: [ID] queryTime: DateTime): [TournamentProgressInterface]
  "Team handicap in the tournament"
  teamHandicap(team: CalculateTeamHandicapInput): Int
  "Indicates whether tournament is free or paid"
  isPaymentEnabled: Boolean
  "Sign up start time for this tournament. Can be null"
  signUpStartTime: DateTime
  "Sign up end time for this tournament. Can be null"
  signUpEndTime: DateTime
  "the payment configuration for each one of the locations available for this tournament"
  locationsConfiguration: [LocationConfiguration]
  "The duration (time length) of the tournament"
  duration: TimeSpan
  "A tournament round"
  round(roundNumber: Int roundId: ID): TournamentRound
  "The tournament rounds"
  rounds: [TournamentRound!]
  "Number of rounds"
  numberOfRounds: PositiveInt
  "Tournament has overlapping rounds"
  hasOverlappingRounds: Boolean
  "The leaderboard for this tournament"
  leaderboard(hcpFrom: Float hcpTo: Float gender: Gender participantGroupId: String holeNumber: Int queryTime: DateTime): Leaderboard
  "The leaderboard for the round"
  roundLeaderboard(hcpFrom: Float hcpTo: Float gender: Gender participantGroupId: String holeNumber: Int queryTime: DateTime roundId: ID!): RoundLeaderboard
  "The leaderboard for the in-round game"
  embeddedGameLeaderboard(hcpFrom: Float hcpTo: Float gender: Gender participantGroupId: String holeNumber: Int! queryTime: DateTime roundId: ID!): EmbeddedGameLeaderboardUnion
  "The leaderboard for the in-round Closest To Pin game"
  closestToPinEmbeddedGameLeaderboard(hcpFrom: Float hcpTo: Float gender: Gender participantGroupId: String holeNumber: Int! queryTime: DateTime roundId: ID!): ClosestToPin
  "The leaderboard for the in-round Longest Drive game"
  longestDriveEmbeddedGameLeaderboard(hcpFrom: Float hcpTo: Float gender: Gender participantGroupId: String holeNumber: Int! queryTime: DateTime roundId: ID!): LongestDrive
  "The game summary leaderboard for birdie streak, GIR streak etc."
  gameSummaryLeaderboard(kind: GameSummaryKinds roundId: ID gender: Gender fromUtc: DateTime toUtc: DateTime skip: Int take: Int): GameSummaryLeaderboardRecordTypeCollectionSegment @deprecated(reason: "Use otherLeaderboards instead. This field will be removed in the future.")
  "Other side-bed leaderboards like birdie streak, GIR streak etc."
  otherLeaderboards(hcpFrom: Float hcpTo: Float gender: Gender participantGroupId: String holeNumber: Int queryTime: DateTime kind: OtherLeaderboardsKind! roundId: ID): OtherLeaderboards
  "The aggregated leaderboard for in-round closest to the pin games"
  aggregatedClosestToPinLeaderboard(hcpFrom: Float hcpTo: Float gender: Gender participantGroupId: String holeNumber: Int queryTime: DateTime roundId: ID!): AggregatedClosestToPinLeaderboard
  oomPointsDistributionTable(numberOfParticipants: Int top: Int): DistributionTable
}

"The tournament description"
type MultiRoundTournament implements CourseTournament & Tournament & KeyValuesInterfaceType & MediaAssetsInterface & TagsInterfaceTypeOfStringType & Node {
  "The time the resource was created"
  createdAt: DateTime!
  "The internal database id"
  dbId: String
  "The time the resource was last updated"
  lastUpdatedAt: DateTime!
  "The facility that owns the resource"
  facility: Facility
  "The list of key values"
  keyValues: [KeyValue!]
  "The list of key values added"
  keyValue(key: String!): String
  "Has any key value been added"
  hasKeyValue(key: String!): Boolean
  "The list of media assets"
  mediaAssets: [MediaAsset!]
  "The list of tags"
  tags: [String!]
  "Has any tags"
  hasTag(tag: String!): Boolean
  id: ID!
  "Verify that the tournament is ready to get published"
  isPublishable: Boolean
  "Get version info about the draft and the published version of the tournament"
  versionInfo: VersionInfo
  "The tournament type"
  type: TournamentTypes
  "Where the tournament is available"
  availability: TournamentAvailability
  "If true the tournament can get played everywhere if the participant is invited. If false it can only get played in tha facility that have created it"
  availableEverywhere: Boolean!
  "The background image for the tournament"
  backgroundImage: URL
  "The logo for the tournament"
  logo: URL
  description("Format to convert the markdown to" as: MkDownTypes = MKDOWN): String
  "The start date and time for the tournament"
  startDate: DateTime!
  "The end date and time for the tournament"
  endDate: DateTime
  "Check if there is an end date for the tournament"
  hasEndDate: Boolean!
  "The name of the tournament"
  name: String
  "The tournament settings"
  settings: TournamentSettings
  "The unit system used when playing the tournament."
  unit: GameUnit
  "The tournament is available on the listed facilities"
  availableOn: [Facility!]
  "Lists with all the teams in the tournament"
  teams: Teams
  "Lists with all the participants"
  participants: Invitations
  "My invitation for this tournament"
  invitation: Invitation
  locations: TournamentLocations
  "The sponsors for this tournament."
  sponsors: [Sponsor]
  "The state of the tournament. The three states are not started, started and completed"
  tournamentState: TournamentState
  "A flag indicating that the tournament is featured in our applications"
  isFeatured: Boolean
  "A flag indicating that this is an indoor tournament"
  isIndoor: Boolean
  "A flag indicating that this is a range tournament"
  isRange: Boolean
  "A flag indicating that this is a team tournament"
  isTeam: Boolean
  "The list of products this tournament is a part of"
  products: [userHasPaid]
  participantGroups: [ParticipantGroup]
  participantRequirements: ParticipantGroup
  "The settings that applies for all teams participating in this tournament"
  teamSettings: TournamentTeamSettingsType
  "Geo location filters for this tournament"
  geoFilters: TournamentGeoFilterType
  "A flag indicating whether any of the rounds in an order of merit tournament has non default max scoring."
  anyRoundHasNonDefaultMaxScoringMethod: Boolean
  "Participant progress in the tournament"
  participantProgress(particpantIds: [[ID]!]! roundIds: [ID] queryTime: DateTime): [TournamentProgressInterface]
  "Team handicap in the tournament"
  teamHandicap(team: CalculateTeamHandicapInput): Int
  "Indicates whether tournament is free or paid"
  isPaymentEnabled: Boolean
  "Sign up start time for this tournament. Can be null"
  signUpStartTime: DateTime
  "Sign up end time for this tournament. Can be null"
  signUpEndTime: DateTime
  "the payment configuration for each one of the locations available for this tournament"
  locationsConfiguration: [LocationConfiguration]
  "The duration (time length) of the tournament"
  duration: TimeSpan
  "A tournament round"
  round(roundNumber: Int roundId: ID): TournamentRound
  "The tournament rounds"
  rounds: [TournamentRound!]
  "Number of rounds"
  numberOfRounds: PositiveInt
  "Tournament has overlapping rounds"
  hasOverlappingRounds: Boolean
  "The leaderboard for this tournament"
  leaderboard(hcpFrom: Float hcpTo: Float gender: Gender participantGroupId: String holeNumber: Int queryTime: DateTime): Leaderboard
  "The leaderboard for the round"
  roundLeaderboard(hcpFrom: Float hcpTo: Float gender: Gender participantGroupId: String holeNumber: Int queryTime: DateTime roundId: ID!): RoundLeaderboard
  "The leaderboard for the in-round game"
  embeddedGameLeaderboard(hcpFrom: Float hcpTo: Float gender: Gender participantGroupId: String holeNumber: Int! queryTime: DateTime roundId: ID!): EmbeddedGameLeaderboardUnion
  "The leaderboard for the in-round Closest To Pin game"
  closestToPinEmbeddedGameLeaderboard(hcpFrom: Float hcpTo: Float gender: Gender participantGroupId: String holeNumber: Int! queryTime: DateTime roundId: ID!): ClosestToPin
  "The leaderboard for the in-round Longest Drive game"
  longestDriveEmbeddedGameLeaderboard(hcpFrom: Float hcpTo: Float gender: Gender participantGroupId: String holeNumber: Int! queryTime: DateTime roundId: ID!): LongestDrive
  "The game summary leaderboard for birdie streak, GIR streak etc."
  gameSummaryLeaderboard(kind: GameSummaryKinds roundId: ID gender: Gender fromUtc: DateTime toUtc: DateTime skip: Int take: Int): GameSummaryLeaderboardRecordTypeCollectionSegment @deprecated(reason: "Use otherLeaderboards instead. This field will be removed in the future.")
  "Other side-bed leaderboards like birdie streak, GIR streak etc."
  otherLeaderboards(hcpFrom: Float hcpTo: Float gender: Gender participantGroupId: String holeNumber: Int queryTime: DateTime kind: OtherLeaderboardsKind! roundId: ID): OtherLeaderboards
  "The aggregated leaderboard for in-round closest to the pin games"
  aggregatedClosestToPinLeaderboard(hcpFrom: Float hcpTo: Float gender: Gender participantGroupId: String holeNumber: Int queryTime: DateTime roundId: ID!): AggregatedClosestToPinLeaderboard
  oomPointsDistributionTable(numberOfParticipants: Int top: Int): DistributionTable
}

"The tournament description"
type ClosestToPinTournament implements Tournament & KeyValuesInterfaceType & MediaAssetsInterface & TagsInterfaceTypeOfStringType & Node {
  "The time the resource was created"
  createdAt: DateTime!
  "The internal database id"
  dbId: String
  "The time the resource was last updated"
  lastUpdatedAt: DateTime!
  "The facility that owns the resource"
  facility: Facility
  "The list of key values"
  keyValues: [KeyValue!]
  "The list of key values added"
  keyValue(key: String!): String
  "Has any key value been added"
  hasKeyValue(key: String!): Boolean
  "The list of media assets"
  mediaAssets: [MediaAsset!]
  "The list of tags"
  tags: [String!]
  "Has any tags"
  hasTag(tag: String!): Boolean
  id: ID!
  "Verify that the tournament is ready to get published"
  isPublishable: Boolean
  "Get version info about the draft and the published version of the tournament"
  versionInfo: VersionInfo
  "The tournament type"
  type: TournamentTypes
  "Where the tournament is available"
  availability: TournamentAvailability
  "If true the tournament can get played everywhere if the participant is invited. If false it can only get played in tha facility that have created it"
  availableEverywhere: Boolean!
  "The background image for the tournament"
  backgroundImage: URL
  "The logo for the tournament"
  logo: URL
  description("Format to convert the markdown to" as: MkDownTypes = MKDOWN): String
  "The start date and time for the tournament"
  startDate: DateTime!
  "The end date and time for the tournament"
  endDate: DateTime
  "Check if there is an end date for the tournament"
  hasEndDate: Boolean!
  "The name of the tournament"
  name: String
  "The tournament settings"
  settings: TournamentSettings
  "The unit system used when playing the tournament."
  unit: GameUnit
  "The tournament is available on the listed facilities"
  availableOn: [Facility!]
  "Lists with all the teams in the tournament"
  teams: Teams
  "Lists with all the participants"
  participants: Invitations
  "My invitation for this tournament"
  invitation: Invitation
  locations: TournamentLocations
  "The sponsors for this tournament."
  sponsors: [Sponsor]
  "The state of the tournament. The three states are not started, started and completed"
  tournamentState: TournamentState
  "A flag indicating that the tournament is featured in our applications"
  isFeatured: Boolean
  "A flag indicating that this is an indoor tournament"
  isIndoor: Boolean
  "A flag indicating that this is a range tournament"
  isRange: Boolean
  "A flag indicating that this is a team tournament"
  isTeam: Boolean
  "The list of products this tournament is a part of"
  products: [userHasPaid]
  participantGroups: [ParticipantGroup]
  participantRequirements: ParticipantGroup
  "The settings that applies for all teams participating in this tournament"
  teamSettings: TournamentTeamSettingsType
  "Geo location filters for this tournament"
  geoFilters: TournamentGeoFilterType
  "A flag indicating whether any of the rounds in an order of merit tournament has non default max scoring."
  anyRoundHasNonDefaultMaxScoringMethod: Boolean
  "Participant progress in the tournament"
  participantProgress(particpantIds: [[ID]!]! roundIds: [ID] queryTime: DateTime): [TournamentProgressInterface]
  "Team handicap in the tournament"
  teamHandicap(team: CalculateTeamHandicapInput): Int
  "Indicates whether tournament is free or paid"
  isPaymentEnabled: Boolean
  "Sign up start time for this tournament. Can be null"
  signUpStartTime: DateTime
  "Sign up end time for this tournament. Can be null"
  signUpEndTime: DateTime
  "the payment configuration for each one of the locations available for this tournament"
  locationsConfiguration: [LocationConfiguration]
  "The number of attempts on each hole in the tournament."
  attempts: PositiveInt
  "Allow the participants to retry the tournament and improve the score."
  allowMultipleTournamentAttempts: Boolean
  "Tell what score is used to generate the leaderboard for the tournament."
  scoreOptions: ScoreOptions
  "The holes selected for the tournament."
  holes: [TournamentHole]
  "The holes available for the tournament"
  availableHoles: [Int]
  "The tee selected for male players in the tournament."
  maleTee: String
  "The tee selected for female players in the tournament."
  femaleTee: String
  "Course Instance Id, for Range"
  courseInstanceId: String
  "The course used for the tournament"
  course: Course
  gameSettings: ClosestToPinGameSettings
  "The leaderboard for this tournament"
  leaderboard(hcpFrom: Float hcpTo: Float gender: Gender holeNumber: Int): ClosestToPinLeaderboard
}

"The tournament description"
type LongestDriveTournament implements Tournament & KeyValuesInterfaceType & MediaAssetsInterface & TagsInterfaceTypeOfStringType & Node {
  "The time the resource was created"
  createdAt: DateTime!
  "The internal database id"
  dbId: String
  "The time the resource was last updated"
  lastUpdatedAt: DateTime!
  "The facility that owns the resource"
  facility: Facility
  "The list of key values"
  keyValues: [KeyValue!]
  "The list of key values added"
  keyValue(key: String!): String
  "Has any key value been added"
  hasKeyValue(key: String!): Boolean
  "The list of media assets"
  mediaAssets: [MediaAsset!]
  "The list of tags"
  tags: [String!]
  "Has any tags"
  hasTag(tag: String!): Boolean
  id: ID!
  "Verify that the tournament is ready to get published"
  isPublishable: Boolean
  "Get version info about the draft and the published version of the tournament"
  versionInfo: VersionInfo
  "The tournament type"
  type: TournamentTypes
  "Where the tournament is available"
  availability: TournamentAvailability
  "If true the tournament can get played everywhere if the participant is invited. If false it can only get played in tha facility that have created it"
  availableEverywhere: Boolean!
  "The background image for the tournament"
  backgroundImage: URL
  "The logo for the tournament"
  logo: URL
  description("Format to convert the markdown to" as: MkDownTypes = MKDOWN): String
  "The start date and time for the tournament"
  startDate: DateTime!
  "The end date and time for the tournament"
  endDate: DateTime
  "Check if there is an end date for the tournament"
  hasEndDate: Boolean!
  "The name of the tournament"
  name: String
  "The tournament settings"
  settings: TournamentSettings
  "The unit system used when playing the tournament."
  unit: GameUnit
  "The tournament is available on the listed facilities"
  availableOn: [Facility!]
  "Lists with all the teams in the tournament"
  teams: Teams
  "Lists with all the participants"
  participants: Invitations
  "My invitation for this tournament"
  invitation: Invitation
  locations: TournamentLocations
  "The sponsors for this tournament."
  sponsors: [Sponsor]
  "The state of the tournament. The three states are not started, started and completed"
  tournamentState: TournamentState
  "A flag indicating that the tournament is featured in our applications"
  isFeatured: Boolean
  "A flag indicating that this is an indoor tournament"
  isIndoor: Boolean
  "A flag indicating that this is a range tournament"
  isRange: Boolean
  "A flag indicating that this is a team tournament"
  isTeam: Boolean
  "The list of products this tournament is a part of"
  products: [userHasPaid]
  participantGroups: [ParticipantGroup]
  participantRequirements: ParticipantGroup
  "The settings that applies for all teams participating in this tournament"
  teamSettings: TournamentTeamSettingsType
  "Geo location filters for this tournament"
  geoFilters: TournamentGeoFilterType
  "A flag indicating whether any of the rounds in an order of merit tournament has non default max scoring."
  anyRoundHasNonDefaultMaxScoringMethod: Boolean
  "Participant progress in the tournament"
  participantProgress(particpantIds: [[ID]!]! roundIds: [ID] queryTime: DateTime): [TournamentProgressInterface]
  "Team handicap in the tournament"
  teamHandicap(team: CalculateTeamHandicapInput): Int
  "Indicates whether tournament is free or paid"
  isPaymentEnabled: Boolean
  "Sign up start time for this tournament. Can be null"
  signUpStartTime: DateTime
  "Sign up end time for this tournament. Can be null"
  signUpEndTime: DateTime
  "the payment configuration for each one of the locations available for this tournament"
  locationsConfiguration: [LocationConfiguration]
  "The number of attempts on each hole in the tournament."
  attempts: PositiveInt
  "Allow the participants to retry the tournament and improve the score."
  allowMultipleTournamentAttempts: Boolean
  "The time limit in the tournament."
  timeLimit: TimeSpan
  "The fairway firmness in the tournament."
  fairwayFirmness: Firmness
  "The fairway width in the tournament."
  fairwayWidth: Int
  "The number of shots per round in the tournament."
  shotsPerRound: Int
  "The difficulty of the tournament."
  difficulty: longestDriveTournamentDifficulty
  "The leaderboard for this tournament"
  leaderboard(hcpFrom: Float hcpTo: Float gender: Gender participantGroupId: String queryTime: DateTime): LongestDriveLeaderboard
  "The number of rounds in the tournament."
  numberOfRounds: PositiveInt
  "The distance type set in the tournament."
  distance: tournamentDistanceType
  "The sync grace period that overrides the global grace period."
  syncGracePeriodInMinutes: Int
}

"The tournament description"
type BullsEyeTournament implements Tournament & KeyValuesInterfaceType & MediaAssetsInterface & TagsInterfaceTypeOfStringType & Node {
  "The time the resource was created"
  createdAt: DateTime!
  "The internal database id"
  dbId: String
  "The time the resource was last updated"
  lastUpdatedAt: DateTime!
  "The facility that owns the resource"
  facility: Facility
  "The list of key values"
  keyValues: [KeyValue!]
  "The list of key values added"
  keyValue(key: String!): String
  "Has any key value been added"
  hasKeyValue(key: String!): Boolean
  "The list of media assets"
  mediaAssets: [MediaAsset!]
  "The list of tags"
  tags: [String!]
  "Has any tags"
  hasTag(tag: String!): Boolean
  id: ID!
  "Verify that the tournament is ready to get published"
  isPublishable: Boolean
  "Get version info about the draft and the published version of the tournament"
  versionInfo: VersionInfo
  "The tournament type"
  type: TournamentTypes
  "Where the tournament is available"
  availability: TournamentAvailability
  "If true the tournament can get played everywhere if the participant is invited. If false it can only get played in tha facility that have created it"
  availableEverywhere: Boolean!
  "The background image for the tournament"
  backgroundImage: URL
  "The logo for the tournament"
  logo: URL
  description("Format to convert the markdown to" as: MkDownTypes = MKDOWN): String
  "The start date and time for the tournament"
  startDate: DateTime!
  "The end date and time for the tournament"
  endDate: DateTime
  "Check if there is an end date for the tournament"
  hasEndDate: Boolean!
  "The name of the tournament"
  name: String
  "The tournament settings"
  settings: TournamentSettings
  "The unit system used when playing the tournament."
  unit: GameUnit
  "The tournament is available on the listed facilities"
  availableOn: [Facility!]
  "Lists with all the teams in the tournament"
  teams: Teams
  "Lists with all the participants"
  participants: Invitations
  "My invitation for this tournament"
  invitation: Invitation
  locations: TournamentLocations
  "The sponsors for this tournament."
  sponsors: [Sponsor]
  "The state of the tournament. The three states are not started, started and completed"
  tournamentState: TournamentState
  "A flag indicating that the tournament is featured in our applications"
  isFeatured: Boolean
  "A flag indicating that this is an indoor tournament"
  isIndoor: Boolean
  "A flag indicating that this is a range tournament"
  isRange: Boolean
  "A flag indicating that this is a team tournament"
  isTeam: Boolean
  "The list of products this tournament is a part of"
  products: [userHasPaid]
  participantGroups: [ParticipantGroup]
  participantRequirements: ParticipantGroup
  "The settings that applies for all teams participating in this tournament"
  teamSettings: TournamentTeamSettingsType
  "Geo location filters for this tournament"
  geoFilters: TournamentGeoFilterType
  "A flag indicating whether any of the rounds in an order of merit tournament has non default max scoring."
  anyRoundHasNonDefaultMaxScoringMethod: Boolean
  "Participant progress in the tournament"
  participantProgress(particpantIds: [[ID]!]! roundIds: [ID] queryTime: DateTime): [TournamentProgressInterface]
  "Team handicap in the tournament"
  teamHandicap(team: CalculateTeamHandicapInput): Int
  "Indicates whether tournament is free or paid"
  isPaymentEnabled: Boolean
  "Sign up start time for this tournament. Can be null"
  signUpStartTime: DateTime
  "Sign up end time for this tournament. Can be null"
  signUpEndTime: DateTime
  "the payment configuration for each one of the locations available for this tournament"
  locationsConfiguration: [LocationConfiguration]
  "The leaderboard for this tournament"
  leaderboard(hcpFrom: Float hcpTo: Float gender: Gender holeNumber: Int): BullsEyeLeaderboard
  "Allow the participants to retry the tournament and improve the score."
  allowMultipleTournamentAttempts: Boolean
  "The number of rounds in the tournament."
  numberOfRounds: PositiveInt
  "The difficulty of the tournament."
  distance: tournamentDistanceType
  "The number of shots per round in the tournament."
  shotsPerRound: Int
  "The sync grace period that overrides the global grace period."
  syncGracePeriodInMinutes: Int
}

type IndoorSponsorCampaign implements SponsorCampaignV2 & Node {
  "The time the resource was created"
  createdAt: DateTime!
  "The internal database id"
  dbId: String
  "The time the resource was last updated"
  lastUpdatedAt: DateTime!
  "The facility that owns the resource"
  facility: Facility
  id: ID!
  title: String
  active: Boolean
  type: SponsorCampaignKinds
  "Is all courses covered by this campaign"
  allCourses: Boolean
  "The courses covered by this campaign"
  courses: [Course]
  "The sponsor shown on the given hole"
  holeSponsors: [HoleSponsorTypeV2]
}

type IndoorBaySponsorCampaign implements SponsorCampaignV2 & Node {
  "The time the resource was created"
  createdAt: DateTime!
  "The internal database id"
  dbId: String
  "The time the resource was last updated"
  lastUpdatedAt: DateTime!
  "The facility that owns the resource"
  facility: Facility
  id: ID!
  title: String
  active: Boolean
  type: SponsorCampaignKinds
  "The locations covered by this campaign"
  locations: [LocationInterfaceType]
  baySponsors: [BaySponsorType]
}

type RangeSponsorCampaign implements SponsorCampaignV2 & Node {
  "The time the resource was created"
  createdAt: DateTime!
  "The internal database id"
  dbId: String
  "The time the resource was last updated"
  lastUpdatedAt: DateTime!
  "The facility that owns the resource"
  facility: Facility
  id: ID!
  title: String
  active: Boolean
  type: SponsorCampaignKinds
  "Is all courses covered by this campaign"
  allCourses: Boolean
  "The courses covered by this campaign"
  courses: [Course]
  "The sponsor shown on the given hole"
  holeSponsors: [HoleSponsorTypeV2]
}

"Mutations on a sponsor campaign"
type IndoorSponsorCampaignMutation implements SponsorCampaignMutationInterfaceType {
  "Delete sponsor campaign"
  delete: Boolean
  "Update active state for this sponsor campaign"
  setActive(active: Boolean! = true): SponsorCampaignV2
  "Update title for this sponsor campaign"
  setTitle(title: NonEmptyString): SponsorCampaignV2
  "Change the name of the location"
  update(sponsorCampaign: SponsorCampaignInputTypeV2!): IndoorSponsorCampaign
}

"Mutations on a sponsor campaign"
type IndoorBaySponsorCampaignMutation implements SponsorCampaignMutationInterfaceType {
  "Delete sponsor campaign"
  delete: Boolean
  "Update active state for this sponsor campaign"
  setActive(active: Boolean! = true): SponsorCampaignV2
  "Update title for this sponsor campaign"
  setTitle(title: NonEmptyString): SponsorCampaignV2
  "Change the name of the location"
  update(sponsorCampaign: IndoorBaySponsorCampaignInputType!): IndoorBaySponsorCampaign
}

"Mutations on a sponsor campaign"
type RangeSponsorCampaignMutation implements SponsorCampaignMutationInterfaceType {
  "Delete sponsor campaign"
  delete: Boolean
  "Update active state for this sponsor campaign"
  setActive(active: Boolean! = true): SponsorCampaignV2
  "Update title for this sponsor campaign"
  setTitle(title: NonEmptyString): SponsorCampaignV2
  "Change the name of the location"
  update(sponsorCampaign: SponsorCampaignInputTypeV2!): RangeSponsorCampaign
}

type StrokeCircleTarget implements StrokeTargetInterface {
  "Target Distance"
  distance: Float!
  "Target Diameter"
  diameter: Float!
  "Target Tour Diameter"
  tourDiameter: Float!
  "Target Radius"
  radius: Float!
  "Target Tour Radius"
  tourRadius: Float!
  "Target handicap"
  hcp: Float!
  "Target type"
  type: String
}

type StrokeRectangleTarget implements StrokeTargetInterface {
  distance: Float!
  length: Float!
  width: Float!
  type: String
}

type StrokeCombineTarget implements StrokeTargetInterface {
  bucket: Int!
  meterDistance: Float!
  yardDistance: Float!
  type: String
}

type StrokeFixedDistanceTarget implements StrokeTargetInterface {
  distance: Float!
  type: String
}

type StrokeDriveTarget implements StrokeTargetInterface {
  level: Int!
  type: String
}

type userHasPaid {
  "The identifier for the product"
  productIdentifier: String
  "A flag indicating if the user has paid to be a part of this tournament or not"
  userHasPaid: Boolean
}

type ParticipantGroup {
  "The time the resource was created"
  createdAt: DateTime!
  "The internal database id"
  dbId: String
  "The graphql id of the participant group"
  id: String
  "The name of the participant group"
  name: String
  "The description of the participant group"
  description: String
  "The criteria for being part of the participant group"
  criteria: [ParticipationCriteria]
  "Validation information for the current player wrt. the criteria for this group"
  playerMeetAllCriteria: Boolean
}

type genderCriteria implements ParticipationCriteria {
  "The name of the criteria"
  name: String
  "The validation message when given value is tested against the criteria"
  validationMessage: String
  "The accepted gender for this criteria"
  gender: CriteriaGender
}

type handicapRangeCriteria implements ParticipationCriteria {
  "The name of the criteria"
  name: String
  "The validation message when given value is tested against the criteria"
  validationMessage: String
  "The start value of the range"
  start: Float!
  "The end value of the range"
  end: Float!
  "Whether or not this range includes the start point"
  includesStart: Boolean!
  "Whether or not this range includes the end point"
  includesEnd: Boolean!
}

type trackmanHandicapCriteria implements ParticipationCriteria {
  "The name of the criteria"
  name: String
  "The validation message when given value is tested against the criteria"
  validationMessage: String
  "The minimum number of played rounds for this criteria"
  requiredRounds: Int
}

type ageCriteria implements ParticipationCriteria {
  "The name of the criteria"
  name: String
  "The validation message when given value is tested against the criteria"
  validationMessage: String
  "The start value of the range"
  start: Int!
  "The end value of the range"
  end: Int!
  "Whether or not this range includes the start point"
  includesStart: Boolean!
  "Whether or not this range includes the end point"
  includesEnd: Boolean!
}

type categoryCriteria implements ParticipationCriteria {
  "The name of the criteria"
  name: String
  "The validation message when given value is tested against the criteria"
  validationMessage: String
  "The accepted category for this criteria"
  category: Category
}

input genderInput {
  name: String
  description: String
  active: Boolean
  "The accepted gender for this criteria"
  gender: CriteriaGender
}

input handicapRangeInput {
  name: String
  description: String
  active: Boolean
  "The start value of the range"
  start: Float!
  "The end value of the range"
  end: Float!
  "Whether or not this range includes the start point"
  includesStart: Boolean!
  "Whether or not this range includes the end point"
  includesEnd: Boolean!
}

input trackmanHandicapInput {
  name: String
  description: String
  active: Boolean
  "The minimum number of played rounds for this criteria"
  numberOfRoundsRequired: Int
}

input ageInput {
  name: String
  description: String
  active: Boolean
  "The start value of the range"
  start: Int!
  "The end value of the range"
  end: Int!
  "Whether or not this range includes the start point"
  includesStart: Boolean!
  "Whether or not this range includes the end point"
  includesEnd: Boolean!
}

input categoryInput {
  name: String
  description: String
  active: Boolean
  "The accepted category for this criteria"
  category: Category
}

type MrtTournamentProgress implements TournamentProgressInterface {
  kind: String
  participantGroups: [String]
  participant: PersonInfo
  isTeamProgress: Boolean
  "The rounds of the tournament that have been completed by the participant."
  rounds: [ID]
  roundsProgress: [RoundProgress]
}

type TeamTournamentProgress implements TournamentProgressInterface {
  kind: String
  participantGroups: [String]
  participant: PersonInfo
  isTeamProgress: Boolean
  rounds: [ID]
  roundsProgress: [RoundProgress]
}

type GameTournamentProgress implements TournamentProgressInterface {
  kind: String
  participantGroups: [String]
  participant: PersonInfo
  isTeamProgress: Boolean
  playerStatus: String
  autoJoin: Boolean
  playAsGuest: Boolean
  messageId: String
}

"The LocalTime scalar type is a local time string (i.e., with no associated timezone) in 24-hr HH:mm:ss."
scalar LocalTime

"The NonNegativeInt scalar type represents a unsigned 32-bit numeric non-fractional value equal to or greater than 0."
scalar NonNegativeInt

"The PositiveInt scalar type represents a signed 32-bit numeric non-fractional value of at least the value 1."
scalar PositiveInt

type TpsApplicationData implements ApplicationDataInterface {
  client: ApplicationClients
  applicationLayout: ApplicationLayout
  "All releases available for download"
  releases(identifier: String): ReleasesModel
  tournamentLayout(playerIds: [String!]): ApplicationLayout
  "The bay connected to this device"
  bay: SimulatorBay
  properties(appIdentifiers: [String!] specifiedLevel: ApplicationPropertyLevelsEnumType): [ApplicationProperty]
  "Is TPS allowed to connect to the devices having the supplied serial numbers"
  deviceValidation(serialNumbers: [String!] = [  ]): DeviceValidation
}

type RangeApplicationData implements ApplicationDataInterface {
  client: ApplicationClients
  applicationLayout: ApplicationLayout
  "All downloadable releases"
  releases(identifier: String): ReleasesModel
  tournamentLayout(playerIds: [String!]): ApplicationLayout
  "The bay connected to this device"
  bay: RangeBay
  properties(appIdentifiers: [String!] specifiedLevel: ApplicationPropertyLevelsEnumType): [ApplicationProperty]
}

type ApplicationLayoutBaseItem implements ApplicationLayoutGroupItemInterface {
  identifier: String
  type: String
  displayName: String
  link: String
}

type ApplicationLayoutCourseItem implements ApplicationLayoutGroupItemInterface {
  identifier: String
  type: String
  displayName: String
  version: String
  course: Course
}

type ApplicationLayoutTournamentItem implements ApplicationLayoutGroupItemInterface {
  identifier: String
  type: String
  displayName: String
  tournament: Tournament
}

type TpsApplicationDataMutations implements ApplicationDataMutationInterfaceType {
  "Creates a simulator bay on the facility with the supplied deviceId and serial number"
  createBay(name: NonEmptyString description: String = ""): SimulatorBay
}

type RangeApplicationDataMutations implements ApplicationDataMutationInterfaceType {
  "Creates a range bay on the facility with the supplied deviceId"
  createBay(name: NonEmptyString description: String = ""): RangeBay
}

type Partner {
  "The id of the partner"
  id: ID
  "The id of the partner"
  dbId: ID
  "The name of the partner"
  name: NonEmptyString
  "The unique key of the partner"
  key: NonEmptyString
  "The url of the partner logo"
  logoUrl: URL
  "The url of the partner info"
  infoUrl: URL
  "The consent list of the partner"
  consents: [ConsentInterfaceType!]
}

type TermsAndConditionsPartnerConsent implements ConsentInterfaceType {
  "The kind of the consent"
  kind: NonEmptyString
  "The key of the partner's consent"
  key: NonEmptyString
  "The title of the consent"
  title: String
  "The description of the consent"
  description: String
  "Mark the consent as mandatory"
  isMandatory: Boolean
  "Default value of the consent"
  isSelectedByDefault: Boolean
  "Mark the consent as persistent. The consent wishes be accepted, even if it is an optional"
  isPersistent: Boolean
  "The version of the consent"
  version: String
  "The info url of the consent"
  infoUrl: URL
  "The localization"
  localization: [PartnerConsentLocalized!]
}

type MarketingPartnerConsent implements ConsentInterfaceType {
  "The kind of the consent"
  kind: NonEmptyString
  "The key of the partner's consent"
  key: NonEmptyString
  "The title of the consent"
  title: String
  "The description of the consent"
  description: String
  "Mark the consent as mandatory"
  isMandatory: Boolean
  "Default value of the consent"
  isSelectedByDefault: Boolean
  "Mark the consent as persistent. The consent wishes be accepted, even if it is an optional"
  isPersistent: Boolean
  "The version of the consent"
  version: String
  "The info url of the consent"
  infoUrl: URL
  "The localization"
  localization: [PartnerConsentLocalized!]
}

type CoachDataSharingPartnerConsent implements ConsentInterfaceType {
  "The kind of the consent"
  kind: NonEmptyString
  "The key of the partner's consent"
  key: NonEmptyString
  "The title of the consent"
  title: String
  "The description of the consent"
  description: String
  "Mark the consent as mandatory"
  isMandatory: Boolean
  "Default value of the consent"
  isSelectedByDefault: Boolean
  "Mark the consent as persistent. The consent wishes be accepted, even if it is an optional"
  isPersistent: Boolean
  "The version of the consent"
  version: String
  "The info url of the consent"
  infoUrl: URL
  "The localization"
  localization: [PartnerConsentLocalized!]
}

type PrivacyPolicyPartnerConsent implements ConsentInterfaceType {
  "The kind of the consent"
  kind: NonEmptyString
  "The key of the partner's consent"
  key: NonEmptyString
  "The title of the consent"
  title: String
  "The description of the consent"
  description: String
  "Mark the consent as mandatory"
  isMandatory: Boolean
  "Default value of the consent"
  isSelectedByDefault: Boolean
  "Mark the consent as persistent. The consent wishes be accepted, even if it is an optional"
  isPersistent: Boolean
  "The version of the consent"
  version: String
  "The info url of the consent"
  infoUrl: URL
  "The localization"
  localization: [PartnerConsentLocalized!]
}

type SwingDataProcessingPartnerConsent implements ConsentInterfaceType {
  "The kind of the consent"
  kind: NonEmptyString
  "The key of the partner's consent"
  key: NonEmptyString
  "The title of the consent"
  title: String
  "The description of the consent"
  description: String
  "Mark the consent as mandatory"
  isMandatory: Boolean
  "Default value of the consent"
  isSelectedByDefault: Boolean
  "Mark the consent as persistent. The consent wishes be accepted, even if it is an optional"
  isPersistent: Boolean
  "The version of the consent"
  version: String
  "The info url of the consent"
  infoUrl: URL
  "The localization"
  localization: [PartnerConsentLocalized!]
}

type AgePartnerConsent implements ConsentInterfaceType {
  "The kind of the consent"
  kind: NonEmptyString
  "The key of the partner's consent"
  key: NonEmptyString
  "The title of the consent"
  title: String
  "The description of the consent"
  description: String
  "Mark the consent as mandatory"
  isMandatory: Boolean
  "Default value of the consent"
  isSelectedByDefault: Boolean
  "Mark the consent as persistent. The consent wishes be accepted, even if it is an optional"
  isPersistent: Boolean
  "The version of the consent"
  version: String
  "The info url of the consent"
  infoUrl: URL
  "The localization"
  localization: [PartnerConsentLocalized!]
  "Minimum value is used for the Age consent"
  minimumValue: Float
}

type WaiverPartnerConsent implements ConsentInterfaceType {
  "The kind of the consent"
  kind: NonEmptyString
  "The key of the partner's consent"
  key: NonEmptyString
  "The title of the consent"
  title: String
  "The description of the consent"
  description: String
  "Mark the consent as mandatory"
  isMandatory: Boolean
  "Default value of the consent"
  isSelectedByDefault: Boolean
  "Mark the consent as persistent. The consent wishes be accepted, even if it is an optional"
  isPersistent: Boolean
  "The version of the consent"
  version: String
  "The info url of the consent"
  infoUrl: URL
  "The localization"
  localization: [PartnerConsentLocalized!]
}

type PartnerConsent implements ConsentInterfaceType {
  "The kind of the consent"
  kind: NonEmptyString
  "The key of the partner's consent"
  key: NonEmptyString
  "The title of the consent"
  title: String
  "The description of the consent"
  description: String
  "Mark the consent as mandatory"
  isMandatory: Boolean
  "Default value of the consent"
  isSelectedByDefault: Boolean
  "Mark the consent as persistent. The consent wishes be accepted, even if it is an optional"
  isPersistent: Boolean
  "The version of the consent"
  version: String
  "The info url of the consent"
  infoUrl: URL
  "The localization"
  localization: [PartnerConsentLocalized!]
}

type PartnerConsentLocalized implements PartnerConsentLocalizedIterfaceType {
  "The country code"
  cultureCode: NonEmptyString
  "The key of the partner's consent"
  infoUrl: String
  "The title of the consent"
  title: String
  "The description of the consent"
  description: String
}

type players1stIntegrationDetails implements FacilityIntegrationResponse {
  providerKey: String
  name: String
  isEnabled: Boolean!
}

"The `Upload` scalar type represents a file upload."
scalar Upload

"Return all event data for a venue\/event"
type paidEvents {
  "The id of the event"
  id: Int
  "Description of the event"
  description: String
  "Can the event be booked"
  bookable: Boolean
  "Number of tickets available for the event"
  capacity: Int
  "The color code in hex"
  color: Int
  "The event id"
  eventId: String!
  "The title of the event"
  title: String!
  "Flags for the event"
  appliedFlags: [Int]
  "Ticket options for the event"
  ticketOption: [paidEventTicketOption]
  "Event has payouts enabled"
  payoutsEnabled: Boolean
  "The start date of the event"
  startDate: DateTime
  "The end date of the event"
  endDate: DateTime
  "The start date of the sign up period"
  signUpStartDate: DateTime
  "The end date of the sign up period"
  signUpEndDate: DateTime
  "Metadata used to store extra data"
  meta: String
}

enum ApplyPolicy {
  BEFORE_RESOLVER
  AFTER_RESOLVER
  VALIDATION
}

"Return all personal data on a profile"
type Me {
  "Information about equipment connected to a person"
  equipment: AllEquipment
  "Return all info abut the players TrackMan handicap"
  hcp: Hcp
  "Paged result for tournaments"
  tournaments(list: TournamentListKinds tournamentKinds: [TournamentTypes!] withPendingInvitation: Boolean = false isFeatured: Boolean isIndoor: Boolean isRange: Boolean isTeamTournament: Boolean isFeaturedPaid: Boolean locationIds: [String!] skip: Int take: Int): TournamentInterfaceTypeCollectionSegment
  "Paged result for planned rounds"
  plannedRounds(skip: Int take: Int): PlannedRoundTypeCollectionSegment
  "Tournaments that´s available for this player. Paged result of tournaments"
  availableTournaments(list: TournamentListKinds tournamentKinds: [TournamentTypes!] tags: [String!] skip: Int take: Int): TournamentInterfaceTypeCollectionSegment
  "List all your scorecards. You can filter and sort the list"
  scorecards(take: Int skip: Int completed: Boolean numberOfHolesToPlay: Int): [Scorecard]
  "Activities connected to a person"
  activities(includeHidden: Boolean kinds: [ActivityKind!] timeFrom: DateTime timeTo: DateTime skip: Int take: Int): PlayerActivityInterfaceTypeCollectionSegment
  "Summary for activities"
  activitySummary(timeFrom: DateTime timeTo: DateTime skip: Int take: Int): ActivitySummaryTypeCollectionSegment
  "Information about students for a coach"
  students: Students
  "My friendships"
  friends: Friendships
  "List the rounds you've played with someone."
  playedWith(take: Int skip: Int): [PlayedWith]
  "Return all permissions that is not bound to a facility or location. You have to combine this list with your facility permissions."
  permissions(domains: [String] permissionPattern: String "If you don't need domains your list wont have duplicates if you set noDomains to true" noDomains: Boolean): [PermissionInfo!]
  profile: Profile
  properties(application: String! facilityId: String locationId: String bayId: String specifiedLevel: ApplicationPropertyLevelsEnumType): [ApplicationPropertySetting]
  consents: UserConsentsResponse
}

"The tournament description"
interface Tournament {
  "The facility that owns the resource"
  facility: Facility
  "The tournament id"
  id: ID!
  "Database identifier"
  dbId: String
  "The name of the tournament"
  name: String
  description("Format to convert the markdown to" as: MkDownTypes = MKDOWN): String
  "The tournament type"
  type: TournamentTypes
  "Verify that the tournament is ready to get published"
  isPublishable: Boolean
  "The background image for the tournament"
  backgroundImage: URL
  "The logo for the tournament"
  logo: URL
  "The start date and time for the tournament"
  startDate: DateTime!
  "The end date and time for the tournament"
  endDate: DateTime
  "Check if there is an end date for the tournament"
  hasEndDate: Boolean!
  "Get version info abut the draft and the published version of the tournament"
  versionInfo: VersionInfo
  "The tournament settings"
  settings: TournamentSettings
  "If true the tournament can get played everywhere if the participant is invited. If false it can only get played in the facility that have created it"
  availableEverywhere: Boolean!
  "Where the tournament is available"
  availability: TournamentAvailability
  "Lists with all the teams in the tournament"
  teams: Teams
  "Lists with all the participants"
  participants: Invitations
  "My invitation for this tournament"
  invitation: Invitation
  "The locations where this tournament can be played"
  locations: TournamentLocations
  "The sponsors for this tournament"
  sponsors: [Sponsor]
  "The state of this tournament"
  tournamentState: TournamentState
  "A flag indicating that the tournament is featured in our applications"
  isFeatured: Boolean
  "A flag indicating that this is an indoor tournament"
  isIndoor: Boolean
  "A flag indicating that this is a range tournament"
  isRange: Boolean
  "A flag indicating that this is a team tournament"
  isTeam: Boolean
  "The list of products this tournament is a part of"
  products: [userHasPaid]
  "The unit system used when playing the tournament."
  unit: GameUnit
  "The participation groups for this tournament"
  participantGroups: [ParticipantGroup]
  "The participation requirements for this tournament"
  participantRequirements: ParticipantGroup
  "The settings that applies for all teams participating in this tournament"
  teamSettings: TournamentTeamSettingsType
  "Geo location filters for this tournament"
  geoFilters: TournamentGeoFilterType
  "A flag indicating whether any of the rounds in an order of merit tournament has non default max scoring."
  anyRoundHasNonDefaultMaxScoringMethod: Boolean
  "Participant progress in the tournament"
  participantProgress(particpantIds: [[ID]!]! roundIds: [ID] queryTime: DateTime): [TournamentProgressInterface]
  "Team handicap in the tournament"
  teamHandicap(team: CalculateTeamHandicapInput): Int
  "Indicates whether tournament is free or paid"
  isPaymentEnabled: Boolean
  "Sign up start time for this tournament. Can be null"
  signUpStartTime: DateTime
  "Sign up end time for this tournament. Can be null"
  signUpEndTime: DateTime
  "the payment configuration for each one of the locations available for this tournament"
  locationsConfiguration: [LocationConfiguration]
  "The list of key values added"
  keyValues: [KeyValue!]
  "The list of key values added"
  keyValue(key: String!): String
  "Has any key value been added"
  hasKeyValue(key: String!): Boolean
  "The list of media assets"
  mediaAssets: [MediaAsset!]
  "The list of tags"
  tags: [String!]
  "Has any tags"
  hasTag(tag: String!): Boolean
}

"A collections of helper functions"
type publicTools {
  "Retrieve the tournaments based on arguments"
  getTournamentsByDbId(tournamentDbIds: [String!]): [Tournament]
  "Retrieve the Scorecards based on arguments"
  getScorecardsByDbId(scorecardDbIds: [String!]!): [Scorecard]
  listAllowedScopes: [ApiResources!]
}

type Invitation implements Node {
  "The global object identification"
  id: ID!
  "The reply date and time"
  replyAt: DateTime
  "Is the invitation sent to a Trackman email"
  isTrackmanUser: Boolean
  "Information about the person"
  person: InvitationPerson
  "The status for this invitation"
  status: InvitationStatus
  "The email address this invitations was sent to."
  invitationEmail: String
  "The group(s) in the tournament the person belongs to."
  participantGroups: PlayerGroups
  "The tournament for this invitation"
  tournament: Tournament
  "Indicates whether the invitation is paid"
  isPaid: Boolean
  "Payment information"
  payment: PaymentInformation
}

"A segment of a collection."
type FacilityTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [Facility]
  totalCount: Int!
}

"A segment of a collection."
type LocationInterfaceTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [LocationInterfaceType]
  totalCount: Int!
}

input LatLonInputType {
  "The latitude of the location"
  lat: Float!
  "The longitude of the location"
  lon: Float!
}

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime

"A segment of a collection."
type CourseTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [Course]
  totalCount: Int!
}

"Global leaderboards"
type GlobalLeaderboards {
  "All hole in ones"
  holeInOneLeaderboard(facilityIds: [ID] countryCode: [String] gender: Gender fromUtc: DateTime toUtc: DateTime): [HoleInOneLeaderboardRecord!]
  "All completed 18 hole courses"
  coursePlayLeaderboard(facilityIds: [ID] countryCode: [String] courseIdentifier: String gender: Gender fromUtc: DateTime toUtc: DateTime): [CoursePlayLeaderboardRecord!]
  "Combine Test Leaderboard"
  combineTestLeaderboard(gender: Gender fromUtc: DateTime toUtc: DateTime hcpFrom: Float hcpTo: Float ageFrom: Int ageTo: Int target: CombineTestTarget countryCode: String "Include test taken outdoor or indoor or both. Default is tests taken outdoor." combineTestMode: CombineTestMode = OUTDOOR "Filter players by player category (Amateur, Professional)" playerCategory: PlayerCategory): CombineLeaderboard
}

type SystemInfo {
  version: SystemInfoVersion
}

type Persons {
  "Find the person with the corresponding email"
  searchByEmail(emails: [String]!): [PersonInfo]
  "Search persons"
  advanceSearch(byEmails: [String!] byFirstNames: [String!] byLastNames: [String!] byFullNames: [String!] byPlayerNames: [String!] byPhoneNumbers: [String!] byClaimSearchCriterias: [ClaimSearchCriteria!] caseSensitiveMatch: Boolean = false fullMatch: Boolean = true skip: Int take: Int): ProfileTypeCollectionSegment
  "Search persons in Person Search service"
  adminSearch("Search person by Email, Fullname, PlayerName" searchText: String! "Order by Email, Fullname, PlayerName, SearchText match" orderBy: [VisitorOrderBy!] "Search by Email, Fullname, PlayerName" searchBy: [SearchByEnum!]! "Search only active accounts" onlyActiveAccounts: Boolean! skip: Int take: Int): AdminPersonInfoTypeCollectionSegment
}

"Root container for range-related data"
type RangeRootQueryType {
  "A single bay by id and option version"
  bayById(id: ID!): RangeBay
  "A single launch area by id and option version"
  launchAreaById(id: ID!): LaunchAreaType
  "A single safety border by id and option version"
  netById(id: ID!): Net
  "A single target by id and option version"
  targetById(id: ID!): RangeTarget
  "A single configuration by id"
  configurationById(id: ID!): RangeConfigurationType
  "A single radar by id and option version"
  radarById(id: ID!): Radar
  "A single section by id and option version"
  sectionById(id: ID!): Section
}

"A collections of helper functions"
type AdminTools {
  "Convert a node id to a database id"
  getDbIdFromNodeId(nodeId: ID!): String
  "Get the object type from a node id"
  getTypeNameFromNodeId(nodeId: ID!): String
  "Convert a database id to a node id"
  getNodeIdFromDbId(dbId: String! nodeType: String!): String
  "Convert a tournament link or id to the new format"
  getNewTournamentLink(tournamentLink: String!): String
  scorecardIdsFromDbId(scorecardDbId: String scorecardDbIds: [String!]): [ID!]
}

interface ApplicationDataInterface {
  client: ApplicationClients
  applicationLayout: ApplicationLayout
  tournamentLayout(playerIds: [String!]): ApplicationLayout
  "All downloadable releases"
  releases(identifier: String): ReleasesModel
  bay: BayInterface
  "The settings of each application"
  properties(appIdentifiers: [String!]): [ApplicationProperty]
}

enum ApplicationClients {
  TPS
  RANGE_APP
  CONSUMER_APP
  TRACKMAN_PRO
}

"A segment of a collection."
type DomainUserAdminTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [Domain]
  totalCount: Int!
}

"Mutations on an Activity"
type ActivityMutation {
  "Mark the activity as hidden for the current user"
  hide: Boolean!
  "Un hide the activity for the current user"
  unHide: Boolean!
}

"Mutations on a Facility"
type FacilityMutation {
  "Mutations on a media"
  media: MediaMutation
  "Mutations on an album"
  album: AlbumMutation
  "Change the name of the facility"
  changeName(name: NonEmptyString!): Facility
  "Rotate facility courses without waiting for maintenance hours"
  rotateFacilityCourses: Boolean!
  "Update all properties in one go"
  update(name: String description: String address: AddressInput phoneNumber: String shopPhoneNumber: String email: EmailAddress urls: [UrlInput] openingHours: OpeningHoursInput appUsed: Boolean "Reset world location to default" defaultWorldLocation: Boolean "Overwrite default world location" worldLocation: LatLonInputType): Facility
  "Delete the facility"
  delete: Boolean
  "Create a tournament"
  createTournament(name: NonEmptyString! tournamentType: TournamentTypes! isTeamTournament: Boolean = false isGlobalTournament: Boolean = false isRange: Boolean = false): Tournament
  "Create a location"
  createLocation(name: String! description: String address: AddressInput! phoneNumber: String shopPhoneNumber: String email: EmailAddress urls: [UrlInput] tags: [LocationUrlTags] "Overwrite default world location" worldLocation: LatLonInputType): LocationInterfaceType
  "Create a new configuration for a location"
  createRangeConfiguration: Facility
  "Create a new sponsor campaign"
  createSponsorCampaign(sponsorCampaign: SponsorCampaignInputType!): SponsorCampaign @deprecated(reason: "Use the new mutations for for creating typed sponsor campaigns")
  "Create a new sponsor"
  createSponsor(name: String! logoUrl: Url! description: String): Sponsor
  "Create a new indoor sponsor campaign"
  createIndoorSponsorCampaign(sponsorCampaign: SponsorCampaignInputTypeV2!): IndoorSponsorCampaign
  "Create a new indoor bay sponsor campaign"
  createIndoorBaySponsorCampaign(sponsorCampaign: IndoorBaySponsorCampaignInputType!): IndoorBaySponsorCampaign
  "Create a new range sponsor campaign"
  createRangeSponsorCampaign(sponsorCampaign: SponsorCampaignInputTypeV2!): RangeSponsorCampaign
  "Mutations on a partner"
  partnerById(partnerId: ID!): PartnerMutations
  "Create a new partner"
  createPartner(name: String! key: String logoUrl: Url): Partner
  "Soft delete of the partners"
  deletePartners(ids: [ID!]): Boolean
  "Mutations available for the range configuration"
  drivingRangeConfiguration: DrivingRangeConfigurationMutations
  "Mutations for facility membership"
  membership: FacilityMembershipMutation
  "Change the url for an existing one"
  changeUrl(url: UrlInput!): Facility
  "Delete the url"
  deleteUrl(kind: LocationUrlKinds!): Facility
  "Method for updating the tags collections on the facility"
  setTags(addTags: [LocationUrlTags] removeTags: [LocationUrlTags]): Facility
  "Method for updating the key value collections on the facility"
  setKeyValues(addKeyValues: [KeyValueInput] removeKeyValues: [String!]): Facility
  "Change if the driving range app is used on this facility´s range installations"
  changeUseDrivingRangeApp(appUsed: Boolean = true): Facility
  "Mutations for user role administration"
  userAdmin: DomainUserAdminMutation
  changeBayLocation(bayIds: [ID!] locationId: ID!): Boolean
  "Mutations on a bays"
  bays(bayIds: [ID!]): BaysMutation
  "Create a new info screen"
  createInfoScreen(name: String! description: String): InfoScreen
  "Get a scorecard mutation by scorecard Id"
  scorecard(id: ID!): ScorecardMutations
  "Add Or Update application properties"
  setApplicationProperties(application: String! addProperties: [ApplicationPropertySettingInput] removeProperties: [String]): LocationInterfaceType
  developerTools: DeveloperToolsMutationType
}

"The description of the facility"
type Facility implements MediasInterface & TagsInterfaceTypeOfLocationTagsType & KeyValuesInterfaceType & Node {
  "The list of media assets"
  medias(mediaKind: MediaKind): [Media!]
  "The list of albums"
  albums: [Album!]
  "The time the resource was created"
  createdAt: DateTime!
  "The internal database id"
  dbId: String
  "The time the resource was last updated"
  lastUpdatedAt: DateTime!
  "The list of tags"
  tags: [LocationUrlTags!]
  "Has any tags"
  hasTag(tag: LocationUrlTags!): Boolean
  "The list of key values"
  keyValues: [KeyValue!]
  "The list of key values added"
  keyValue(key: String!): String
  "Has any key value been added"
  hasKeyValue(key: String!): Boolean
  "The name of the facility"
  name: NonEmptyString
  "Is this location also a facility"
  isDefaultLocation: Boolean
  description("Format to convert the markdown to" as: MkDownTypes = MKDOWN): String
  "The primary email to the facility"
  email: String
  "The time zone where the facility is located"
  timezone: String
  "The address of the facility"
  address: Address
  "The primary phone number to the facility"
  phoneNumber: String
  "The phone number of the shop on the facility"
  shopPhoneNumber: String
  "The url of the facilities logo image"
  url(kind: LocationUrlKinds!): URL
  "The facility kind"
  kind: FacilityKind
  "The GPS position of the facility"
  worldLocation: LatLon
  "Is this the default world location"
  isDefaultWorldLocation: Boolean
  "Opening hours for the facility, including maintenance hours"
  openingHours: OpeningHours
  "The distance to the facility from the search point 'near'"
  distance: Float
  "Indicate that a facility is deleted"
  isDeleted: Boolean
  id: ID!
  "The unique key of the facility"
  facilityKey: NonEmptyString
  "The membership facility"
  membership: Membership
  "Return all tournaments"
  tournaments: FacilityTournaments!
  "Return all locations"
  locations: [LocationInterfaceType!]
  "Return all bays in the facility"
  bays(types: BayTypes = ALL): [BayInterface!]
  drivingRangeConfiguration: DrivingRangeConfiguration
  permissions: [PermissionInfo!]
  "The url of the facilities logo image"
  logoUrl: URL @deprecated(reason: "Use url")
  "The integration details of the facilities"
  integrations(providerKeys: [String]): [FacilityIntegrationResponse!]
  "The url of the facilities sponsor logo image"
  sponsorLogoUrl: URL @deprecated(reason: "Use url")
  "The sponsors added for this facility"
  sponsors(skip: Int take: Int): SponsorTypeCollectionSegment
  "The sponsors campaigns added for this facility"
  sponsorCampaigns(skip: Int take: Int): SponsorCampaignTypeCollectionSegment @deprecated(reason: "Please use 'sponsorCampaignsV2' instead")
  "The sponsors campaigns added for this facility"
  sponsorCampaignsV2(skip: Int take: Int): SponsorCampaignTypeV2CollectionSegment
  "The partners added for this facility"
  partners: [Partner!]
  "The template of partner with a supported consents"
  partnerTemplate: Partner!
  "The scorecards for rounds played at this facility. Unless specified, FromDate is the last 30 days."
  scorecards(tournamentIds: [String] tournamentRoundIds: [String] courseIdentifiers: [String] playerNames: [String] playerIds: [String] fromDate: DateTime = "2024-10-27T01:13:16.069Z" toDate: DateTime skip: Int take: Int): ScorecardTypeCollectionSegment
  infoScreens(skip: Int take: Int): InfoScreenTypeCollectionSegment
  userAdmin: Domain
  "Search persons that have visited this facility"
  visitors("Search visitor by Email, Fullname, PlayerName" searchText: String "Filter on location (if none defined then filter on facility)" locationId: [ID!] "Order by Email, Fullname, PlayerName, SearchText match" orderBy: [VisitorOrderBy!] skip: Int take: Int): FacilityVisitorTypeCollectionSegment
  Facility: Facility
  "The net incidents of the facilities"
  netIncidents(ids: [String] periodFrom: DateTime periodTo: DateTime byIncident: Boolean skip: Int take: Int): NetIncidentTypeCollectionSegment
  applicationProperties(appIdentifiers: [String!] specifiedLevel: ApplicationPropertyLevelsEnumType): [ApplicationProperty]
  "Range-related entities available for this location"
  range: RangeLocationType!
  developerTools: DeveloperTools!
}

input AddressInput {
  street: NonEmptyString
  city: NonEmptyString
  zipCode: String
  countryCode: String
  stateCode: String
}

"The EmailAddress scalar type constitutes a valid email address, represented as a UTF-8 character sequence. The scalar follows the specification defined by the HTML Spec https:\/\/html.spec.whatwg.org\/multipage\/input.html#valid-e-mail-address."
scalar EmailAddress

enum LocationUrlTags {
  IS_VISIBLE_ON_LOCATOR
  HAS_VIRTUAL_GOLF
  HAS_EQUIPMENT_SALES
  IS_FITTER
  IS_GOLF_SIM
  HAS_EQUIPMENT_RENTAL
  HAS_FOOD
  HAS_COACHING_LESSONS
  HAS_DRINKS
  HAS_NINE_HOLE_COURSE
  HAS_EIGHTEEN_HOLE_COURSE
  HAS_TOURNAMENTS
  HAS_FITNESS_CENTER
  HAS_VIP_BAYS
  HAS_WARM_UP_NET
  HAS_PARKING
  HAS_SHORT_GAME_AREA
  HAS_TV_BROADCASTING
  HAS_PRIVATE_SIM_ROOMS
  IS_EQUIPMENT_MANUFACTURER
  IS_ENTERTAINMENT
}

input UrlInput {
  "The kind for the url - logo, sponsorLogo, ... "
  kind: LocationUrlKinds!
  "The uri for the resource"
  uri: Url!
}

"Mutations on a Facility Location"
type LocationMutation {
  "Change the name of the location"
  changeName(name: NonEmptyString!): LocationInterfaceType
  "Change the address of the location"
  changeAddress(address: AddressInput!): LocationInterfaceType
  "Update all properties for this location in one go"
  update(name: String description: String address: AddressInput phoneNumber: String shopPhoneNumber: String email: EmailAddress openingHours: OpeningHoursInput urls: [UrlInput] "Reset world location to default" defaultWorldLocation: Boolean "Overwrite default world location" worldLocation: LatLonInputType): LocationInterfaceType
  "Change the url for an exists one"
  changeUrl(url: UrlInput!): LocationInterfaceType
  "Delete the url"
  deleteUrl(kind: LocationUrlKinds!): LocationInterfaceType
  "Method for updating the tags collections on the location"
  setTags(addTags: [LocationUrlTags] removeTags: [LocationUrlTags]): LocationInterfaceType
  "Method for updating the key values collections on the location"
  setKeyValues(addKeyValues: [KeyValueInput] removeKeyValues: [String!]): LocationInterfaceType
  "Delete the location"
  delete: Boolean
  "Add Or Update application properties"
  setApplicationProperties(application: String! addProperties: [ApplicationPropertySettingInput] removeProperties: [String]): LocationInterfaceType
  "Range-related entities mutations available for this location"
  range: RangeLocationMutationType
}

"Mutations on a Tournament"
interface TournamentMutationInterface {
  "Delete the tournament"
  delete: Boolean
  "Change the name of the tournament"
  changeName(name: String!): Tournament
  "Change the description of the tournament"
  changeDescription(description: String): Tournament
  "Change the logo of the tournament"
  changeLogo(logoUrl: Url!): Tournament
  "Set flag indicating that this is an indoor tournament"
  setIsIndoor(isIndoor: Boolean!): Tournament
  "Set flag indicating that this is a range tournament"
  setIsRange(isRange: Boolean!): Tournament
  "Set the tournament availability"
  setAvailability(availability: TournamentAvailability! makeAvailableForAllBays: Boolean): Tournament
  "Publish the draft as published"
  publish: Tournament
  "Un-publish the published version"
  unPublish: Tournament
  "Move a tournament and all it's round to a new starting date and time"
  moveStartTime(newStartTime: DateTime!): Tournament
  "The round default mutations"
  roundDefaults: TournamentRoundDefaultsMutation
  "Invite by emails"
  invite(emails: [String!]!): Boolean
  "Join the tournament"
  join: Invitation
  "Join a player to the tournament without the player having to accept an invitation"
  joinPlayer(playerId: String email: String): Invitation
  "Accept invitation"
  acceptInvitation(invitationIds: [ID!]): Invitation
  "Decline invitation"
  declineInvitation(invitationIds: [ID!]): Invitation
  "Withdraw invitation"
  withdrawInvitation(invitationIds: [ID!]): Invitation
  "Resend invitation"
  reInvite(invitationIds: [ID!]): Invitation
  "Add a sponsor to the tournament"
  addSponsor(sponsorId: String!): Tournament
  "Remove a sponsor from the tournament"
  removeSponsor(sponsorId: String!): Tournament
  "Replace a sponsor already added to the tournament"
  replaceSponsor(oldSponsorId: String! newSponsorId: String!): Tournament
  "Add or remove tags to the tournament"
  updateTags(addTags: [String] removeTags: [String]): Tournament
  "Method for updating the key values collections on the tournament"
  setKeyValues(addKeyValues: [KeyValueInput] removeKeyValues: [String!]): Tournament
  "Add or remove geo filters to the tournament"
  updateGeoFilters(field: GeoFilterFields addIncludedValues: [String] removeIncludedValues: [String] addExcludedValues: [String] removeExcludedValues: [String]): Tournament
  "Add default requirements for participation to the tournament.Only use 'templateOwner' argument if assigning template from a specific user, otherwise leave blank to use the Trackman global template."
  addParticipantRequirementsFromDefaultTemplate(templateOwner: String): Tournament
  "Update requirements for participation to the tournament.Not passing a value for a criteria will remove it, ie. even if you do not change an existing criteriait must still be provided in order to keep it."
  updateParticipantRequirements(description: String age: ageInput gender: genderInput handicapRange: handicapRangeInput trackmanHandicap: trackmanHandicapInput category: categoryInput): Tournament
  "Remove requirements for participation from the tournament"
  removeParticipantRequirements: Tournament
  "Update group for participation in the tournament. Renaming an existing group will delete the old group and create a new one.Not passing a value for a criteria will remove it, ie. even if you do not change an existing criteriait must still be provided in order to keep it."
  updateParticipantGroup(name: String! description: String age: ageInput gender: genderInput handicapRange: handicapRangeInput trackmanHandicap: trackmanHandicapInput category: categoryInput): Tournament
  "Remove a participant group from the tournament"
  removeParticipantGroup(name: String!): Tournament
  "Remove all participant groups from the tournament"
  removeAllParticipantGroups: Tournament
  "Add or remove which locations this tournament is available."
  setLocations(addLocations: [NonEmptyString] removeLocations: [NonEmptyString] setLocations: [NonEmptyString] selectAll: Boolean): Tournament @deprecated(reason: "No longer supported.")
  "add a location to this tournament"
  addLocation(locationId: ID!): Tournament
  "remove a location from this tournament"
  removeLocation(locationId: ID!): Tournament
  "select all facility locations for this tournament"
  selectAllLocations: Tournament
  "deSelect all facility locations for this tournament"
  deSelectAllLocations: Tournament
  "filter out the locations that are not configured for payment"
  filterOutLocationsNotConfiguredForPayment: Tournament
  "Add default image to the media assets"
  addDefaultImage(mediaId: ID!): MediaAssetsInterface
  "Add media assets to the media assets"
  addMediaAssets(mediaId: ID! mediaAssetKind: [MediaAssetKind]!): MediaAssetsInterface
  "Remove media assets from the media assets"
  removeMediaAssets(mediaAssetKind: [MediaAssetKind!]!): MediaAssetsInterface
  "Remove all media assets, and fallback to default media assets"
  resetMediaAssets: MediaAssetsInterface
  "Enable payment. Payment needs to be configured for each location where the tournament is available."
  enablePayment: Tournament
  "Disable payment. Please note that the existing payment configuration will be deleted."
  disablePayment: Tournament
  "change the start time of the sign up"
  changeSignUpStartTime(signUpStartTime: DateTime): Tournament
  "change the end time of the sign up"
  changeSignUpEndTime(signUpEndTime: DateTime): Tournament
  "change the payment configuration of a location"
  changeLocationPaymentConfiguration(locationId: ID! fee: NonNegativeFloat flags: [Int]): Tournament
}

"Mutations on Me"
type MeMutation {
  "Friend mutations"
  friend(id: ID!): FriendshipMutation
  "Friends mutations"
  friends: FriendshipsMutation
  "Profile mutations"
  profile: ProfileMutation
  "Purchase mutations"
  purchases: PurchaseMutations
  "Create a planned round"
  createPlannedRound(input: PlannedRoundInput!): PlannedRoundPayload
  "Update a planned round"
  updatePlannedRound(id: ID! input: PlannedRoundInput!): PlannedRoundPayload
  "Delete a planned round"
  deletePlannedRound(id: ID!): Boolean
  "Add or update the application properties for the user"
  properties(application: String! addProperties: [ApplicationPropertySettingInput] removeProperties: [String]): [ApplicationPropertySetting] @deprecated(reason: "Try to use the `setUserProperties` mutation")
}

type DefaultError implements BaseError {
  code: String
  message: String
}

type MissingMandatoryFieldError implements BaseError {
  fieldName: String
  code: String
  message: String
}

type UserConsentItem {
  key: String!
  kind: ConsentKind!
  approvedVersion: String
  isApproved: Boolean!
  isRequired: Boolean!
}

type DuplicateRecordError implements BaseError {
  entityName: String
  code: String
  message: String
}

type ApplicationPropertySetting {
  "The key of the setting"
  key: String
  "The value of the setting"
  value: String
}

input ApplicationPropertySettingInput {
  "The key of the setting"
  key: String
  "The value of the setting"
  value: String
}

type NotificationMutations {
  "Register a device for receiving notifications"
  register(deviceId: String! tokenId: String! platform: DevicePlatformEnum! language: String! appName: String! appVersion: String!): Device
  "Un-register a device from receiving notifications"
  unRegister(deviceId: String!): Device
  "Publish a notification to a set of devices"
  sendNotification(title: String subTitle: String body: String messageKey: String data: Any): Boolean
  "Broadcast a notification to a set of devices"
  broadcastNotification(title: String body: String data: Any promotionUrl: String lang: String userIds: [String!] countryCodes: [String!] continentCodes: [String!] regionCodes: [String!]): BroadcastNotificationStatus
}

"Mutations on a Facility Location"
type SponsorCampaignMutations {
  "Change the name of the location"
  update(sponsorCampaign: SponsorCampaignInputType!): SponsorCampaign
  "Delete sponsor campaign"
  delete: Boolean
  "Update active state for this sponsor campaign"
  setActive(active: Boolean! = true): SponsorCampaign
}

interface SponsorCampaignMutationInterfaceType {
  "Delete sponsor campaign"
  delete: Boolean
  "Update active state for this sponsor campaign"
  setActive(active: Boolean! = true): SponsorCampaignV2
  "Update title for this sponsor campaign"
  setTitle(title: NonEmptyString): SponsorCampaignV2
}

"Mutations on a Sponsor"
type SponsorMutations implements MediaAssetsMutationInterface {
  "Update existing sponsor"
  update(name: String! logoUrl: Url! link: Url description: String): Sponsor
  "Delete existing sponsor"
  delete: Boolean
  "Add default image to the sponsor"
  addDefaultImage(mediaId: ID!): MediaAssetsInterface
  "Add media assets to the sponsor"
  addMediaAssets(mediaId: ID! mediaAssetKind: [MediaAssetKind]!): MediaAssetsInterface
  "Remove media assets from the sponsor"
  removeMediaAssets(mediaAssetKind: [MediaAssetKind!]!): MediaAssetsInterface
  "Remove all media assets, and fallback to default media assets"
  resetMediaAssets: MediaAssetsInterface
}

type DomainUserAdminMutation {
  modifyUserRoles(userId: ID! roleIds: [ID!]!): UserRoles
  createUserRoles(email: String! roleIds: [ID!]!): UserRoles
  domainName: String
}

"Mutations on a partner"
type PartnerMutations {
  "Delete existing partner"
  delete: Boolean
  "Add consents to the partner"
  addConsents(consents: [PartnerConsentInput]): Partner
  "Add consents to the partner"
  deleteConsents(consents: [PartnerConsentDeleteInput]): Partner
  "Add consents to the partner"
  deleteConsentLocalizations(consents: [PartnerConsentDeleteLocalizationInput]): Partner
}

type FacilityIntegrationsMutations {
  "integrate a facility to the provider"
  enable(providerKey: String! facilityId: ID!): EnableIntegrationResponse!
  "remove the integration of the facility"
  disable(providerKey: String! facilityId: ID!): Boolean!
}

"Mutations on a InfoScreen"
type InfoScreenId {
  "Method for updating the key value collections on the facility"
  setKeyValues(addKeyValues: [KeyValueInput] removeKeyValues: [String!]): InfoScreen
  delete: Boolean
  "change the name of the InfoScreen"
  changeName(newName: String!): InfoScreen
  "Add new page to the InfoScreen"
  addPage(layout: String = "FullPage" name: String index: Int displayDuration: String): InfoScreenPage
}

"Mutations on a InfoScreen type"
type InfoScreenPageId {
  "Method for updating the key value collections on the page"
  setKeyValues(addKeyValues: [KeyValueInput] removeKeyValues: [String!]): InfoScreenPage
  "change the name of the InfoScreen page"
  changeName(newName: String!): InfoScreenPage
  "change the layout of infoScreen Page"
  changeLayout(layout: String!): InfoScreenPage
  "change the display duration of infoScreen Page"
  changeDisplayDuration(displayDuration: String!): InfoScreenPage
  "Delete the page"
  deletePage: Boolean
  "Add new item to the InfoScreen page"
  addItem(kind: String = "Leaderboard" position: String index: Int): InfoScreenPageItem
}

"Mutations on a InfoScreen page"
type InfoScreenPageItemId {
  "Method for updating the key value collections on the page"
  setKeyValues(addKeyValues: [KeyValueInput] removeKeyValues: [String!]): InfoScreenPageItem
  "Change the kind of the InfoScreen page item"
  changeKind(kind: String!): InfoScreen
  "Change the position of the InfoScreen page item"
  changePosition(position: String!): InfoScreen
  "Delete InfoScreen page item"
  delete: Boolean
}

type EntityNotFoundError implements BaseError {
  id: String
  version: String
  entityName: String
  code: String
  message: String
}

type InfoScreen implements KeyValuesInterfaceType & Node {
  "The list of key values"
  keyValues: [KeyValue!]
  "The list of key values added"
  keyValue(key: String!): String
  "Has any key value been added"
  hasKeyValue(key: String!): Boolean
  "The time the resource was created"
  createdAt: DateTime!
  "The internal database id"
  dbId: String
  "The time the resource was last updated"
  lastUpdatedAt: DateTime!
  id: ID!
  name: String
  description: String
  pages: [InfoScreenPage!]
}

interface ApplicationDataMutationInterfaceType {
  createBay(name: NonEmptyString description: String = ""): BayInterface
}

type IdValue {
  "Change the persons email"
  changeEmail(email: EmailAddress!): AdminPersonInfo
  "Update all the profile properties in one go"
  update(playerName: String email: EmailAddress firstName: String lastName: String nationalityCode: String dateOfBirth: Date handicap: Float gender: Gender category: PlayerCategory dexterity: PlayerDexterity): AdminPersonInfo
  "Schedule GDPR data deletion"
  scheduleGdprDeletion: String
  "Merge another person to this person"
  merge(fromPersonId: String): Boolean
  "Schedule GDPR data extraction and receive it by email"
  scheduleGdprExtraction(receiverEmail: String): Boolean
  "Generate temporary password for this person"
  generateTempPassword: String
  schemaName: String
  typeName: String!
}

"Mutations for AdminTools"
type AdminToolMutationType {
  "Mutations on hcp records"
  hcp: HcpMutations
}

type PaymentMutationsType {
  paymentReceived(metaData: [KeyValueInput]! userId: String userEmail: String): Boolean
}

type Application {
  "Name of the client"
  name: String
  "Description of the client"
  description: String
  "ClientId of the client"
  clientId: String
  "Client Secret of the client"
  clientSecret: String
  "Time when client was created"
  createdAt: DateTime
}

input CreateOAuthClientApplicationInput {
  userId: String
  name: String
  description: String
  allowedScopes: [String]
}

type CreateUserFailedError implements BaseError {
  code: String
  message: String
}

type ServiceAccount {
  "Id of the account"
  id: String
  "Email of the account"
  email: String
}

input CreateServiceAccountInput {
  facilityId: String
  facilityKey: String
  name: String
}

type NumericValueOutOfRangeError implements BaseError {
  fieldName: String
  minValue: Float!
  maxValue: Float!
  value: Float!
  code: String
  message: String
}

type ActiveConfigurationNotFoundError implements BaseError {
  locationId: String
  code: String
  message: String
}

type NumericValueShouldBePositiveOrZeroError implements BaseError {
  fieldName: String
  value: Float!
  code: String
  message: String
}

type Net implements Node {
  "The global object identification"
  id: ID!
  dbId: String
  "The name of the net"
  name: String
  "Description of the net"
  description: String
  "Indicate whether this data is enabled or not"
  isEnabled: Boolean
  "Indicate whether this data is valid or not"
  isValid: Boolean
  "The poles of the net"
  poles: [NetPole]
  "The location the net is located in"
  location: LocationInterfaceType
  "Returns version information about the draft and published version of the net"
  versionInfo: NetVersionInfoType!
  tags: [RangeTagType]
}

input NetPoleInput {
  worldPoint: WorldCoord!
  height: Float!
}

type EntityNotModifiableError implements BaseError {
  entityId: String
  entityType: String
  code: String
  message: String
}

type ConcurrencyViolationError implements BaseError {
  entityId: String
  entityType: String
  code: String
  message: String
}

type AppMutationResult {
  isSuccess: Boolean!
}

"A target on a driving range"
type RangeTarget implements Node {
  "The global object identification"
  id: ID!
  dbId: String
  "The name of the target"
  name: String
  "Description of the target"
  description: String
  "Indicate whether the target is enabled or not"
  isEnabled: Boolean
  "World coordinates of the target"
  worldPoint: LatLonAlt
  "It indicates if the target is hidden"
  isHidden: Boolean
  "The type of the target"
  type: Type
  "The color of the target"
  color: String
  annotations: [KeyValue!]
  "The location the target is located in"
  location: LocationInterfaceType
  "Returns version information about the draft and published version of the target"
  versionInfo: TargetVersionInfoType
  tags: [RangeTagType]
}

input WorldCoord {
  "The altitude of the location"
  alt: Float
  "The latitude of the location"
  lat: Float
  "The longitude of the location"
  lon: Float
}

input KeyValueInput {
  key: String!
  value: String!
}

"It indicates the type of target"
enum Type {
  "All target"
  ALL
  "Game only target"
  GAME_ONLY
  "Directional only target"
  DIRECTIONAL_ONLY
}

"A section on a driving range"
type Section implements Node {
  "The global object identification"
  id: ID!
  dbId: String
  "The name of the section"
  name: String
  "The facility that the bay is located in"
  facility: Facility
  "The location the bay is located in"
  location: LocationInterfaceType
}

"Indicates the availability status of the bay"
enum BayAvailability {
  DEFAULT
  FREE_FOR_ALL
  MEMBERS_ONLY
  BOOKING_ONLY
  NON_PLAYABLE
}

"A Launch Area on a driving range"
type LaunchAreaType implements Node {
  "The global object identification"
  id: ID!
  dbId: String
  "The name of the launch area"
  name: String
  "Description of the launch area"
  description: String
  "Indicate whether this data is enabled or not"
  isEnabled: Boolean
  "Indicate whether this data is valid or not"
  isValid: Boolean
  "The vertices of the launch area"
  vertices: [CoordinatesType]
  "The location the launch area is located in"
  location: LocationInterfaceType
  "Returns version information about the draft and published version of the launch area"
  versionInfo: LaunchAreaVersionInfoType!
  tags: [RangeTagType]
}

input LaunchAreaCoordinatesInput {
  worldPoint: WorldCoord
}

"A radar on a driving range"
type Radar implements Node {
  "The global object identification"
  id: ID!
  dbId: String
  "The name of the Radar"
  name: String
  "Serial number of the Radar"
  serialNumber: String
  "It indicates if the Radar is hidden"
  uri: String
  "World coordinates of the Radar"
  worldPoint: LatLonAlt
  "It indicates the direction of the radar"
  bearing: Float
  "Can confirm"
  canConfirm: Boolean
  "Information about the radar camera"
  camera: RadarCamera
  "Information about the Gps Rtk"
  gpsRtk: RadarGpsRtk
  "Indicate whether the Radar is enabled or not"
  isEnabled: Boolean
  "It indicates the orientation of the radar. It returns a value only if the logical id of the entity is present in the radars available in the active configuration."
  orientation: Float
  "The location the radar is located in"
  location: LocationInterfaceType
  "Returns version information about the draft and published version of the radar"
  versionInfo: RadarVersionInfoType
  tags: [RangeTagType]
}

type NothingToPublishError implements BaseError {
  code: String
  message: String
}

type BaseRadarNotSetError implements BaseError {
  code: String
  message: String
}

type RangeConfigurationType implements Node {
  "The global object identification"
  id: ID!
  dbId: String!
  name: String
  releaseNotes: String
  publishedBy: Profile
  publishedAt: DateTime
  createdAt: DateTime!
  createdBy: Profile
  lastUpdatedAt: DateTime!
  lastUpdatedBy: Profile
  "Indicates whether this configuration is deleted or not"
  isMarkedForDelete: Boolean!
  "Indicate whether this configuration is published now or not"
  isPublished: Boolean!
  referenceWorldPoint: LatLon
  originWorldPoint: LatLonAlt
  "The location that the entity belongs to"
  location: LocationInterfaceType
  "A list of range bays in this configuration"
  bays(skip: Int take: Int order: [RangeBaySortInput!]): RangeConfigurationBaysCollectionSegment
  "A list of range launch areas"
  launchAreas(skip: Int take: Int order: [LaunchAreaSortInput!]): RangeConfigurationLaunchAreasCollectionSegment
  "A list of range safety borders"
  nets(skip: Int take: Int order: [NetSortInput!]): RangeConfigurationNetsCollectionSegment
  "A list of range targets"
  targets(skip: Int take: Int order: [TargetSortInput!]): RangeConfigurationTargetsCollectionSegment
  "A list of range radars"
  radars(skip: Int take: Int order: [RadarSortInput!]): RangeConfigurationRadarsCollectionSegment
  historyLog: RangeEntityModificationHistoryType
}

"The description of the location"
interface LocationInterfaceType {
  "The name of the location"
  name: NonEmptyString
  "The location id"
  id: ID!
  "The location kind"
  kind: FacilityKind
  "The default location"
  isDefaultLocation: Boolean
  "Is this the default world location"
  isDefaultWorldLocation: Boolean
  description("Format to convert the markdown to" as: MkDownTypes = MKDOWN): String
  "The primary email to the location"
  email: String
  "The address of the location"
  address: Address
  "The primary phone number to the location"
  phoneNumber: String
  "The phone number of the shop on the location"
  shopPhoneNumber: String
  "The url of the facilities logo image"
  url(kind: LocationUrlKinds!): URL
  "The GPS position of the location"
  worldLocation: LatLon
  "The distance to the facility from the search point 'near'"
  distance: Float
  "Indicate that a facility is deleted"
  isDeleted: Boolean
  "When have the facility last been updated"
  lastUpdatedAt: DateTime
  Facility: Facility
  "Bays available for this location"
  bays(types: BayTypes = ALL): [BayInterface!]
  "The time zone where the location is located"
  timezone: String
  "The internal database id"
  dbId: String
  "Range-related entities available for this location"
  range: RangeLocationType!
  applicationProperties(appIdentifiers: [String!] specifiedLevel: ApplicationPropertyLevelsEnumType): [ApplicationProperty]
  "The flags available for this location"
  paymentFlags: [PaidEventFlag]
  "Indicates if the location can be used for payment"
  isConfiguredForPayment: Boolean
  "The list of key values added"
  keyValues: [KeyValue!]
  "The list of key values added"
  keyValue(key: String!): String
  "Has any key value been added"
  hasKeyValue(key: String!): Boolean
  "The list of tags"
  tags: [LocationUrlTags!]
  "Has any tags"
  hasTag(tag: LocationUrlTags!): Boolean
}

interface TagsInterfaceTypeOfLocationTagsType {
  "The list of tags"
  tags: [LocationUrlTags!]
  "Has any tags"
  hasTag(tag: LocationUrlTags!): Boolean
}

interface KeyValuesInterfaceType {
  "The list of key values added"
  keyValues: [KeyValue!]
  "The list of key values added"
  keyValue(key: String!): String
  "Has any key value been added"
  hasKeyValue(key: String!): Boolean
}

type KeyValue {
  key: String!
  value: String!
}

"The NonEmptyString scalar type represents non empty textual data, represented as UTF‐8 character sequences with at least one character"
scalar NonEmptyString

enum MkDownTypes {
  MKDOWN
  HTML
  PLAIN_TEXT
}

"An address"
type Address {
  "The name of the street"
  street: String
  "The zip code of the address"
  zipCode: String
  "The city name of the address"
  city: String
  "The state code of the address (ANSI standard INCITS 38:2009)"
  stateCode: String
  "The country code of the address (ISO 3166-1 alpha-2)"
  countryCode: String
  "The name of the country."
  countryName(format: CountryNameFormat = ENGLISH_NAME): String
}

scalar URL

enum LocationUrlKinds {
  LOGO
  SPONSOR_LOGO
  FACEBOOK
  TWITTER
  INSTAGRAM
  BACKGROUND_IMAGE
  BOOKING
  WEB_SITE
  LOCK_TEMPLATE
}

"The different kinds available for a facility"
enum FacilityKind {
  NOTHING_ASSIGNED
  RANGE
  INDOOR_SIMULATOR
  INDOOR_SIMULATOR_AND_RANGE
  UNKNOWN
}

"A world location"
type LatLon {
  "The latitude of the location"
  latitude: Float!
  "The longitude of the location"
  longitude: Float!
  "The altitude of the location (if present)"
  altitude: Float
  "Universal Transverse Mercator (UTM) coordinate system. Uses the WGS 84 Datum by default."
  utm: UTM
  "Url to a google map with a in at the location"
  googleMapUrl: URL
}

"Opening hours for the facility"
type OpeningHours {
  "Information about the maintenance hours for the facility"
  maintenanceHours: MaintenanceHours
}

type PaidEventFlag {
  "The id of the flag"
  id: Int
  "Flag description"
  description: String
  "The name of the flag"
  name: String
}

"Return all tickets for an event"
type paidTickets {
  "The status of the ticket payment"
  status: String
  "Number of tickets the user have bought"
  uses: Int
  "Maximum number of tickets the user can buy"
  maxUses: Int
  "User details"
  ticketUser: paidTicketUser
}

"Properties available for all bay kinds"
interface BayInterface {
  "The bay Id"
  id: ID!
  "Database identifier of the bay"
  dbId: String
  "Indicate if the bay is an indoor simulator bay or a bay in a driving range"
  kind: BayKind
  "The name of the bay"
  name: String
  "The bay description"
  description: String
  "A numeric identifier for the bay"
  bayNumber: Int
  "Indicates the availability status of the bay"
  availability: BayAvailability!
  "Indicates whether the bay is currently offline"
  isOffline: Boolean!
  "The facility that the bay is located in"
  facility: Facility
  "The location the bay is located in"
  location: LocationInterfaceType
  "Indicates whether the bay is currently part of one of the enabled bay setups"
  isEnabled: Boolean!
  "Activity information for this bay"
  activities: BayActivitiesInterface!
  "Booking information for this bay"
  bookings: BayBookings!
  applicationProperties(appIdentifiers: [String!] specifiedLevel: ApplicationPropertyLevelsEnumType): [ApplicationProperty]
}

enum BayTypes {
  ALL
  INDOOR_SIMULATOR_BAYS
  RANGE_BAYS
}

"The settings is related to each application"
type ApplicationProperty {
  "The application Id"
  identifier: String
  "The settings of this application"
  settings: [ApplicationPropertySetting!]
}

enum ApplicationPropertyLevelsEnumType {
  GLOBAL
  FACILITY
  LOCATION
  BAY
  USER
}

"Container for range-related entities"
type RangeLocationType {
  "The safety border notifications settings"
  netNotifications: NetNotificationType
  "A list of range bays"
  bays(filter: RangeBaysFilter skip: Int take: Int order: [RangeBaySortInput!]): RangeLocationBaysCollectionSegment
  "A list of range launch areas"
  launchAreas(filter: LaunchAreaFilter skip: Int take: Int order: [LaunchAreaSortInput!]): RangeLocationLaunchAreasCollectionSegment
  "A list of range safety borders"
  nets(filter: NetFilter skip: Int take: Int order: [NetSortInput!]): RangeLocationNetsCollectionSegment
  "A list of range targets"
  targets(filter: RangeTargetFilter skip: Int take: Int order: [TargetSortInput!]): RangeLocationTargetsCollectionSegment
  "A list of range radars"
  radars(filter: RadarFilter skip: Int take: Int order: [RadarSortInput!]): RangeLocationRadarsCollectionSegment
  "Current active configuration"
  activeConfiguration: RangeConfigurationType
  "A list of range configuration"
  configurations(filter: RangeConfigurationFilterInput skip: Int take: Int order: [RangeConfigurationSortType!]): RangeLocationConfigurationsCollectionSegment
  "A list of range sections"
  sections(filter: SectionFilter skip: Int take: Int order: [SectionSortInput!]): RangeLocationSectionsCollectionSegment
}

"Indicate if the bay is an indoor simulator bay or a bay in a driving range"
enum BayKind {
  "Indoor simulator bay"
  SIMULATOR_BAY
  "Bay in a driving range"
  RANGE_BAY
}

type BayIndoorActivities implements BayActivitiesInterface {
  "The activity currently being played in an indoor bay"
  current: SimulatorBayActivity
}

type BayBookings {
  "The next booking scheduled for a bay"
  next: Booking
  "The list of bookings for a bay"
  list(todayOnly: Boolean! = true skip: Int take: Int): BookingTypeCollectionSegment
}

type BayIndoorSession implements BaySessionInterface {
  "The session duration"
  duration: TimeSpan
  "The list of players currently occupying the bay"
  players: [BayPlayer]!
}

type BayStorageInfo {
  "Name of the disk"
  name: String
  "Model of the disk"
  model: String
  "Size of the storage"
  size: Long
  "The type of file system"
  fileSystem: String
  "Free space of the storage"
  freeSpace: Long
}

type BayScreenInfo {
  "The device name"
  deviceName: String
  "Width of the screen"
  width: Int
  "Height of the screen"
  height: Int
  "Is it the primary screen or not"
  primary: Boolean
}

type BayGraphicsInfo {
  "The gpu name"
  name: String
  "Memory of the gpu"
  memory: Long
  "Date of the driver"
  driverDate: String
  "Version of the driver"
  driverVersion: String
  "Is it dedicated gpu or not"
  main: Boolean
}

type BayStrokes {
  "The last stroke for a bay"
  last: StrokeV2
}

type BayRangeActivities implements BayActivitiesInterface {
  "The activity currently being played in a range bay"
  current: RangeBayActivity
}

type BayNetIncidents {
  "The last safety border net incident for a bay"
  last: NetIncident
}

"Version information for a Driving Range bay"
type RangeBayVersionInfo implements EntityVersionInfo {
  "Indicates whether this is a published or draft version of an entity"
  state: PublishState!
  "The version of the entity"
  version: String!
  "The timestamp of this version's publication date"
  publishedAt: DateTime
  "Indicates whether a draft version has been marked for delete on the next publish"
  isMarkedForDelete: Boolean!
  "Returns the current draft version of the Bay if one exists"
  draftVersion: RangeBay
  "Returns the latest published version of the Bay if one exists"
  publishedVersion: RangeBay
  "The other versions of the bay"
  versions(filter: RangeBayVersionFilter skip: Int take: Int order: [RangeBaySortInput!]): RangeBayVersionsCollectionSegment
}

"Activity information for a Driving Range bay"
interface BayActivityInterface {
  "The ID of the player"
  id: ID!
  "The activity type"
  type: String!
  "The kind of the activity"
  kind: ActivityKind
  "The start time of the activity"
  startTime: DateTime!
  "The list of players currently occupying the bay"
  players: [BayPlayerInterface]!
}

enum ActivityKind {
  SESSION
  DYNAMIC_REPORT
  SCREENCAST
  VIDEO
  TEST
  COMBINE_TEST
  RANGE_PRACTICE
  COURSE_PLAY
  RANGE_FIND_MY_DISTANCE
  RANGE_BULLS_EYE
  RANGE_HIT_IT
  RANGE_CAPTURE_THE_FLAG
  VIRTUAL_GOLF_PLAY
  VIRTUAL_GOLF_PRACTICE
  SHOT_ANALYSIS
  VIRTUAL_RANGE
  PERFORMANCE_PUTTING
  SIMULATOR
  TRACY
  EVENT_REPORT
  PDF_REPORT
  NOTE
  PERFORMANCE_CENTER
  MAGIC_POND
  PUTT_PUTT
  SCRAP_YARD
  CREATURE_CATCH
  CLOSEST_TO_THE_PIN
  CLOSEST_TO_THE_PIN_TOURNAMENT
  MULTI_ROUND_TOURNAMENT
  ORDER_OF_MERIT_TOURNAMENT
  LONGEST_DRIVE_TOURNAMENT
  TARGET_PRACTICE
  ON_THE_EDGE
  BOWLING
  OTHER
}

"Information about a player on a bay"
type BayPlayer implements BayPlayerInterface {
  "The ID of the player"
  id: ID!
  "The player name"
  playerName: String
  "The player's full name"
  fullName: String
  "Indicates whether the player is a guest player"
  isGuestPlayer: Boolean!
  "The uri for the person profile picture"
  picture: URL
}

type StrokeList {
  "The list of all net incidents for an activity"
  list(skip: Int take: Int): StrokeV2TypeCollectionSegment
}

type BayRangeActivityNetIncidents {
  "The list of all net incidents for an activity"
  list(skip: Int take: Int): NetIncidentTypeCollectionSegment
}

interface PlayerActivity {
  "The activity id"
  id: ID!
  "The date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
}

interface SessionActivityInterface {
  strokes(clubs: [ClubEnum!]): [Stroke!]
  aggregatedMeasurement(clubs: [ClubEnum!] useNormalizedMeasurement: Boolean = false): AggregatedMeasurement
  "The activity id"
  id: ID!
  "The date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
}

type Profile implements Node {
  id: ID!
  dbId: String
  "Various info about equiptment, handicap,  tournaments, etc connected to the person"
  playerData: PlayerData
  nickName: String @deprecated(reason: "Use playerName")
  "The alias of the person"
  playerName: String
  "The full name of the person"
  fullName: String
  "The first name of the person"
  firstName: String
  "The last name of the person"
  lastName: String
  "The gender of the person"
  gender: Gender
  "The email address for the person"
  email: String
  "Email was confirmed by the user"
  emailConfirmed: Boolean
  "The nationality of the person"
  nationality: String
  "The nationality of the person in ISO 3166-1 alpha-2"
  nationalityCode: String
  "The date of birth for the person"
  dateOfBirth: String
  "The uri for this persons profile picture"
  picture: URL
  "This is NOT your TrackMan handicap but your official outdoor handicap index"
  outdoorHandicap: Float
  "Allow show and search by anyone. default true"
  searchAnyone: Boolean
  "Allow show and search by played with"
  searchPlayed: Boolean
  "Allow show and search by nobody"
  searchNobody: Boolean
  "Allow show picture. default true"
  showPicture: Boolean
  "Allow played rounds to be visible to friends. default true"
  sharePlayedRounds: Boolean
  "Allow show and search by email"
  showEmail: Boolean
  "Allow show fullname for tournaments"
  showFullNameForTournaments: Boolean
  "Allow show and search by fullname for friends"
  showFullNameForFriends: Boolean
  "The category of the person"
  category: PlayerCategory
  "The dexterity of the person"
  dexterity: PlayerDexterity
  claims: [SimpleClaim]
}

type Stroke {
  impactLocation: ImpactLocation
  measurementDetails: MeasurementDetails
  target: StrokeTargetInterface
  time: DateTime!
  club: String
  clubData: ClubData
  tags: [StrokeTag]
  ball: String
  targetDistance: Float
  measurement: Measurement
  normalizedMeasurement: Measurement
  data: [KeyValuePairOfStringAndObject!]
}

enum ClubEnum {
  IRON1
  IRON2
  IRON3
  IRON4
  IRON5
  IRON6
  IRON7
  IRON8
  IRON9
  DRIVER
  WOOD2
  WOOD3
  WOOD4
  WOOD5
  WOOD6
  WOOD7
  WOOD8
  WOOD9
  PITCHING_WEDGE
  SAND_WEDGE
  LOB_WEDGE
  WEDGE50
  WEDGE52
  WEDGE54
  WEDGE56
  WEDGE58
  WEDGE60
  HYBRID1
  HYBRID2
  HYBRID3
  HYBRID4
  HYBRID5
  HYBRID6
  HYBRID7
  HYBRID8
  HYBRID9
  UNKNOWN
}

type AggregatedMeasurement {
  averageBackswingTime: Float
  averageForwardswingTime: Float
  averageTempo: Float
  averageStrokeLength: Float
  averageDynamicLie: Float
  averageImpactOffset: Float
  averageImpactHeight: Float
  averageSkidDistance: Float
  averageRollPercentage: Float
  averageRollSpeed: Float
  averageSpeedDrop: Float
  averageRollDeceleration: Float
  averageEffectiveStimp: Float
  averageFlatStimp: Float
  averageBreak: Float
  averageBounces: Float
  averageEntrySpeedDistance: Float
  averageElevation: Float
  averageSlopePercentageSide: Float
  averageSlopePercentageRise: Float
  averageTotalBreak: Float
  averageAttackAngle: Float
  averageLaunchDirection: Float
  averageBallSpeed: Float
  averageClubPath: Float
  averageClubSpeed: Float
  averageDynamicLoft: Float
  averageFaceAngle: Float
  averageFaceToPath: Float
  averageLaunchAngle: Float
  averageSmashFactor: Float
  averageSpinAxis: Float
  averageGyroSpinAngle: Float
  averageSpinLoft: Float
  averageSpinRate: Float
  averageSwingDirection: Float
  averageSwingPlane: Float
  averageSwingRadius: Float
  averageDPlaneTilt: Float
  averageLowPointDistance: Float
  averageLowPointHeight: Float
  averageLowPointSide: Float
  averageMaxHeight: Float
  averageLandingHeight: Float
  averageCarry: Float
  averageTotal: Float
  averageCarrySide: Float
  averageTotalSide: Float
  averageSide: Float
  averageLandingAngle: Float
  averageHangTime: Float
  averageLastData: Float
  averageCurve: Float
  averageCarryActual: Float
  averageTotalActual: Float
  averageCarrySideActual: Float
  averageTotalSideActual: Float
  averageCurveActual: Float
  averageLandingAngleActual: Float
  averageSpinAxisActual: Float
  averageSkidRatio: Float
  averageRollFactor: Float
  countBackswingTime: Float
  countForwardswingTime: Float
  countTempo: Float
  countStrokeLength: Float
  countDynamicLie: Float
  countImpactOffset: Float
  countImpactHeight: Float
  countSkidDistance: Float
  countRollPercentage: Float
  countRollSpeed: Float
  countSpeedDrop: Float
  countRollDeceleration: Float
  countEffectiveStimp: Float
  countFlatStimp: Float
  countBreak: Float
  countBounces: Float
  countEntrySpeedDistance: Float
  countElevation: Float
  countSlopePercentageSide: Float
  countSlopePercentageRise: Float
  countTotalBreak: Float
  countAttackAngle: Float
  countLaunchDirection: Float
  countBallSpeed: Float
  countClubPath: Float
  countClubSpeed: Float
  countDynamicLoft: Float
  countFaceAngle: Float
  countFaceToPath: Float
  countLaunchAngle: Float
  countSmashFactor: Float
  countSpinAxis: Float
  countGyroSpinAngle: Float
  countSpinLoft: Float
  countSpinRate: Float
  countSwingDirection: Float
  countSwingPlane: Float
  countSwingRadius: Float
  countDPlaneTilt: Float
  countLowPointDistance: Float
  countLowPointHeight: Float
  countLowPointSide: Float
  countMaxHeight: Float
  countLandingHeight: Float
  countCarry: Float
  countTotal: Float
  countCarrySide: Float
  countTotalSide: Float
  countSide: Float
  countLandingAngle: Float
  countHangTime: Float
  countLastData: Float
  countCurve: Float
  countCarryActual: Float
  countTotalActual: Float
  countCarrySideActual: Float
  countTotalSideActual: Float
  countCurveActual: Float
  countLandingAngleActual: Float
  countSpinAxisActual: Float
  countSkidRatio: Float
  countRollFactor: Float
  minBackswingTime: Float
  minForwardswingTime: Float
  minTempo: Float
  minStrokeLength: Float
  minDynamicLie: Float
  minImpactOffset: Float
  minImpactHeight: Float
  minSkidDistance: Float
  minRollPercentage: Float
  minRollSpeed: Float
  minSpeedDrop: Float
  minRollDeceleration: Float
  minEffectiveStimp: Float
  minFlatStimp: Float
  minBreak: Float
  minBounces: Float
  minEntrySpeedDistance: Float
  minElevation: Float
  minSlopePercentageSide: Float
  minSlopePercentageRise: Float
  minTotalBreak: Float
  minAttackAngle: Float
  minLaunchDirection: Float
  minBallSpeed: Float
  minClubPath: Float
  minClubSpeed: Float
  minDynamicLoft: Float
  minFaceAngle: Float
  minFaceToPath: Float
  minLaunchAngle: Float
  minSmashFactor: Float
  minSpinAxis: Float
  minGyroSpinAngle: Float
  minSpinLoft: Float
  minSpinRate: Float
  minSwingDirection: Float
  minSwingPlane: Float
  minSwingRadius: Float
  minDPlaneTilt: Float
  minLowPointDistance: Float
  minLowPointHeight: Float
  minLowPointSide: Float
  minMaxHeight: Float
  minLandingHeight: Float
  minCarry: Float
  minTotal: Float
  minCarrySide: Float
  minTotalSide: Float
  minSide: Float
  minLandingAngle: Float
  minHangTime: Float
  minLastData: Float
  minCurve: Float
  minCarryActual: Float
  minTotalActual: Float
  minCarrySideActual: Float
  minTotalSideActual: Float
  minCurveActual: Float
  minLandingAngleActual: Float
  minSpinAxisActual: Float
  minSkidRatio: Float
  minRollFactor: Float
  maxBackswingTime: Float
  maxForwardswingTime: Float
  maxTempo: Float
  maxStrokeLength: Float
  maxDynamicLie: Float
  maxImpactOffset: Float
  maxImpactHeight: Float
  maxSkidDistance: Float
  maxRollPercentage: Float
  maxRollSpeed: Float
  maxSpeedDrop: Float
  maxRollDeceleration: Float
  maxEffectiveStimp: Float
  maxFlatStimp: Float
  maxBreak: Float
  maxBounces: Float
  maxEntrySpeedDistance: Float
  maxElevation: Float
  maxSlopePercentageSide: Float
  maxSlopePercentageRise: Float
  maxTotalBreak: Float
  maxAttackAngle: Float
  maxLaunchDirection: Float
  maxBallSpeed: Float
  maxClubPath: Float
  maxClubSpeed: Float
  maxDynamicLoft: Float
  maxFaceAngle: Float
  maxFaceToPath: Float
  maxLaunchAngle: Float
  maxSmashFactor: Float
  maxSpinAxis: Float
  maxGyroSpinAngle: Float
  maxSpinLoft: Float
  maxSpinRate: Float
  maxSwingDirection: Float
  maxSwingPlane: Float
  maxSwingRadius: Float
  maxDPlaneTilt: Float
  maxLowPointDistance: Float
  maxLowPointHeight: Float
  maxLowPointSide: Float
  maxMaxHeight: Float
  maxLandingHeight: Float
  maxCarry: Float
  maxTotal: Float
  maxCarrySide: Float
  maxTotalSide: Float
  maxSide: Float
  maxLandingAngle: Float
  maxHangTime: Float
  maxLastData: Float
  maxCurve: Float
  maxCarryActual: Float
  maxTotalActual: Float
  maxCarrySideActual: Float
  maxTotalSideActual: Float
  maxCurveActual: Float
  maxLandingAngleActual: Float
  maxSpinAxisActual: Float
  maxSkidRatio: Float
  maxRollFactor: Float
}

type TestResult {
  "Test definition and settings"
  definition: TestResultDefinition
  "Link to the test report"
  reportPath: String
  "Overall statistics about the test result"
  statistics: TestResultStatistics
  "Statistics about the driving results"
  drivingStatistics: TestResultDrivingStatistics
  "Targets"
  targets: [TestResultTarget!]
  "Estimated handicap"
  estimatedHcp: Decimal
  player: Player
  id: UUID!
  time: DateTime!
  updated: DateTime
  client: Client
  user: User
  groups: [Group]
  data: [KeyValuePairOfStringAndObject!]
}

interface RangeActivityInterface {
  "Strokes"
  strokes: [RangeStroke!]
  siteAssetInfo: [SiteAssetInfo!]
  siteMetadata: DrivingRangesMetadata
  activityEvents: [ActivityEvent!]
  "OldPlayerId is used when a temp player have been merged on the server but you still would like to use the old Id in the leaderboard"
  oldPlayerId: UUID
  "The activity id"
  id: ID!
  "The date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
}

type RangeStroke {
  "Time when the stroke was hit"
  time: DateTime
  "The name of the bay"
  bayName: String
  "The bay type"
  bayType: String
  "The bay position (center of bay) in Site Coordinates"
  bayPosition: [Float!]
  "The shot was from a Dynamic Bay"
  isDynamicBay: Boolean
  "Indicate that the player have deleted the stroke"
  isDeleted: Boolean!
  "The position of the target in Site Coordinates (Only if target have been selected)"
  targetPosition: [Float!]
  "The id of the target (Only if target have been selected)"
  targetId: String
  club: String
  "The Site Coordinates of where the ball was hit from"
  teePosition: [Float!]
  "Indicate that the shot was not a real shot but a simulated shot"
  isSimulated: Boolean!
  "The player"
  player: TrackerMessagePlayer
  "Database Id"
  dbId: String
  "The measurement of the stroke. Use the measurementType argument to choose the right measurement. Default measurement is SiteMeasurement"
  measurement("Default: SiteMeasurement. You can get the measurement in Site Coordinates or Bay Coordinates, as Pro-Ball converted or not" measurementType: RangeMeasurementTypes = SITE_MEASUREMENT): RangeStrokeMeasurement
}

type SiteAssetInfo {
  "The id of the site"
  siteId: String
  "The type of file"
  type: String
  "The content type of the filet"
  contentType: String
  "The name of the file"
  fileName: String
  "The uri of the file"
  uri: String
  "The MD5 hash"
  md5: String
  "The time the file was uploaded"
  uploadDateTime: DateTime
}

type DrivingRangesMetadata {
  launch(bayName: String type: String angle: String resolution: String aspect: String): [DrivingRangeMetadataBay!]
  landing(bayName: String type: String angle: String resolution: String aspect: String): [DrivingRangeMetadataBay!]
  side(bayName: String type: String angle: String resolution: String aspect: String): [DrivingRangeMetadataViewType!]
  top(type: String angle: String resolution: String aspect: String distanceString: String nearestDistance: Float): [DrivingRangeMetadataViewType!]
  splash: DrivingRangeMetadataViewType
  courseName: String
  courseId: String
  siteKey: String
  siteId: String
  coordinates: UtmModel3DCoordinate
  hitAreas: [HitArea]
  heights: [HeightPoint]
  id: String
  createdAt: DateTime!
  lastUpdatedAt: DateTime!
  createdBy: String
  lastUpdatedBy: String
}

scalar UUID

"The internal ActivityEvents for the RangeApp"
type ActivityEvent {
  "The type of the payload"
  type: String
  "The events payload. This is of type Any so it's NOT strongly typed."
  payload: AnyWithJObject @deprecated(reason: "Use eventData")
  "The events data as json."
  eventData: JSON
}

type ActivityLocation {
  name: String
}

"All scorecard data for a round of golf"
type Scorecard implements Node {
  "The time the resource was created"
  createdAt: DateTime!
  "The internal database id"
  dbId: String
  "The time the resource was last updated"
  lastUpdatedAt: DateTime!
  "The facility that owns the resource"
  facility: Facility
  id: ID!
  "The version of the scorecard data. Currently version 2 and 3 is supported"
  version: String
  bayKind: BayKind
  "The scorecard kind"
  kind: String
  "The holes on the round. You can ask for one hole, an array of specific holes or an array of hole types"
  holes(holeNumber: Int holeNumbers: [Int!] holeTypes: HolesToPlay = ALL_HOLES): [ScorecardHole]
  "The total distance for all holes"
  totalDistance(holeTypes: HolesToPlay = ALL_HOLES): Float
  "The course that the round was played on"
  course: Course
  "The game settings"
  gameSettings: GameSettings
  "The teams. Return null if single player teams"
  teams: [TeamPlayerInfo]
  "The number of holes to play"
  numberOfHolesToPlay: Int
  "Played until this hole number"
  thruHole(holeTypes: HolesToPlay = ALL_HOLES): Int
  "The par of the course"
  par: Int
  "Played until this hole number"
  numberOfHolesPlayed(holeTypes: HolesToPlay = ALL_HOLES): Int
  "The round completed"
  isCompleted(holeTypes: HolesToPlay = ALL_HOLES): Boolean
  "The gross score of the currently played holes"
  grossScore(holeTypes: HolesToPlay = ALL_HOLES): Int
  "The net score of the currently played holes"
  netScore(holeTypes: HolesToPlay = ALL_HOLES): Int
  "The stableford points of the completed round"
  stablefordPoints(holeTypes: HolesToPlay = ALL_HOLES): Int
  "The number of gross strokes up or down compared to par on currently played holes"
  toPar(holeTypes: HolesToPlay = ALL_HOLES): Int
  "The number of net strokes up or down compared to par on currently played holes"
  netToPar(holeTypes: HolesToPlay = ALL_HOLES): Int
  "The stableford up or down compared to par on currently played holes"
  stablefordToPar(holeTypes: HolesToPlay = ALL_HOLES): Int
  "Total score for hole 1 to 9"
  outScore(holeTypes: HolesToPlay = ALL_HOLES): Int
  "Total score for hole 10 to 18"
  inScore(holeTypes: HolesToPlay = ALL_HOLES): Int
  "Total number of mulligans"
  mulligans(holeTypes: HolesToPlay = ALL_HOLES): Int
  "The start time of the first played hole"
  startedAt(holeTypes: HolesToPlay = ALL_HOLES): DateTime
  "The finish time of the last played hole"
  finishedAt(holeTypes: HolesToPlay = ALL_HOLES): DateTime
  "The player information"
  player: PlayerInfo
  "The participants information"
  participants: [PlayerInfo]
  "The other players that played this round together scorecards"
  otherPlayersScorecards(includeCurrentPlayer: Boolean = false): [Scorecard]
  "Aggregated across played holes"
  stat: ScorecardStat
  "If the scorecard is a part of a tournament then return the tournament"
  tournament: Tournament
  "If the scorecard is a valid part of a tournament"
  isTournamentScore: Boolean
  "The status message of the scorecard in the tournament"
  tournamentStatusMessage: String
  "Has one or more shot videos"
  hasVideos: Boolean
  "The bay the round was played in"
  bay: BayInterface
  "Can the scorecard be edited"
  isEditable: Boolean
  "The scorecard has been edited"
  isEdited: Boolean
  "Total Hcp strokes for all selected holes"
  totalHcpStrokes(holeTypes: HolesToPlay = ALL_HOLES): Int
  "Is this a scorecard for a team"
  isTeamScorecard: Boolean
  "Players of the team"
  teamMembers: [PlayerInfo]
  teeName: String
  "The list of tees for the selected holes"
  tees: [TeeInfo]
  courseHcp: Float
  fairwayFirmness: String
  greenFirmness: String
  greenStimp: Float
  windMode: WindMode
}

"Information on the game"
type GameSettings {
  "The scoring method for the game"
  gameScore: String
  "The putting settings"
  puttingSettings: PuttingSettings
  gamePlay: String
  gameBall: String
  handicapped: Boolean!
  teamSize: Int!
  holes: Int!
  selectedHoles: [Int!]
  pins: String
  mulligans: String
  units: String
}

"Metadata for a virtual Golf Course"
type Course implements Node {
  id: ID!
  "The time the resource was created"
  createdAt: DateTime!
  "The internal database id"
  dbId: String
  "The time the resource was last updated"
  lastUpdatedAt: DateTime!
  "The name of Golf course"
  displayName: String
  "Short description of the Golf course"
  description: String
  "The version"
  version: String
  "Unique name of the course"
  courseIdentifier: String
  "Course image. The default is the Splash image, but with the argument kind you can get others"
  image(kind: ImageKinds = SPLASH): MediaResource
  "List all kinds of course images"
  images: [MediaResource]
  "Course video. The default is the Promotion video, but with the argument kind you can get others"
  video(kind: ImageKinds = PROMOTION): MediaResource
  "List all kinds of course videos"
  videos: [MediaResource]
  "The GPS position of the course"
  worldLocation: LatLon
  "The name of the course"
  courseLocation: String
  "The default tee for male and females"
  defaultTees: DefaultTees
  "The difficulty of the course from 1 to 5 where 1 is easy"
  difficulty: Int
  "The course environment"
  environment: Environment
  "The holes on the course"
  holes(holeNumbers: [Int!] holeTypes: HolesToPlay = ALL_HOLES name: String gender: Gender forEditor: Boolean = false): [CourseHole!]
  "The number of holes"
  numbersOfHoles: Int
  "The tees on the course"
  tees: [CourseTee]
  "Course tags"
  tags: [String]
  "The default tee on the course"
  tee(gender: Gender name: String): CourseTee
  "Performance properties for the course binary version, such as VRAM usage."
  performance: CoursePerformance
  resource(platform: MetadataResourcePlatform = WINDOWS): MetadataResource
  "The course available from this date"
  availableFromDate: DateTime
  "The course available until this date"
  availableUntilDate: DateTime
  "The ID of the course instance, if applicable"
  courseInstanceId: String
  "Can the course be selected in the Tournament editor"
  selectable: Boolean!
  "Get the scorecard template for current course based on either gender and handicap, or the player id"
  scorecardTemplate(tee: String! playerId: ID gender: Gender handicap: Float): ScorecardTemplate
}

enum CoursePlayStateEnum {
  UNKNOWN
  IN_PROGRESS
  COMPLETED
  DID_NOT_FINISH
  SAVED
}

interface RangeGameActivityInterface {
  "The game ended tie"
  didEndInTie: Boolean
  "You won the game"
  youWon: Boolean
  "You was placed on this position. Note that it's a string so Tie is marked as T6"
  youPlaced: String
  "Game leaderboard"
  leaderboard: [RangeLeaderboardRecord!]
  "The activity id"
  id: ID!
  "The date and time the activity was created"
  time: DateTime
  "The kind of the activity"
  kind: ActivityKind
  "The activity is marked hidden for the current user"
  isHidden: Boolean!
  "The player that created the activity"
  player: Profile
  "Strokes"
  strokes: [RangeStroke!]
  siteAssetInfo: [SiteAssetInfo!]
  siteMetadata: DrivingRangesMetadata
  activityEvents: [ActivityEvent!]
  "OldPlayerId is used when a temp player have been merged on the server but you still would like to use the old Id in the leaderboard"
  oldPlayerId: UUID
}

type RangeLeaderboardRecord {
  position: String
  sortOrder: Int
  numberOfRounds: Int
  numberOfStrokes: Int
  numberOfStrokesPerRound: Int
  player: LeaderboardPlayer
  winner: Boolean
  bayWinner: Boolean
  value1: Float
  value1PerNumberOfRounds: Float
  value1PerNumberOfStrokes: Float
  value2: Float
  value2PerNumberOfRounds: Float
  value2PerNumberOfStrokes: Float
}

type PerformanceCenterQuickPlayReport {
  "Report Id"
  id: String
  "Targets"
  targets: [QuickPlayTarget!]
  "Result summary"
  result: QuickPlayResult
  kind: String
  player: PlayerType
  client: ClientType
  user: UserType
  groups: [GroupType]
  time: DateTime!
  updated: DateTime
  createdAt: DateTime!
  lastUpdatedAt: DateTime!
  data: [KeyValuePairOfStringAndObject!]
}

"Url scalar type"
scalar Url

"Unit for the game"
enum GameUnit {
  FEET
  METERS
}

enum TournamentAvailability {
  PRIVATE
  PUBLIC
  GLOBAL
}

type TournamentRoundDefaultsMutation {
  changeDefaultRoundTime(defaultRoundTime: TimeSpan! adjustRounds: Boolean = false): DefaultRoundSettings
}

enum GeoFilterFields {
  CONTINENT
  COUNTRY
  REGION
}

"Interface to list media assets"
interface MediaAssetsInterface {
  "The list of media assets"
  mediaAssets: [MediaAsset!]
}

enum MediaAssetKind {
  "Tournament 'LauncherTall' Image for Tps"
  TOURNAMENT_TPS_LAUNCHERTALL_IMAGE
  "Tournament 'LauncherShort' Image for Tps"
  TOURNAMENT_TPS_LAUNCHERSHORT_IMAGE
  "Tournament 'SplashScreen' Image for Tps"
  TOURNAMENT_TPS_SPLASHSCREEN_IMAGE
  "Tournament 'Promotion' Video for Tps"
  TOURNAMENT_TPS_PROMOTION_VIDEO
  "Tournament 'LauncherTall' Image for Kiosk"
  TOURNAMENT_KIOSK_LAUNCHERTALL_IMAGE
  "Tournament 'LauncherShort' Image for Kiosk"
  TOURNAMENT_KIOSK_LAUNCHERSHORT_IMAGE
  "Tournament 'ScreenSaver' Image for Kiosk"
  TOURNAMENT_KIOSK_SCREENSAVER_IMAGE
  "Tournament 'ScreenSaverRange' Image for Kiosk"
  TOURNAMENT_KIOSK_SCREENSAVERRANGE_IMAGE
  "Tournament 'Overview' Image for Kiosk"
  TOURNAMENT_KIOSK_OVERVIEW_IMAGE
  "Tournament 'MyActivities' Image for GolfApp"
  TOURNAMENT_GOLFAPP_MYACTIVITIES_IMAGE
  "Tournament 'MyTournaments' Image for GolfApp"
  TOURNAMENT_GOLFAPP_MYTOURNAMENTS_IMAGE
  "Tournament 'TournamentPreview' Image for GolfApp"
  TOURNAMENT_GOLFAPP_TOURNAMENTPREVIEW_IMAGE
  "Tournament 'TournamentFeatured' Image for GolfApp"
  TOURNAMENT_GOLFAPP_TOURNAMENTFEATURED_IMAGE
  "Tournament 'RangeTournament' Image for GolfApp"
  TOURNAMENT_GOLFAPP_RANGETOURNAMENT_IMAGE
  "Tournament 'MyActivities' Image for Portal"
  TOURNAMENT_PORTAL_MYACTIVITIES_IMAGE
  "Tournament 'MyTournaments' Image for Portal"
  TOURNAMENT_PORTAL_MYTOURNAMENTS_IMAGE
  "Sponsor 'SponsorLogo' Image for Portal"
  SPONSOR_PORTAL_SPONSORLOGO_IMAGE
}

"The NonNegativeFloat scalar type represents a double‐precision fractional value greater than or equal to 0."
scalar NonNegativeFloat

enum GameTypes {
  STABLEFORD
  STROKE
  STROKE_NET
  MATCH
}

enum GameFormats {
  INDIVIDUAL
  SCRAMBLE
  BETTER
  ALTERNATE
  GREENSOMES
}

enum Mulligans {
  NO
  FIRST_TEE
  ALWAYS
}

enum HcpKind {
  TRACKMAN_INDOOR
  ASK_FOR_HCP
}

type TournamentRound implements Node {
  "The course that the round was played on"
  course: Course
  "Course Instance Id for the round"
  courseInstanceId: String
  id: ID!
  "The round number"
  roundNumber: Int
  "The start date and time"
  startDate: DateTime
  "The end date and time"
  endDate: DateTime
  "The round duration"
  roundDuration: TimeSpan
  "The duration count"
  duration: PositiveInt @deprecated(reason: "No longer used")
  "The duration kind (Day, Week, Month)."
  durationKind: DurationKind @deprecated(reason: "No longer used")
  "The round settings"
  settings: RoundSettings
  isPublished: Boolean
  "Round state"
  roundState: TournamentRoundState
  "Embedded game"
  embeddedGame: TournamentEmbeddedGame
  "Number of holes"
  numberOfHoles: PositiveInt
  "Number of holes"
  orderOfMeritScoring: OrderOfMeritScoring
  dbId: String
}

type TournamentRoundMutation {
  "Delete the round"
  delete: Boolean
  "Change the start date of the round"
  changeStartDate(date: DateTime!): TournamentRound @deprecated(reason: "Use changeRoundDates instead")
  "Change the end date of the round"
  changeEndDate(date: DateTime!): TournamentRound @deprecated(reason: "Use changeRoundDates instead")
  "Change the end time of the round"
  changeEndTime(time: LocalTime!): TournamentRound @deprecated(reason: "Use changeRoundDates instead")
  "Change the duration round"
  changeDuration(duration: PositiveInt durationType: DurationKind!): Tournament @deprecated(reason: "Use changeRoundDates instead")
  "Change the start- and\/or end date of the round. Must be in UTC time."
  changeRoundDates(startDate: DateTime! endDate: DateTime!): TournamentRound
  "Change the end course of the round"
  changeCourse(courseIdentifier: String! courseInstanceId: String): TournamentRound
  "Change the holes to play of the round"
  changeHolesToPlay(holesToPlay: HolesToPlay! specifiedHoles: [PositiveInt!]): TournamentRound
  "Change the fairway firmness of the round"
  changeFairwayFirmness(fairwayFirmness: Firmness!): TournamentRound
  "Change the green firmness of the round"
  changeGreenFirmness(greenFirmness: Firmness!): TournamentRound
  "Change the wind speed of the round"
  changeWindSpeed(wind: WindMode!): TournamentRound
  "Change the pin difficulty of the round"
  changePinDifficulty(pinDifficulty: Pin!): TournamentRound
  "Change the putting mode of the round"
  changePuttingMode(puttingMode: PuttMode!): TournamentRound
  "Change the green stimp of the round"
  changeGreenStimp(greenStimp: Stimp!): TournamentRound
  "Change the lighting of the course when played for this round"
  changeLighting(lighting: Lighting!): TournamentRound
  "Change the gimme distance of the round"
  changeGimmeDistance(GimmeDistance: NonNegativeFloat!): TournamentRound
  "Change the female tee of the round"
  changeFemaleTee(teeName: String!): TournamentRound
  "Change the male tee of the round"
  changeMaleTee(teeName: String!): TournamentRound
  "End the round"
  endRound: TournamentRound
  "Apply this round settings to all rounds"
  applyRoundSettingsToAllRounds: TournamentRound
  "Embedded games"
  embeddedGame: TournamentEmbeddedGameMutation
  "Change the way the max score is determined."
  changeMaxScoreMethod(maxScoreMethod: OrderOfMeritMaxScoreMethod! = DEFAULT percentageModifier: Int = 1 maxScore: Int): TournamentRound
  "Create a new scorecard"
  addScorecard(scorecard: [AddScorecardInput]! locationId: ID): [Scorecard]
}

enum Pin {
  EASY
  MEDIUM
  HARD
}

enum Firmness {
  NONE
  SOFT
  NORMAL
  HARD
  COUNT
}

enum Stimp {
  NONE
  LENGTH6
  LENGTH7
  LENGTH8
  LENGTH9
  LENGTH10
  LENGTH11
  LENGTH12
  COUNT
}

enum WindMode {
  NONE
  CALM
  BREEZY
  STRONG_BREEZE
  VARIABLE
  GUSTY
  WINDY
  STORMY
  COUNT
}

enum Lighting {
  AFTERNOON
  EVENING
  NONE
}

"The `TimeSpan` scalar represents an ISO-8601 compliant duration type."
scalar TimeSpan

enum longestDriveTournamentDifficulty {
  SKILLED
  EXPERT
  CUSTOM
}

enum tournamentDistanceType {
  CARRY
  TOTAL
}

interface CourseTournament {
  "The duration (time length) of the tournament"
  duration: TimeSpan
  "A tournament round"
  round(roundNumber: Int roundId: ID): TournamentRound
  "The tournament rounds"
  rounds: [TournamentRound!]
  "Number of rounds"
  numberOfRounds: PositiveInt
  "Tournament has overlapping rounds"
  hasOverlappingRounds: Boolean
  "The leaderboard for this tournament"
  leaderboard(hcpFrom: Float hcpTo: Float gender: Gender participantGroupId: String holeNumber: Int queryTime: DateTime): Leaderboard
  "The leaderboard for the round"
  roundLeaderboard(hcpFrom: Float hcpTo: Float gender: Gender participantGroupId: String holeNumber: Int queryTime: DateTime roundId: ID!): RoundLeaderboard
  "The leaderboard for the in-round game"
  embeddedGameLeaderboard(hcpFrom: Float hcpTo: Float gender: Gender participantGroupId: String holeNumber: Int! queryTime: DateTime roundId: ID!): EmbeddedGameLeaderboardUnion
  "The leaderboard for the in-round Closest To Pin game"
  closestToPinEmbeddedGameLeaderboard(hcpFrom: Float hcpTo: Float gender: Gender participantGroupId: String holeNumber: Int! queryTime: DateTime roundId: ID!): ClosestToPin
  "The leaderboard for the in-round Longest Drive game"
  longestDriveEmbeddedGameLeaderboard(hcpFrom: Float hcpTo: Float gender: Gender participantGroupId: String holeNumber: Int! queryTime: DateTime roundId: ID!): LongestDrive
  "The game summary leaderboard for birdie streak, GIR streak etc."
  gameSummaryLeaderboard(kind: GameSummaryKinds roundId: ID gender: Gender fromUtc: DateTime toUtc: DateTime skip: Int take: Int): GameSummaryLeaderboardRecordTypeCollectionSegment @deprecated(reason: "Use otherLeaderboards instead. This field will be removed in the future.")
  "Other side-bed leaderboards like birdie streak, GIR streak etc."
  otherLeaderboards(hcpFrom: Float hcpTo: Float gender: Gender participantGroupId: String holeNumber: Int queryTime: DateTime kind: OtherLeaderboardsKind! roundId: ID): OtherLeaderboards
  "The aggregated leaderboard for in-round closest to the pin games"
  aggregatedClosestToPinLeaderboard(hcpFrom: Float hcpTo: Float gender: Gender participantGroupId: String holeNumber: Int queryTime: DateTime roundId: ID!): AggregatedClosestToPinLeaderboard
  oomPointsDistributionTable: DistributionTable
  "The facility that owns the resource"
  facility: Facility
  "The tournament id"
  id: ID!
  "Database identifier"
  dbId: String
  "The name of the tournament"
  name: String
  description("Format to convert the markdown to" as: MkDownTypes = MKDOWN): String
  "The tournament type"
  type: TournamentTypes
  "Verify that the tournament is ready to get published"
  isPublishable: Boolean
  "The background image for the tournament"
  backgroundImage: URL
  "The logo for the tournament"
  logo: URL
  "The start date and time for the tournament"
  startDate: DateTime!
  "The end date and time for the tournament"
  endDate: DateTime
  "Check if there is an end date for the tournament"
  hasEndDate: Boolean!
  "Get version info abut the draft and the published version of the tournament"
  versionInfo: VersionInfo
  "The tournament settings"
  settings: TournamentSettings
  "If true the tournament can get played everywhere if the participant is invited. If false it can only get played in the facility that have created it"
  availableEverywhere: Boolean!
  "Where the tournament is available"
  availability: TournamentAvailability
  "Lists with all the teams in the tournament"
  teams: Teams
  "Lists with all the participants"
  participants: Invitations
  "My invitation for this tournament"
  invitation: Invitation
  "The locations where this tournament can be played"
  locations: TournamentLocations
  "The sponsors for this tournament"
  sponsors: [Sponsor]
  "The state of this tournament"
  tournamentState: TournamentState
  "A flag indicating that the tournament is featured in our applications"
  isFeatured: Boolean
  "A flag indicating that this is an indoor tournament"
  isIndoor: Boolean
  "A flag indicating that this is a range tournament"
  isRange: Boolean
  "A flag indicating that this is a team tournament"
  isTeam: Boolean
  "The list of products this tournament is a part of"
  products: [userHasPaid]
  "The unit system used when playing the tournament."
  unit: GameUnit
  "The participation groups for this tournament"
  participantGroups: [ParticipantGroup]
  "The participation requirements for this tournament"
  participantRequirements: ParticipantGroup
  "The settings that applies for all teams participating in this tournament"
  teamSettings: TournamentTeamSettingsType
  "Geo location filters for this tournament"
  geoFilters: TournamentGeoFilterType
  "A flag indicating whether any of the rounds in an order of merit tournament has non default max scoring."
  anyRoundHasNonDefaultMaxScoringMethod: Boolean
  "Participant progress in the tournament"
  participantProgress(particpantIds: [[ID]!]! roundIds: [ID] queryTime: DateTime): [TournamentProgressInterface]
  "Team handicap in the tournament"
  teamHandicap(team: CalculateTeamHandicapInput): Int
  "Indicates whether tournament is free or paid"
  isPaymentEnabled: Boolean
  "Sign up start time for this tournament. Can be null"
  signUpStartTime: DateTime
  "Sign up end time for this tournament. Can be null"
  signUpEndTime: DateTime
  "the payment configuration for each one of the locations available for this tournament"
  locationsConfiguration: [LocationConfiguration]
  "The list of key values added"
  keyValues: [KeyValue!]
  "The list of key values added"
  keyValue(key: String!): String
  "Has any key value been added"
  hasKeyValue(key: String!): Boolean
  "The list of media assets"
  mediaAssets: [MediaAsset!]
  "The list of tags"
  tags: [String!]
  "Has any tags"
  hasTag(tag: String!): Boolean
}

interface TagsInterfaceTypeOfStringType {
  "The list of tags"
  tags: [String!]
  "Has any tags"
  hasTag(tag: String!): Boolean
}

type MediaAsset {
  "The url for the media"
  url: URL
  "MediaAsset kind"
  kind: MediaAssetKind
  "MediaAsset is using a default asset"
  isDefault: Boolean
}

type VersionInfo {
  "The state of the tournament"
  state: VersionInfoState!
  "The version number of the tournament"
  version: String!
  "The current version number of the tournaments draft state"
  draftVersion: Tournament
  "The version number of the current published version of the tournament"
  publishedVersion: Tournament
}

enum TournamentTypes {
  COURSE_TOURNAMENT
  ORDER_OF_MERIT
  CLOSEST_TO_PIN
  LONGEST_DRIVE
  BULLS_EYE
}

type TournamentSettings {
  "The tournament handicap kind"
  hcpKind: HcpKind
  "The tournament game type"
  gameType: GameTypes
  "The format of the team tournament tournament"
  gameFormat: GameFormats
  "Allow to play rounds ahead in the tournament"
  allowPlayAhead: Boolean
  "Allow mulligans when playing"
  allowMulligans: Mulligans
  "The number of attempts pr round that counts on the leaderboard"
  attempts: PositiveInt
  "The number of bottom scoring rounds that are not counted on the leaderboard"
  ignoreBottomRounds: Int
  "The default round game settings used for adding a new round"
  defaultRoundGameSettings: DefaultRoundSettings
}

"An overview of all teams for a tournament"
type Teams {
  "All teams that have joined the tournament"
  accepted(skip: Int take: Int): TeamTypeCollectionSegment
}

"An overview of all player invitations for a tournament"
type Invitations {
  "All pending invitations"
  pending(skip: Int take: Int): InvitationTypeCollectionSegment
  "Number of pending invitations"
  pendingCount: Int!
  "All declined invitations"
  declined(skip: Int take: Int): InvitationTypeCollectionSegment
  "Number of declined invitations"
  declinedCount: Int!
  "All withdrawn invitations"
  withdrawn(skip: Int take: Int): InvitationTypeCollectionSegment
  "Number of withdrawn invitations"
  withdrawnCount: Int!
  "All accepted invitations"
  accepted(skip: Int take: Int): InvitationTypeCollectionSegment
  "Number of accepted invitations"
  acceptedCount: Int!
  "All invitations"
  allInvitations(skip: Int take: Int): InvitationTypeCollectionSegment
  "Number of all invitations"
  allInvitationsCount: Int!
  demographics: InvitationsDemographics
}

type TournamentLocations {
  "Is this tournament available in all locations connected to the facility that created the tournament"
  allLocationsIsSelected: Boolean
  "The locations where this tournament is available"
  list: [LocationInterfaceType!]
}

"The sponsor model"
type Sponsor implements MediaAssetsInterface & Node {
  "The time the resource was created"
  createdAt: DateTime!
  "The internal database id"
  dbId: String
  "The list of media assets"
  mediaAssets: [MediaAsset!]
  id: ID!
  "The name of the sponsor"
  name: String
  "The url for the sponsor logo"
  logoUri: URL
  "The url for the sponsor website"
  link: URL
  "The description of the sponsor"
  description: String
}

"State of the tournament"
enum TournamentState {
  NOT_STARTED
  IS_ACTIVE
  COMPLETED
}

type TournamentTeamSettingsType {
  "The number of players allowed on each team"
  size: Int
}

type TournamentGeoFilterType {
  "Values included in the filter"
  included: TournamentGeoFilterIncludedExcludedType
  "Values excluded from the filter"
  excluded: TournamentGeoFilterIncludedExcludedType
}

interface TournamentProgressInterface {
  kind: String
  participantGroups: [String]
  participant: PersonInfo
  isTeamProgress: Boolean
}

input CalculateTeamHandicapInput {
  players: [CalculateTeamHandicapPlayerInput]!
}

type LocationConfiguration {
  "The ids of applied flags for this location on this model"
  appliedFlags: [NonNegativeInt]
  "The fee amount for this location on this model"
  fee: NonNegativeFloat
  "The maximum number of participants allowed in this location for this model"
  maxParticipants: NonNegativeInt
  "The location connected to this configuration"
  location: LocationInterfaceType
  "The link to the payment site"
  paymentUrl: URL
  "the number of remaining spots for this location"
  remainingSpots: NonNegativeInt
  "the fee alongside the currency"
  displayFee: String
}

type Leaderboard {
  "The list of results for this leaderboard"
  records("Order by options for leaderboard" orderBy: LeaderboardOrderBy = POS "Filter players that is currently playing" playNow: Boolean "Filter players by nationality (Country code)" nationality: [String!] "Filter players by gender" gender: Gender "Search for players by name" searchText: String "Filter players by player category (Amateur, Professional)" playerCategory: PlayerCategory skip: Int take: Int): LeaderboardRecordTypeCollectionSegment
  "A list of player\/team ids that´s always displayed on the leaderboard"
  selectedPlayers(ids: [ID!]!): [LeaderboardRecord!]
  hcpFrom: Float
  hcpTo: Float
  gender: String
  holeNumber: Int
  participantGroupId: String
  queryTime: DateTime
  fromUtc: DateTime
  toUtc: DateTime
  target: CombineTestTarget
  ageFrom: Int
  ageTo: Int
  countryCode: String
  combineTestMode: CombineTestMode
  playerCategory: String
}

enum Gender {
  MALE
  FEMALE
  UNKNOWN
}

type RoundLeaderboard {
  "The embedded game"
  embeddedGameType: EmbeddedGameType
  selectedPlayers(ids: [ID!]!): [RoundLeaderboardRecord!]
  records("Order by options for leaderboard" orderBy: LeaderboardOrderBy = POS "Filter players that is currently playing" playNow: Boolean "Filter players by nationality (Country code)" nationality: [String!] "Filter players by gender" gender: Gender "Search for players by name" searchText: String "Filter players by player category (Amateur, Professional)" playerCategory: PlayerCategory "Filter players by score" hasScore: [LeaderboardHasScore] skip: Int take: Int): RoundLeaderboardRecordTypeCollectionSegment
  roundId: String
  hcpFrom: Float
  hcpTo: Float
  gender: String
  participantGroupId: String
  queryTime: DateTime
  hole: Int
}

union EmbeddedGameLeaderboardUnion = ClosestToPin | LongestDrive

type ClosestToPin {
  selectedPlayers(ids: [ID!]!): [RoundLeaderboardClosestToPinRecordType!]
  records("Order by options for leaderboard" orderBy: LeaderboardOrderBy = POS "Filter players that is currently playing" playNow: Boolean "Filter players by nationality (Country code)" nationality: [String!] "Filter players by gender" gender: Gender "Search for players by name" searchText: String "Filter players by player category (Amateur, Professional)" playerCategory: PlayerCategory skip: Int take: Int): RoundLeaderboardClosestToPinRecordTypeCollectionSegment
}

type LongestDrive {
  selectedPlayers(ids: [ID!]!): [RoundLeaderboardLongestDriveRecordType!]
  records("Order by options for leaderboard" orderBy: LeaderboardOrderBy = POS "Filter players that is currently playing" playNow: Boolean "Filter players by nationality (Country code)" nationality: [String!] "Filter players by gender" gender: Gender "Search for players by name" searchText: String "Filter players by player category (Amateur, Professional)" playerCategory: PlayerCategory skip: Int take: Int): RoundLeaderboardLongestDriveRecordTypeCollectionSegment
}

"A segment of a collection."
type GameSummaryLeaderboardRecordTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [GameSummaryLeaderboardRecord]
  totalCount: Int!
}

enum GameSummaryKinds {
  BIRDIES
  BIRDIE_STREAK
  GREENS_IN_REGULATION
}

type OtherLeaderboards {
  records("Order by options for leaderboard" orderBy: LeaderboardOrderBy = POS "Filter players that is currently playing" playNow: Boolean "Filter players by nationality (Country code)" nationality: [String!] "Filter players by gender" gender: Gender "Search for players by name" searchText: String "Filter players by player category (Amateur, Professional)" playerCategory: PlayerCategory skip: Int take: Int): OtherLeaderboardsRecordTypeCollectionSegment
  roundId: String
  summaryKind: GameSummaryKinds
  hcpFrom: Float
  hcpTo: Float
  gender: String
  holeNumber: Int
  participantGroupId: String
  queryTime: DateTime
  fromUtc: DateTime
  toUtc: DateTime
  target: CombineTestTarget
  ageFrom: Int
  ageTo: Int
  countryCode: String
  combineTestMode: CombineTestMode
  playerCategory: String
}

enum OtherLeaderboardsKind {
  BIRDIES
  BIRDIE_STREAK
  GREENS_IN_REGULATION
}

type AggregatedClosestToPinLeaderboard {
  records("Order by options for leaderboard" orderBy: LeaderboardOrderBy = POS "Filter players that is currently playing" playNow: Boolean "Filter players by nationality (Country code)" nationality: [String!] "Filter players by gender" gender: Gender "Search for players by name" searchText: String "Filter players by player category (Amateur, Professional)" playerCategory: PlayerCategory skip: Int take: Int): AggregatedClosestToPinLeaderboardRecordTypeCollectionSegment
}

type DistributionTable {
  "Order of merit point distribution pr. round"
  rounds: [PointDistribution]
}

"Method used to distribute scores"
enum ScoreOptions {
  CLOSEST
  TOTAL
}

type ClosestToPinGameSettings {
  "The fairway firmness"
  fairwayFirmness: Firmness
  "The green firmness"
  greenFirmness: Firmness
  "The pin difficulty"
  pinDifficulty: Pin
  "The wind mode"
  windSpeed: WindMode
  "The stimp for the green"
  greenStimp: Stimp
}

type ClosestToPinLeaderboard {
  "The list of results for this leaderboard"
  records("Order by options for leaderboard" orderBy: LeaderboardOrderBy = POS "Filter players that is currently playing" playNow: Boolean "Filter players by nationality (Country code)" nationality: [String!] "Filter players by gender" gender: Gender "Search for players by name" searchText: String "Filter players by player category (Amateur, Professional)" playerCategory: PlayerCategory skip: Int take: Int): ClosestToPinLeaderboardRecordTypeCollectionSegment
  "A list of player\/team ids that´s always displayed on the leaderboard"
  selectedPlayers(ids: [ID!]!): [ClosestToPinLeaderboardRecord!]
  hcpFrom: Float
  hcpTo: Float
  gender: String
  holeNumber: Int
  participantGroupId: String
  queryTime: DateTime
  fromUtc: DateTime
  toUtc: DateTime
  target: CombineTestTarget
  ageFrom: Int
  ageTo: Int
  countryCode: String
  combineTestMode: CombineTestMode
  playerCategory: String
}

type LongestDriveLeaderboard {
  "The list of results for this leaderboard"
  records("Order by options for leaderboard" orderBy: LeaderboardOrderBy = POS "Filter players that is currently playing" playNow: Boolean "Filter players by nationality (Country code)" nationality: [String!] "Filter players by gender" gender: Gender "Search for players by name" searchText: String "Filter players by player category (Amateur, Professional)" playerCategory: PlayerCategory skip: Int take: Int): LongestDriveLeaderboardRecordTypeCollectionSegment
  "A list of player\/team ids that´s always displayed on the leaderboard"
  selectedPlayers(ids: [ID!]!): [LongestDriveLeaderboardRecord!]
  hcpFrom: Float
  hcpTo: Float
  gender: String
  holeNumber: Int
  participantGroupId: String
  queryTime: DateTime
  fromUtc: DateTime
  toUtc: DateTime
  target: CombineTestTarget
  ageFrom: Int
  ageTo: Int
  countryCode: String
  combineTestMode: CombineTestMode
  playerCategory: String
}

type BullsEyeLeaderboard {
  "The list of results for this leaderboard"
  records("Order by options for leaderboard" orderBy: LeaderboardOrderBy = POS "Filter players that is currently playing" playNow: Boolean "Filter players by nationality (Country code)" nationality: [String!] "Filter players by gender" gender: Gender "Search for players by name" searchText: String "Filter players by player category (Amateur, Professional)" playerCategory: PlayerCategory skip: Int take: Int): BullsEyeLeaderboardRecordTypeCollectionSegment
  "A list of player\/team ids that´s always displayed on the leaderboard"
  selectedPlayers(ids: [ID!]!): [BullsEyeLeaderboardRecord!]
  hcpFrom: Float
  hcpTo: Float
  gender: String
  holeNumber: Int
  participantGroupId: String
  queryTime: DateTime
  fromUtc: DateTime
  toUtc: DateTime
  target: CombineTestTarget
  ageFrom: Int
  ageTo: Int
  countryCode: String
  combineTestMode: CombineTestMode
  playerCategory: String
}

interface SponsorCampaignV2 {
  "The sponsor campaign id"
  id: ID!
  "Database identifier"
  dbId: String
  "The title of the sponsor campaign"
  title: String
  "Is the campaign active"
  active: Boolean
  "The sponsor campaign type"
  type: SponsorCampaignKinds
}

enum SponsorCampaignKinds {
  INDOOR
  INDOOR_BAY
  RANGE
}

"Get sponsor information for sponsor added to this hole"
type HoleSponsorTypeV2 {
  "Hole number of the course"
  holeNumber: Int
  "Sponsor information"
  sponsor: Sponsor
}

"Get sponsor information for sponsor added to this hole"
type BaySponsorType {
  "The bay cover by this sponsor."
  bay: SimulatorBay
  "The sponsor selected for this bay."
  sponsor: Sponsor
}

input SponsorCampaignInputTypeV2 {
  "The title for the campaign"
  title: String!
  "Is the sponsor campaign active"
  active: Boolean = true
  "The course identifiers this campaign covers - if null or empty, all courses will covered"
  courses: [String]
  "The sponsors covering the holes"
  holeSponsors: [HoleSponsorInputType]!
}

input IndoorBaySponsorCampaignInputType {
  "The title for the campaign"
  title: String!
  "Is the sponsor campaign active"
  active: Boolean = true
  "The locations where this campaign applies"
  locationIds: [NonEmptyString]
  "The locations where this campaign applies"
  baySponsors: [BaySponsorInputTypeType]
}

interface StrokeTargetInterface {
  type: String
}

interface ParticipationCriteria {
  "The name of the criteria"
  name: String
  "The validation message when given value is tested against the criteria"
  validationMessage: String
}

enum CriteriaGender {
  MALE
  FEMALE
  ALL
}

enum Category {
  AMATEUR
  PROFESSIONAL
  ALL
}

type PersonInfo implements Node {
  dbId: String
  "Account Id of the person"
  accountId: String
  "Player name"
  playerName: String
  "Full name"
  fullName: String
  "First name"
  firstName: String
  "Last name"
  lastName: String
  "Email"
  email: String
  "Picture"
  picture: String
  "Nationality"
  nationality: String
  "Professional or amateur"
  category: PlayerCategory
  "DateOfBirth"
  dateOfBirth: String
  "Return all info about the players TrackMan handicap"
  hcp: Hcp
  "Gender"
  gender: Gender
  "The global object identification"
  id: ID!
  "Information about this player"
  playerData: PlayerData
  "Last known location"
  lastLocation: LatLon
}

type RoundProgress {
  autoJoin: Boolean
  verboseInfo: String
  playAsGuest: Boolean
  messageId: String
  completed: Boolean
  lastHoleFinishedAt: DateTime
  roundId: ID
  playerStatus: String
}

type ApplicationLayout {
  pages: [ApplicationLayoutPage!]
  layoutResources: [LayoutResource]
  licenseResources: [TrackManResource]
  language: String
}

type ReleasesModel {
  "All release components and there dependent sub components"
  components: [ReleaseComponent!]
  resources: [ReleaseResource]
}

type DeviceValidation {
  "Returns Valid if TPS can connect to all devices"
  State: String
  "Error code for why State is not valid"
  Reason: String
}

interface ApplicationLayoutGroupItemInterface {
  identifier: String
  type: String
  displayName: String
}

interface ConsentInterfaceType {
  "The kind of the consent"
  kind: NonEmptyString
  "The key of the partner's consent"
  key: NonEmptyString
  "The title of the consent"
  title: String
  "The description of the consent"
  description: String
  "Mark the consent as mandatory"
  isMandatory: Boolean
  "Mark the consent as persistent. This consent will show up to a user until one is accepted"
  isPersistent: Boolean
  "Default value of the consent"
  isSelectedByDefault: Boolean
  "The version of the consent"
  version: String
  "The info url of the consent"
  infoUrl: URL
  "The localization"
  localization: [PartnerConsentLocalizedIterfaceType!]
}

interface PartnerConsentLocalizedIterfaceType {
  "The country code"
  cultureCode: NonEmptyString
  "The key of the partner's consent"
  infoUrl: String
  "The title of the consent"
  title: String
  "The description of the consent"
  description: String
}

interface FacilityIntegrationResponse {
  providerKey: String
  name: String
  isEnabled: Boolean!
}

"Return all data for a ticket option"
type paidEventTicketOption {
  "Description of the ticket"
  description: String
  "The name of the ticket option"
  name: String
  "The id of the flag"
  id: Int
  "The displayed price of the ticket"
  displayPrice: String
  "The ticket category"
  category: String
  "The price of the ticket"
  price: Int
  "Minimum tickets per person"
  min: Int
  "Maximum tickets per person"
  max: Int
  "How many tickets are booked"
  usedCapacity: Int
  "Number of tickets available"
  capacity: Int
}

type AllEquipment {
  "Get all clubs"
  clubs(where: ClubFilterInput): [Club!]
  "Get all balls"
  balls(where: BallFilterInput): [Ball!]
  "Get all retired clubs"
  retiredClubs: [Club!]
  "Get all retired balls"
  retiredBalls: [Ball!]
}

"Object having the TrackMan handicap data"
type Hcp {
  "The current TrackMan handicap"
  currentHcp: Decimal
  "The current TrackMan handicap record"
  currentRecord: HcpRecord
  "The TrackMan handicap records"
  history(take: Int = 20 skip: Int = 0): [HcpRecord!] @deprecated(reason: "Use playerHistory for paging")
  "The TrackMan handicap records"
  playerHistory(skip: Int take: Int): HcpHistoryCollectionSegment
}

"A segment of a collection."
type TournamentInterfaceTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [Tournament]
  totalCount: Int!
}

"The different list kinds available"
enum TournamentListKinds {
  LIVE_AND_UPCOMING
  DRAFT
  HISTORY
  DELETED
  SCHEDULED
  LIVE
}

"A segment of a collection."
type PlannedRoundTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [PlannedRound]
  totalCount: Int!
}

"A segment of a collection."
type PlayerActivityInterfaceTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [PlayerActivity]
  totalCount: Int!
}

"A segment of a collection."
type ActivitySummaryTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [ActivitySummary]
  totalCount: Int!
}

"Students for a coach"
type Students {
  "Summary for student activities"
  activitySummary(timeFrom: DateTime timeTo: DateTime skip: Int take: Int): ActivitySummaryTypeCollectionSegment
  "Students with activities"
  list(timeFrom: DateTime timeTo: DateTime skip: Int take: Int): PlayerActivitySummaryTypeCollectionSegment
  "Search students for this coach"
  search("Search visitor by Email, Fullname, PlayerName" searchText: String "Order by Email, Fullname, PlayerName, SearchText match" orderBy: [VisitorOrderBy!] timeFrom: DateTime timeTo: DateTime skip: Int take: Int): CoachStudentTypeCollectionSegment
  "Student Activities"
  activities(includeHidden: Boolean kinds: [ActivityKind!] timeFrom: DateTime timeTo: DateTime skip: Int take: Int): PlayerActivityInterfaceTypeCollectionSegment
}

type Friendships {
  "All friend requests"
  all(personIds: [ID!]): [Friendship]
  "All accepted friend requests"
  accepted(personIds: [ID!]): [Friendship]
  "All sent friend request"
  sent(personIds: [ID!]): [Friendship]
  "All received friend request"
  received(personIds: [ID!]): [Friendship]
  "All declined by friend"
  declined(personIds: [ID!]): [Friendship]
  "All cancelled by me"
  cancelled(personIds: [ID!]): [Friendship]
  "All withdrawn by me"
  withdrawn(personIds: [ID!]): [Friendship]
  "Search persons"
  searchPerson("Search person by Email, Fullname, PlayerName" fullSearch: String! "Sort on Geo Location - If not specified uses the last geo location of the caller" near: LatLonInputType "Precision around Geo Location (meters) sorting" maxRadius: Float skip: Int take: Int): SearchPersonInfoTypeCollectionSegment
}

"Played round"
type PlayedWith {
  "When was the last round played"
  time: DateTime
  "Player who played the round"
  person: PersonInfo
  "Is this person your friend"
  friend: Friendship
  "Scorecard for last played round"
  scorecard: Scorecard
  "Course played for the last round"
  course: Course
}

type PermissionInfo {
  permission: String
  domain: String
}

type UserConsentsResponse {
  facilityConsents: [FacilityUserConsentItem!]
  trackManConsents: [UserConsentItem!]
}

type ApiResources {
  scopes: [String]
  enabled: Boolean
  name: String
  displayName: String
}

"Invitation person in an invitation"
type InvitationPerson {
  "Player name"
  playerName: String
  "Player name"
  nickName: String @deprecated(reason: "Use playerName instead")
  "Player fullname"
  fullName: String
  "Handicap"
  handicap: String
  "Email"
  email: String
  "Picture"
  picture: String
  "TrackMan Indoor Hcp"
  hcp: HcpRecord
}

"The invitation status"
enum InvitationStatus {
  "The invitation is accepted"
  accepted
  "The invitation is pending"
  pending
  "The invitation is withdrawn"
  withdrawn
  "The invitation is declined"
  declined
}

type PlayerGroups {
  "The graphql id of the player"
  playerId: String
  "The group(s) in the tournament that the player belongs to"
  groupIds: [String]
  "true = assigned when the player joined the tournamentfalse = assigned when the player played the first hole in the tournament"
  preliminary: Boolean
}

type PaymentInformation {
  "The location for the payment"
  location: Location
}

"Information about the offset pagination."
type CollectionSegmentInfo {
  "Indicates whether more items exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more items exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
}

type HoleInOneLeaderboardRecord {
  player: PersonInfo
  scorecardId: String
  courseIdentifier: String
  courseName: String
  continentCode: String
  continentName: String
  countryCode: String
  countryName: String
  regionCode: String
  regionName: String
  time: DateTime
  holeNumber: Int
  holeDistance: Float
  tags: [LeaderboardRecordTag]
  values: [KeyValuePairOfStringAndDouble!]
  value1: Float
  value1Normalized: Float
  value1Normalized2: Float
  value2: Float
  value2Normalized: Float
  value2Normalized2: Float
  averageDistanceToPin: Float
  totalDistanceAllShots: Float
  id: String
  createdAt: DateTime!
  lastUpdatedAt: DateTime!
  createdBy: String
  lastUpdatedBy: String
}

type CoursePlayLeaderboardRecord {
  player: PersonInfo
  scorecardId: String
  courseIdentifier: String
  courseName: String
  continentCode: String
  continentName: String
  countryCode: String
  countryName: String
  regionCode: String
  regionName: String
  time: DateTime
  score: Float
  tags: [LeaderboardRecordTag]
  values: [KeyValuePairOfStringAndDouble!]
  value1: Float
  value1Normalized: Float
  value1Normalized2: Float
  value2: Float
  value2Normalized: Float
  value2Normalized2: Float
  averageDistanceToPin: Float
  totalDistanceAllShots: Float
  id: String
  createdAt: DateTime!
  lastUpdatedAt: DateTime!
  createdBy: String
  lastUpdatedBy: String
}

type CombineLeaderboard {
  "The list of results for this leaderboard"
  records("Order by options for leaderboard" orderBy: LeaderboardOrderBy = POS "Filter players that is currently playing" playNow: Boolean "Filter players by nationality (Country code)" nationality: [String!] "Filter players by gender" gender: Gender "Search for players by name" searchText: String "Filter players by player category (Amateur, Professional)" playerCategory: PlayerCategory skip: Int take: Int): CombineLeaderboardRecordTypeCollectionSegment
  hcpFrom: Float
  hcpTo: Float
  gender: String
  holeNumber: Int
  participantGroupId: String
  queryTime: DateTime
  fromUtc: DateTime
  toUtc: DateTime
  target: CombineTestTarget
  ageFrom: Int
  ageTo: Int
  countryCode: String
  combineTestMode: CombineTestMode
  playerCategory: String
}

"The target for the combine test"
enum CombineTestTarget {
  TOTAL
  YARD60
  YARD70
  YARD80
  YARD90
  YARD100
  YARD120
  YARD140
  YARD160
  YARD180
  DRIVE
}

"The mode for the combine test"
enum CombineTestMode {
  ALL
  OUTDOOR
  INDOOR
}

enum PlayerCategory {
  AMATEUR
  PROFESSIONAL
  UNKNOWN
}

"A segment of a collection."
type ProfileTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [Profile]
}

input ClaimSearchCriteria {
  type: String
  values: [String]
}

"A segment of a collection."
type AdminPersonInfoTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [AdminPersonInfo]
  totalCount: Int!
}

input VisitorOrderBy {
  "The sort order"
  order: VisitorOrderByEnum
  "The sort direction"
  sortDirection: SortDirection
}

"Search fields"
enum SearchByEnum {
  "Search by player name"
  playerName
  "Search by full name"
  fullName
  "Search by email"
  email
  "Search by person id"
  id
  "Search by account id"
  accountId
}

type Domain implements Node {
  id: ID!
  domain: DomainInfo
  roleCount: Int
  roles: [Role!]
  users(email: String userId: String includeServiceAccounts: Boolean skip: Int take: Int): UserRolesTypeCollectionSegment
}

"Mutations on a media"
type MediaMutation {
  "Upload a media to the media library"
  uploadMedia(file: Upload! name: String album: ID): Media
  "Delete the media"
  delete(id: ID!): Boolean
  "Rename the media"
  rename(id: ID! name: String!): Media
  "Duplicate the media"
  duplicate(id: ID!): Media
  "Move media to album"
  moveToAlbum(id: ID! album: ID!): Media
  "Remove media from album"
  removeFromAlbum(id: ID!): Media
}

"Mutations on an album"
type AlbumMutation {
  "Create an album in the media library"
  createAlbum(name: String!): Album
  "Delete the album"
  delete(id: ID!): Boolean
  "Rename the album"
  rename(id: ID! name: String!): Album
}

input OpeningHoursInput {
  maintenanceHours: MaintenanceHoursInput
}

"A sponsor campaign created by a facility"
type SponsorCampaign implements Node {
  "The time the resource was created"
  createdAt: DateTime!
  "The internal database id"
  dbId: String
  "The time the resource was last updated"
  lastUpdatedAt: DateTime!
  "The facility that owns the resource"
  facility: Facility
  id: ID!
  "The kind of the sponsor campaign - indoor or range"
  kind: SponsorCampaignKinds
  "The title of the sponsor campaign"
  title: String
  "Is the sponsor campaign active"
  active: Boolean
  "Is all courses covered by this campaign"
  allCourses: Boolean
  "The courses covered by this campaign"
  courses: [Course]
  "The sponsor shown on the given hole"
  holeSponsors: [HoleSponsorType]
}

input SponsorCampaignInputType {
  "The kind for the campaign - indoor or range"
  kind: SponsorCampaignKinds!
  "The title for the campaign"
  title: String!
  "Is the sponsor campaign active"
  active: Boolean = true
  "The course identifiers this campaign covers - if null or empty, all courses will covered"
  courses: [String]
  "The sponsors covering the holes"
  holeSponsors: [HoleSponsorInputType]!
}

"Mutations available for a range configuration"
type DrivingRangeConfigurationMutations {
  "Add a course to the future configuration"
  addCourseToFutureConfiguration(courseIdentifier: String!): DrivingRangeConfiguration
  "Remove a course from the future configuration"
  removeCourseFromFutureConfiguration(instanceId: String!): DrivingRangeConfiguration
  "Create a new future configuration for this facilities driving ranges"
  createFutureConfiguration(courseConfiguration: CourseSettingsListInputType!): DrivingRangeConfiguration
  "Mutations available for updating a course instance"
  courseInstanceById(instanceId: String!): DrivingRangeConfigurationCourseInstanceMutations
  "Get available mutations for updating a specific future configuration"
  futureConfigurationById(futureConfigurationId: String!): DrivingRangeConfigurationFutureConfigurationMutationType
  "Add a course to the favorite courses for the facility"
  addCourseToFavorites(courseIdentifier: String!): DrivingRangeConfiguration
  "Remove a course from the favorite courses for the facility"
  removeCourseFromFavorites(courseIdentifier: String!): DrivingRangeConfiguration
}

type FacilityMembershipMutation {
  changeAccess(access: MembershipAccess): Facility
}

"Mutations on a Bays"
type BaysMutation {
  lock(unlockCode: String unlockUrl: String useFacilityLockScreen: Boolean = false): Boolean
  unlock(unlockCode: String force: Boolean): Boolean
  sendMessage(message: String! autoDismissDurationInSeconds: Int = 0): Boolean
  endSession(message: String secondsToEnd: Int doNotEndSession: Boolean scheduleTime: DateTime lockScreen: Boolean unlockCode: String unlockUrl: String): Boolean
  restartTps(refreshSettings: Boolean): Boolean
  "Add Or Update application properties"
  setApplicationProperties(application: String! addProperties: [ApplicationPropertySettingInput] removeProperties: [String]): Boolean
}

type ScorecardMutations {
  "Set the hide flag to true for all the videos for the given holes"
  hideVideos(holes: [Int]! reason: String): Boolean
  "Set the hide flag to false for all the videos for the given holes"
  unhideVideos(holes: [Int]! reason: String): Boolean
  "Remove this scorecard from a tournament"
  removeFromTournament: Boolean
  "Update all properties for this scorecard in one go"
  updateScorecard(scorecard: UpdatedScorecard!): Boolean
}

type DeveloperToolsMutationType {
  "Create a new WebHook"
  createWebHook(endpointUrl: String! description: String eventTypes: [WebHookEventName] bayIds: [ID!] locationIds: [ID!] headers: [KeyValueInput!]): WebHook
  webHook(id: ID!): WebHookMutationData
}

"Interface to list albums and medias"
interface MediasInterface {
  "The list of medias"
  medias(mediaKind: MediaKind): [Media!]
  "The list of albums"
  albums: [Album!]
}

type Media implements KeyValuesInterfaceType & TagsInterfaceTypeOfStringType & Node {
  "The list of key values"
  keyValues: [KeyValue!]
  "The list of key values added"
  keyValue(key: String!): String
  "Has any key value been added"
  hasKeyValue(key: String!): Boolean
  "The list of tags"
  tags: [String!]
  "Has any tags"
  hasTag(tag: String!): Boolean
  id: ID!
  "The url for the media"
  url: URL
  "The name of the media"
  name: String
  kind: MediaKind
}

enum MediaKind {
  IMAGE
  VIDEO
}

type Album implements KeyValuesInterfaceType & TagsInterfaceTypeOfStringType & Node {
  "The list of key values"
  keyValues: [KeyValue!]
  "The list of key values added"
  keyValue(key: String!): String
  "Has any key value been added"
  hasKeyValue(key: String!): Boolean
  "The list of tags"
  tags: [String!]
  "Has any tags"
  hasTag(tag: String!): Boolean
  id: ID!
  "The name of the album"
  name: String
  "The list of medias on this album"
  medias(mediaKind: MediaKind): [Media!]
}

type Membership {
  "Access restrictions for this facility"
  access: MembershipAccess
}

type FacilityTournaments {
  "The tournament id"
  id: ID
  "Tournaments available for this facility. Various filters available"
  list(list: TournamentListKinds tournamentKinds: [TournamentTypes!] withPendingInvitation: Boolean = false isFeatured: Boolean isIndoor: Boolean isRange: Boolean isTeamTournament: Boolean isFeaturedPaid: Boolean locationIds: [String!] skip: Int take: Int): FacilityTournamentsTypeCollectionSegment
  "VG courses to be shown in the Tournaments editor"
  availableCourses(tags: [String!] "Product can be: INDOOR or RANGE" product: TrackmanProductKinds = INDOOR "CourseContext can be: FACILITY or GLOBAL" courseContext: CourseContextKinds = FACILITY includeNonSelectableCourses: Boolean = false): [Course!]
}

type DrivingRangeConfiguration {
  "Is it possible to use the TrackMan mobile phone application"
  appUsed: Boolean!
  "Available configurations for this range"
  coursesConfigurations: CoursesConfigurations
  "All available virtual golf courses for this facility"
  courses: [Course]
  "The list of courses incl. settings currently running on the server."
  deployedCourses(locationId: String): [CourseWithSettingsDeployed]
  "The list of favorite course identifiers for this facility."
  favoriteCourses: [String]
}

"A segment of a collection."
type SponsorTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [Sponsor]
  totalCount: Int!
}

"A segment of a collection."
type SponsorCampaignTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [SponsorCampaign]
  totalCount: Int!
}

"A segment of a collection."
type SponsorCampaignTypeV2CollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [SponsorCampaignV2]
  totalCount: Int!
}

"A segment of a collection."
type ScorecardTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [Scorecard]
  totalCount: Int!
}

"A segment of a collection."
type InfoScreenTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [InfoScreen]
  totalCount: Int!
}

"A segment of a collection."
type FacilityVisitorTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [FacilityVisitor]
  totalCount: Int!
}

"A segment of a collection."
type NetIncidentTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [NetIncident]
  totalCount: Int!
}

type DeveloperTools {
  "Get all webhooks for the facility"
  webHooks(skip: Int take: Int): WebHooksCollectionSegment
  facilityModel: Facility
}

"Container for mutations of range-related entities"
type RangeLocationMutationType {
  netConfiguration: SafetyBorderConfigurationMutations
}

"Interface for mutation on media assets"
interface MediaAssetsMutationInterface {
  "Add default image to the media assets"
  addDefaultImage(mediaId: ID!): MediaAssetsInterface
  "Add media assets to the media assets"
  addMediaAssets(mediaId: ID! mediaAssetKind: [MediaAssetKind]!): MediaAssetsInterface
  "Remove media assets from the media assets"
  removeMediaAssets(mediaAssetKind: [MediaAssetKind!]!): MediaAssetsInterface
  "Remove all media assets, and fallback to default media assets"
  resetMediaAssets: MediaAssetsInterface
}

"Mutations on a Payments"
interface PaymentMutationInterface {
  "Enable payment. Payment needs to be configured for each location where the tournament is available."
  enablePayment: Tournament
  "Disable payment. Please note that the existing payment configuration will be deleted."
  disablePayment: Tournament
  "change the start time of the sign up"
  changeSignUpStartTime(signUpStartTime: DateTime): Tournament
  "change the end time of the sign up"
  changeSignUpEndTime(signUpEndTime: DateTime): Tournament
  "change the payment configuration of a location"
  changeLocationPaymentConfiguration(locationId: ID! fee: NonNegativeFloat flags: [Int]): Tournament
}

"Mutations on friendship"
type FriendshipMutation {
  "Accept friendship"
  accept: Friendship
  "Decline friendship"
  decline: Friendship
  "Withdraw friendship"
  withdraw: Friendship
  "Cancel friendship"
  cancel: Friendship
}

"Mutations on friendships"
type FriendshipsMutation {
  "Add a friend"
  addFriend(friendId: ID!): Friendship
}

"Mutations on my Profile"
type ProfileMutation {
  "Update all the profile properties in one go"
  update(playerName: String firstName: String lastName: String nationalityCode: String dateOfBirth: Date handicap: Float gender: Gender category: PlayerCategory dexterity: PlayerDexterity): Profile
  "Change my player name"
  changePlayerName(playerName: NonEmptyString!): Profile
  "Change my email"
  changeEmail(email: EmailAddress!): Profile
  "Change my password"
  changePassword(currentPassword: String! newPassword: String!): Profile
  "Send an email to confirm my email"
  sendEmailConfirmation: Profile
  "Change my first name"
  changeFirstName(firstName: NonEmptyString!): Profile
  "Change my last name"
  changeLastName(lastName: NonEmptyString!): Profile
  "Change my nationality code"
  changeNationalityCode(nationalityCode: NonEmptyString!): Profile
  "Change my date of birth"
  changeDateOfBirth(dateOfBirth: Date!): Profile
  "Change my official handicap"
  changeOutdoorHandicap(handicap: Int!): Profile
  "Change my gender"
  changeGender(gender: Gender!): Profile
  "Change my player category"
  changeCategory(category: PlayerCategory!): Profile
  "Allow my profile to be seen or searched by either anyone, the players I have played with, or no one"
  allowSearch(for: AllowProfileSearch!): Profile
  "Allow show picture. default true"
  showPicture(show: Boolean!): Profile
  "Allow friends to see played rounds. default true"
  sharePlayedRounds(share: Boolean!): Profile
  "Allow show email"
  showEmail(show: Boolean!): Profile
  "Allow show fullname for tournaments"
  showFullNameForTournaments(show: Boolean!): Profile
  "Allow show fullname for friends"
  showFullNameForFriends(show: Boolean!): Profile
  "Delete a profile and all its data. The deleted data cannot be restored."
  deleteAllProfileData(sendEmail: Boolean): Profile
}

"Mutations available for purchases"
type PurchaseMutations {
  "Save the purchase and have the backend process the purchase"
  savePurchase(Purchase: PurchaseInputType!): PurchaseResponseType
}

type PlannedRoundPayload {
  plannedRound: PlannedRound
}

input PlannedRoundInput {
  "The name of the planned round"
  name: String
  "The description of the planned round"
  description: String
  "The course identifier of the planned round"
  courseIdentifier: String
  "The default tee of the planned round"
  defaultTee: String
  "The default male tee of the planned round"
  defaultMaleTee: String
  "The default female tee of the planned round"
  defaultFemaleTee: String
  "The game type of the planned round"
  gameTypes: GameTypes
  "The holes to play of the planned round"
  holesToPlay: HolesToPlay
  "The putting mode of the planned round"
  puttingMode: PuttMode
  "The gimme distance of the planned round"
  gimmeDistance: NonNegativeFloat
  mulligans: Mulligans
  "The wind speed of the planned round"
  windSpeed: WindMode
  "The fairway firmness of the planned round"
  fairwayFirmness: Firmness
  "The green firmness of the planned round"
  greenFirmness: Firmness
  "The green speed firmness of the planned round"
  greenStimp: Stimp
  "The pin difficulty of the planned round"
  pin: Pin
}

interface BaseError {
  code: String
  message: String
}

"ConsentKind"
enum ConsentKind {
  MARKETING
  TERMS_AND_CONDITIONS
  COACH_DATA_SHARING
  PRIVACY_POLICY
  SWING_DATA_PROCESSING
  AGE
  WAIVER
}

type Device {
  platform: DevicePlatformEnum
  user: Profile
  ipAddess: IPv4
  deviceId: String
  tokenId: String
  language: String
  appName: String
  appVersion: String
  ipLocation: GeoLocation
  isRegistered: Boolean!
  id: String
  createdAt: DateTime!
  lastUpdatedAt: DateTime!
  createdBy: String
  lastUpdatedBy: String
}

enum DevicePlatformEnum {
  ANDROID
  IOS
}

scalar Any

type BroadcastNotificationStatus implements Node {
  id: ID!
  state: [BroadcastNotificationDetails!]
  successCount: Int
  isCompleted: Boolean
  jobIds: [String]
}

type UserRoles {
  "Id of the UserRoles"
  id: ID
  "Name of the UserRoles"
  name: String
  "Email of the UserRoles"
  email: String
  "Profile of the UserRoles"
  profile: Profile
  "Number of Roles"
  roleCount: Int
  "The Roles"
  roles: [Role!]
}

input PartnerConsentInput {
  "The kind of the consent"
  kind: NonEmptyString
  "The title of the consent"
  title: String
  "The description of the consent"
  description: String
  "Mark the consent as mandatory"
  isMandatory: Boolean
  "Default value of the consent"
  isSelectedByDefault: Boolean
  "Mark the consent as persistent. The consent wishes be accepted, even if it is an optional"
  isPersistent: Boolean
  "Minimum value is used for the Age consent"
  minimumValue: Float
  "The version of the consent"
  version: String
  "The info url of the consent"
  infoUrl: URL
  "The localization"
  localization: [PartnerConsentLocalizedInput!]
  key: String
}

input PartnerConsentDeleteInput {
  "The kind of the consent"
  kind: NonEmptyString
  "The version of the consent"
  version: String
}

input PartnerConsentDeleteLocalizationInput {
  "The kind of the consent"
  kind: NonEmptyString
  "The version of the consent"
  version: String
  "The country code"
  cultureCode: NonEmptyString
}

type EnableIntegrationResponse {
  created: Boolean!
}

type InfoScreenPage implements KeyValuesInterfaceType & Node {
  "The list of key values"
  keyValues: [KeyValue!]
  "The list of key values added"
  keyValue(key: String!): String
  "Has any key value been added"
  hasKeyValue(key: String!): Boolean
  id: ID!
  name: String
  layout: String
  displayDuration: String
  items: [InfoScreenPageItem!]
}

type InfoScreenPageItem implements KeyValuesInterfaceType & Node {
  "The list of key values"
  keyValues: [KeyValue!]
  "The list of key values added"
  keyValue(key: String!): String
  "Has any key value been added"
  hasKeyValue(key: String!): Boolean
  id: ID!
  kind: String
  position: String
}

"An admin person info"
type AdminPersonInfo implements Node {
  dbId: String
  "Account Id of the person"
  accountId: String
  "Player name"
  playerName: String
  "Full name"
  fullName: String
  "First name"
  firstName: String
  "Last name"
  lastName: String
  "Email"
  email: String
  "Picture"
  picture: String
  "Nationality"
  nationality: String
  "Professional or amateur"
  category: PlayerCategory
  "DateOfBirth"
  dateOfBirth: String
  "Return all info about the players TrackMan handicap"
  hcp: Hcp
  "Gender"
  gender: Gender
  "The global object identification"
  id: ID!
  "Login providers"
  loginProviders: [String]
  "Email history"
  emailHistory: [EmailHistory]
  "Get event logs"
  eventLogs(skip: Int take: Int): EventLogItemTypeCollectionSegment
  "The scorecards for this person"
  scorecards(fromDate: DateTime toDate: DateTime skip: Int take: Int): ScorecardTypeCollectionSegment
  "Activities of the person"
  activities(includeHidden: Boolean kinds: [ActivityKind!] timeFrom: DateTime timeTo: DateTime skip: Int take: Int): PlayerActivityInterfaceTypeCollectionSegment
}

"The `Date` scalar represents an ISO-8601 compliant date type."
scalar Date

enum PlayerDexterity {
  RIGHT_HANDED
  LEFT_HANDED
  UNKNOWN
}

type HcpMutations {
  "Updates the hcp for the given players"
  updatePlayersHcp(playerDbIds: [String]! excludeScorecardIds: [String] dryRun: Boolean = true sendNotification: Boolean = false): UpdatePlayerHcpCommandResult
}

type NetPole {
  "X,Y,Z position based on the site coordinate system"
  sitePoint: [Point3D]
  "Indicate whether this data is valid or not"
  isValid: Boolean
  "The location based on the world latitude and longitude"
  worldPoint: LatLonAlt
  "The height of the net pole"
  height: Float
}

"Version information for a Driving Range net"
type NetVersionInfoType implements EntityVersionInfo {
  "Indicates whether this is a published or draft version of an entity"
  state: PublishState!
  "The version of the entity"
  version: String!
  "The timestamp of this version's publication date"
  publishedAt: DateTime
  "Indicates whether a draft version has been marked for delete on the next publish"
  isMarkedForDelete: Boolean!
  "Returns the current draft version of the Net if one exists"
  draftVersion: Net
  "Returns the latest published version of the Net if one exists"
  publishedVersion: Net
  "The other versions of the net"
  versions(filter: NetVersionFilter skip: Int take: Int order: [NetSortInput!]): NetTypeCollectionSegment
}

type RangeTagType {
  id: String
  name: String
  color: String
}

type LatLonAlt {
  "The altitude of the location"
  alt: Float
  "The latitude of the location"
  lat: Float
  "The longitude of the location"
  lon: Float
  distanceTo(point: LatLonInputType radius: Float! = 6367444.7): Float!
  bearingTo(point: LatLonInputType): Float!
  finalBearingTo(point: LatLonInputType): Float!
  midpointTo(point: LatLonInputType): LatLon
  destinationPoint(distance: Float! bearing: Float! radius: Float! = 6367444.7): LatLon
  intersection(p1: LatLonInputType brng1: Float! p2: LatLonInputType brng2: Float!): LatLon
  crossTrackDistanceTo(pathStart: LatLonInputType pathEnd: LatLonInputType radius: Float! = 6367444.7): Float!
  maxLatitude(bearing: Float!): Float!
  crossingParallels(point1: LatLonInputType point2: LatLonInputType latitude: Float!): TupleOfDoubleAndDouble
}

"Version information for a Driving Range target"
type TargetVersionInfoType implements EntityVersionInfo {
  "Indicates whether this is a published or draft version of an entity"
  state: PublishState!
  "The version of the entity"
  version: String!
  "The timestamp of this version's publication date"
  publishedAt: DateTime
  "Indicates whether a draft version has been marked for delete on the next publish"
  isMarkedForDelete: Boolean!
  "Returns the current draft version of the target if one exists"
  draftVersion: RangeTarget
  "Returns the latest published version of the Target if one exists"
  publishedVersion: RangeTarget
  "The other versions of the target"
  versions(filter: TargetVersionFilter skip: Int take: Int order: [TargetSortInput!]): TargetVersionsCollectionSegment
}

type CoordinatesType {
  "The location based on the world latitude and longitude"
  worldPoint: LatLonAlt
  "X,Y,Z position based on the site coordinate system"
  sitePoint: Point3D
}

"Version information for a Driving Range launch area"
type LaunchAreaVersionInfoType implements EntityVersionInfo {
  "Indicates whether this is a published or draft version of an entity"
  state: PublishState!
  "The version of the entity"
  version: String!
  "The timestamp of this version's publication date"
  publishedAt: DateTime
  "Indicates whether a draft version has been marked for delete on the next publish"
  isMarkedForDelete: Boolean!
  "Returns the current draft version of the Launch Area if one exists"
  draftVersion: LaunchAreaType
  "Returns the latest published version of the Launch Area if one exists"
  publishedVersion: LaunchAreaType
  "The other versions of the launch area"
  versions(filter: LaunchAreaVersionFilter skip: Int take: Int order: [LaunchAreaSortInput!]): LaunchAreaVersionsCollectionSegment
}

type RadarCamera {
  "It indicates if the camera is enabled"
  isEnabled: Boolean
}

type RadarGpsRtk {
  "It indicates if the GpsRtk is enabled"
  isEnabled: Boolean
}

"Version information for a Driving Range radar"
type RadarVersionInfoType implements EntityVersionInfo {
  "Indicates whether this is a published or draft version of an entity"
  state: PublishState!
  "The version of the entity"
  version: String!
  "The timestamp of this version's publication date"
  publishedAt: DateTime
  "Indicates whether a draft version has been marked for delete on the next publish"
  isMarkedForDelete: Boolean!
  "Returns the current draft version of the Radar if one exists"
  draftVersion: Radar
  "Returns the latest published version of the Radar if one exists"
  publishedVersion: Radar
  "The other versions of the Radar"
  versions(filter: RadarVersionFilter skip: Int take: Int order: [RadarSortInput!]): RadarVersionsCollectionSegment
}

"Sort options for searching range bays"
input RangeBaySortInput {
  name: SortEnumType
  bayNumber: SortEnumType
}

"Sort options for searching range launch area"
input LaunchAreaSortInput {
  name: SortEnumType
  version: SortEnumType
}

"Sort options for searching range nets"
input NetSortInput {
  name: SortEnumType
  version: SortEnumType
}

"Sort options for searching targets"
input TargetSortInput {
  name: SortEnumType
  version: SortEnumType
}

"Sort options for searching radars"
input RadarSortInput {
  name: SortEnumType
  version: SortEnumType
}

"A segment of a collection."
type RangeConfigurationBaysCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [RangeBay]
  totalCount: Int!
}

"A segment of a collection."
type RangeConfigurationLaunchAreasCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [LaunchAreaType]
  totalCount: Int!
}

"A segment of a collection."
type RangeConfigurationNetsCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [Net]
  totalCount: Int!
}

"A segment of a collection."
type RangeConfigurationTargetsCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [RangeTarget]
  totalCount: Int!
}

"A segment of a collection."
type RangeConfigurationRadarsCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [Radar]
  totalCount: Int!
}

type RangeEntityModificationHistoryType {
  "The list of areas that has changed in this configuration"
  modifiedEntities: [RangeEntityTypesEnumType]
  bays(statuses: [EntityModificationStatusType]): [RangeConfigurationBay]
  launchAreas(statuses: [EntityModificationStatusType]): [RangeConfigurationLaunchArea]
  nets(statuses: [EntityModificationStatusType]): [RangeConfigurationNet]
  targets(statuses: [EntityModificationStatusType]): [RangeConfigurationTarget]
  radars(statuses: [EntityModificationStatusType]): [RangeConfigurationRadar]
}

enum CountryNameFormat {
  ENGLISH_NAME
  NATIVE_NAME
}

"Universal Transverse Mercator (UTM) coordinate system. Uses the WGS 84 Datum by default."
type UTM {
  asString: String
  "UTM Easting"
  easting: Float
  "UTM Northing"
  northing: Float
  "UTM Longitude Band Grid Zone Designation"
  longZone: Int
  "UTM Latitude Band Grid Zone Designation"
  latZone: String
}

"Maintenance hours for the facility"
type MaintenanceHours {
  "Start time for the Maintenance hours - ISO 8601 duration format"
  startTime: TimeSpan
  "End time for the Maintenance hours - ISO 8601 duration format"
  endTime: TimeSpan
}

"Return all tickets for an event"
type paidTicketUser {
  "The id of the user"
  id: String
  "The YGB-username of the user"
  username: String
}

"Activity information on the bay"
interface BayActivitiesInterface {
  "The activity currently being played in a bay"
  current: BayActivityInterface
}

"Sort options for searching configurations"
input RangeConfigurationSortType {
  publishedAt: SortEnumType
}

"Sort options for searching sections"
input SectionSortInput {
  name: SortEnumType
}

type NetNotificationType {
  configurations: NetNotificationConfiguration
  defaultMessages: [NetNotificationDefaultMessages]
  pinCode: String
}

"A segment of a collection."
type RangeLocationBaysCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [RangeBay]
  totalCount: Int!
}

input RangeBaysFilter {
  "Filter by one or more Ids"
  ids: [ID]
  "Filter by the draft or published state of the bay. If unspecified, only published bays will be returned by default."
  publishState: PublishStateFilterType
  "Specify whether to returned enabled, disabled or all bays regardless of status"
  isEnabled: Boolean
  "Filter by one or more bay availability statuses"
  availabilities: [BayAvailability!]
}

"A segment of a collection."
type RangeLocationLaunchAreasCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [LaunchAreaType]
  totalCount: Int!
}

input LaunchAreaFilter {
  "Filter by one or more Ids"
  ids: [ID]
  "Filter by one or more Tags"
  tags: [String]
  "Specify whether to returned enabled, disabled or all launch areas regardless of status"
  isEnabled: Boolean
  "Filter by the draft or published state of the launch area. If unspecified, only published launch areas will be returned by default."
  publishState: PublishStateFilterType = PUBLISHED
}

"A segment of a collection."
type RangeLocationNetsCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [Net]
  totalCount: Int!
}

input NetFilter {
  "Filter by one or more Ids"
  ids: [ID]
  "Filter by one or more Tags"
  tags: [String]
  "Specify whether to returned enabled, disabled or all launch areas regardless of status"
  isEnabled: Boolean
  "Filter by the draft or published state of the launch area. If unspecified, only published launch areas will be returned by default."
  publishState: PublishStateFilterType = PUBLISHED
}

"A segment of a collection."
type RangeLocationTargetsCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [RangeTarget]
  totalCount: Int!
}

input RangeTargetFilter {
  "Filter by one or more Ids"
  ids: [ID]
  "Filter by one or more Tags"
  tags: [String]
  "Specify whether to returned enabled, disabled or all targets regardless of status"
  isEnabled: Boolean
  "Filter by the draft or published state of the target. If unspecified, only published targets will be returned by default."
  publishState: PublishStateFilterType = PUBLISHED
}

"A segment of a collection."
type RangeLocationRadarsCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [Radar]
  totalCount: Int!
}

input RadarFilter {
  "Filter by one or more Ids"
  ids: [VersionIdInput]
  "Filter by one or more Tags"
  tags: [String]
  "Specify whether to returned enabled, disabled or all radars regardless of status"
  isEnabled: Boolean
  "Filter by the draft or published state of the radar. If unspecified, only published radars will be returned by default."
  publishState: PublishStateFilterType = PUBLISHED
}

"A segment of a collection."
type RangeLocationConfigurationsCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [RangeConfigurationType]
  totalCount: Int!
}

input RangeConfigurationFilterInput {
  "Filter by one or more Ids"
  ids: [String]
  "Specify whether to returned activated, deactivated or all configuration regardless of status"
  activeOnly: Boolean
}

"A segment of a collection."
type RangeLocationSectionsCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [Section]
  totalCount: Int!
}

input SectionFilter {
  "Filter by one or more Ids"
  ids: [ID]
}

"The activity played in a range bay"
type SimulatorBayActivity implements BayActivityInterface & Node {
  id: ID!
  "The activity type"
  type: String!
  "The activity kind"
  kind: ActivityKind
  "The start time of the activity"
  startTime: DateTime!
  "The list of players currently occupying the bay"
  players: [BayPlayer]!
  "The list of strokes currently in the ongoing activity"
  strokes: StrokeList!
}

"A segment of a collection."
type BookingTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [Booking]
  totalCount: Int!
}

"Session information for a Simulator bay"
interface BaySessionInterface {
  "The session duration"
  duration: TimeSpan
  "The list of players currently occupying the bay"
  players: [BayPlayerInterface]!
}

"The `Long` scalar type represents non-fractional signed whole 64-bit numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

type StrokeV2 implements StrokeV2Interface {
  time: DateTime
}

"Represents a safety border net incident"
type NetIncident implements Node {
  id: ID!
  "Database identifier of the net incident"
  dbId: String
  "Time the net incident"
  time: DateTime
  "Number of related net incidents"
  numberOfIncidents: Int
  "Activity Id of the net incident"
  activityId: String
  "The bay information of the net incident"
  bay: NetIncidentBay
  "The duration from the ball was struck till it crossed the border"
  crossingTime: Float
  "The X point that the ball cross the border"
  crossingX: Float
  "The Z point that the ball cross the border"
  crossingZ: Float
  "The height of the ball at the crossing point"
  netHeightAtCrossing: Float
  "Id of the session in which the net incident took place"
  sessionId: String
  "The height of the stroke at the crossing point"
  strokeHeightAtCrossing: Float
  "Id of the stroke in which the net incident took place"
  strokeId: String
  "The id of the related net incidents"
  otherNetIncidentIds: [String]
  "The related net incidents"
  otherNetIncidents: [NetIncident]
  "The player who shoots the ball out of the border"
  player: TrackerMessagePlayer
  "The location of the tee"
  teeLocation: SiteLocationModel
  "The location where the ball landed"
  landingLocation: SiteLocationModel
  "One of the poles where the ball crossed the safety border"
  pole1: NetPole
  "One of the poles where the ball crossed the safety border"
  pole2: NetPole
  "Details of the border"
  net: Net
}

interface EntityVersionInfo {
  "Indicates whether this is a published or draft version of an entity"
  state: PublishState!
  "The version of the entity"
  version: String!
  "Indicates whether a draft version has been marked for delete on the next publish"
  isMarkedForDelete: Boolean!
}

enum PublishState {
  PUBLISHED
  DRAFT
}

"A segment of a collection."
type RangeBayVersionsCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [RangeBay]
  totalCount: Int!
}

input RangeBayVersionFilter {
  "Filter by one or more Tags"
  tags: [String]
  "Specify whether to return enabled, disabled or all bays regardless of status"
  isEnabled: Boolean
  "Filter by the draft or published state of the bay. If unspecified, only published bays will be returned by default."
  publishState: PublishStateFilterType = PUBLISHED
}

"Information about a player on a bay"
interface BayPlayerInterface {
  "The ID of the player"
  id: ID!
  "The player name"
  playerName: String
  "The player's full name"
  fullName: String
  "Indicates whether the player is a guest player"
  isGuestPlayer: Boolean!
  "The uri for the person profile picture"
  picture: URL
}

"A segment of a collection."
type StrokeV2TypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [StrokeV2]
  totalCount: Int!
}

"Return all personal data on a profile"
type PlayerData {
  "Information about equipment connected to a person"
  equipment: AllEquipment
  "Return all info abut the players TrackMan handicap"
  hcp: Hcp
  "Paged result for tournaments"
  tournaments(list: TournamentListKinds tournamentKinds: [TournamentTypes!] withPendingInvitation: Boolean = false isFeatured: Boolean isIndoor: Boolean isRange: Boolean isTeamTournament: Boolean isFeaturedPaid: Boolean locationIds: [String!] skip: Int take: Int): TournamentInterfaceTypeCollectionSegment
  "Paged result for planned rounds"
  plannedRounds(skip: Int take: Int): PlannedRoundTypeCollectionSegment
  "Tournaments that´s available for this player. Paged result of tournaments"
  availableTournaments(list: TournamentListKinds tournamentKinds: [TournamentTypes!] tags: [String!] skip: Int take: Int): TournamentInterfaceTypeCollectionSegment
  "List all your scorecards. You can filter and sort the list"
  scorecards(take: Int skip: Int completed: Boolean numberOfHolesToPlay: Int): [Scorecard]
  "Activities connected to a person"
  activities(includeHidden: Boolean kinds: [ActivityKind!] timeFrom: DateTime timeTo: DateTime skip: Int take: Int): PlayerActivityInterfaceTypeCollectionSegment
  "Summary for activities"
  activitySummary(timeFrom: DateTime timeTo: DateTime skip: Int take: Int): ActivitySummaryTypeCollectionSegment
  "Information about students for a coach"
  students: Students
  "My friendships"
  friends: Friendships
  "List the rounds you've played with someone."
  playedWith(take: Int skip: Int): [PlayedWith]
  "Return all permissions that is not bound to a facility or location. You have to combine this list with your facility permissions."
  permissions(domains: [String] permissionPattern: String "If you don't need domains your list wont have duplicates if you set noDomains to true" noDomains: Boolean): [PermissionInfo!]
}

type ImpactLocation {
  impactOffset: Float!
  impactHeight: Float!
  dynamicLie: Float!
  data: [KeyValuePairOfStringAndObject!]
}

type MeasurementDetails {
  impactLocation: MeasurementDetailImpactLocation
  expiredLicense: ExpiredLicense
  outsideTeeAreaForClubData: OutsideTeeArea
  outsideTeeAreaForPutting: OutsideTeeArea
  videoIssues: VideoIssuesPayload
  trackerNoise: TrackerNoiseNotification
  data: [KeyValuePairOfStringAndObject!]
}

type TestResultDefinition {
  "Test definition name"
  name: String
  "Test definition string"
  testDefinition: String
  "Indication if this test was performed indoor"
  indoorTest: Boolean
  "Indication if this test was performed in yards"
  inYards: Boolean
  isNormalized: Boolean!
  "Location where the test was performed"
  location: String
  "Temperature in celcius when the test was performed"
  temperature: Float
  "Wind conditions when the test was performed"
  wind: String
  "Notes about the test"
  notes: String
  data: [KeyValuePairOfStringAndObject!]
}

type TestResultStatistics {
  "Average score"
  avgScore: Float
  "Number of strokes deleted while performing the test"
  numberOfDeletedStrokes: Int
  data: [KeyValuePairOfStringAndObject!]
}

type TestResultDrivingStatistics {
  "Average ball speed"
  avgBallSpeed: Float
  "Maximum ball speed"
  maxBallSpeed: Float
  "Average club speed"
  avgClubSpeed: Float
  "Maximum club speed"
  maxClubSpeed: Float
  "Average launch angle"
  avgLaunchAngle: Float
  "Average spin rate"
  avgSpinRate: Float
  avgAttackAngle: Float
  data: [KeyValuePairOfStringAndObject!]
}

type TestResultTarget {
  "Target definition"
  definition: String
  "Target type"
  type: String
  "Target distance"
  distance: Decimal
  "Target distance 2"
  distance2: Decimal
  "Score"
  score: Decimal
  "Consistency (standard deviation)"
  consistency: Decimal
  "Distance units"
  unit: String
  "Statistics about this target"
  statistics: TargetStatistics
  "Strokes for this target"
  strokes: [TargetStroke]
  data: [KeyValuePairOfStringAndObject!]
}

"The built-in `Decimal` scalar type."
scalar Decimal

type RangeStrokeMeasurement {
  "The total length of the shot including bounce and role. It was if the shot was hit on a flat environment and landed on fairway"
  total: Float
  "The length of the shot until the ball hit the ground first time. It was if the shot was hit on a flat environment"
  carry: Float
  "The length of the shot until the ball hit the ground first time. It estimated to where it would land in the real environment"
  carryActual: Float
  "The side distance where the ball hit the ground compared with a selected target line.  It was if the shot was hit on a flat environment. Note: This value do not give any sense in SideMeasurement and if a target is not selected"
  carrySide: Float
  "The side distance where the ball hit the ground compared with a selected target line. It estimated to where it would land in the real environment. Note: This value do not give any sense in SideMeasurement and if a target is not selected"
  carrySideActual: Float
  clone: RangeStrokeMeasurement
  isValidMeasurement: Boolean!
  messageId: String
  ballSpeed: Float
  maxHeight: Float
  totalActual: Float
  ballSpin: Float
  ballSpinEffective: Float
  spinAxis: Float
  launchAngle: Float
  lastData: Float
  launchDirection: Float
  landingAngle: Float
  totalSide: Float
  totalSideActual: Float
  reducedAccuracy: [String]
  ballTrajectory: [StrokeTrajectory]
  ballVelocity: [Float!]
  time: DateTime
  kind: String
  targetDistance: Float
  distanceFromPin: Float
  distanceFromPinActual: Float
  distanceFromPinTotal: Float
  distanceFromPinTotalActual: Float
  curve: Float
  curveActual: Float
  curveTotal: Float
  curveTotalActual: Float
  landingPossitionCarry: [Float!]
  landingPossitionCarryActual: [Float!]
  landingPossitionTotal: [Float!]
  windVelocity: [Float!]
}

enum RangeMeasurementTypes {
  MEASUREMENT
  SITE_MEASUREMENT
  PRO_BALL_MEASUREMENT
  PRO_BALL_SITE_MEASUREMENT
}

type DrivingRangeMetadataBay {
  image: DrivingRangeMetadataImage
  bayName: String
  bayId: String
  distanceString: String
  type: String
  resolution: String
  aspect: String
  hitAreaId: String
  hitAreaName: String
  angle: String
  siteLocation: [Float!]
  name: String
  tags: [KeyValue!]
  camera: Camera
}

type DrivingRangeMetadataViewType {
  image: DrivingRangeMetadataImage
  bayName: String
  bayId: String
  distanceString: String
  type: String
  resolution: String
  aspect: String
  hitAreaId: String
  hitAreaName: String
  angle: String
  name: String
  tags: [KeyValue!]
  camera: Camera
}

scalar AnyWithJObject

scalar JSON

type ScorecardHole implements Node {
  id: ID!
  "The hole number"
  holeNumber: Int!
  player: PlayerInfo
  "Indicate if the hole is played"
  isPlayed: Boolean!
  "The length of the hole from the played tee on the scorecard"
  distance: Float
  "The par of the hole from the played tee on the scorecard"
  par: Int
  "The stroke index of the hole from the played tee on the scorecard"
  strokeIndex: Int
  "The time the hole was finished"
  finishedAt: DateTime
  "The tee that the hole was played from"
  teeName: String
  "Gross score"
  grossScore: Int
  "Net score"
  netScore: Int
  "Skins score"
  skinsScore: Int
  "Match score"
  matchScore: Int
  "Stableford point"
  stablefordPoint: Int
  "Hcp strokes"
  hcpStrokes: Int
  "Putts"
  putts: Int
  "Green in Regulation: A green is considered hit in regulation if any part of the ball is touching the putting surface while the number of strokes taken is at least two fewer than par"
  greenInRegulation: Boolean
  "Net Green in Regulation"
  netGreenInRegulation: Int
  "Got a Gimme"
  gimmeWasGiven: Boolean
  "Number of Mulligans that was taking"
  mulligans: Int
  "All the shots"
  shots(shotNumbers: [Int!]): [ScorecardShot]
  "Has one or more shot video"
  hasVideos: Boolean
  "Has the shot videos been hidden by an admin due to inappropriate content"
  isShotVideosHidden: Boolean
  pinPosition: Position
  "Hole image. The default is the TopView image, but with the argument kind you can get others"
  image(kind: String = "TopView"): MediaResource
  "List all kinds of hole images"
  images: [MediaResource]
  "List all kinds of hole videos"
  videos: [MediaResource]
  "Indicate if one or more parts of the data on the ball position is invalid"
  ballPositionValidationData: [BallPositionValidation]
  "The hole has been edited"
  isEdited: Boolean
}

"Holes selector type"
enum HolesToPlay {
  "All holes"
  ALL_HOLES
  "The first 9 holes"
  FRONT_NINE
  "The last 9 holes"
  BACK_NINE
  "All par 3 holes"
  PAR3_HOLES
  "All par 4 holes"
  PAR4_HOLES
  "All par 5 holes"
  PAR5_HOLES
  "The specified holes"
  SPECIFIC
}

"Information about the player"
type PlayerInfo {
  "The id of the player"
  id: ID
  "Database identifier of the player"
  dbId: String
  "The gender of the player"
  gender: String
  "The display name for the player"
  name: String
  "Did the player sign in"
  isGuest: Boolean
  "Was the player add to this round as a ghost player"
  isGhost: Boolean
  "The player hcp index used"
  hcp: Float
  "The player course hcp obtained from the course slope and rating"
  courseHcp: Float
  "The tee played from"
  tee: String
  "The url for the players profile image"
  picture: URL
  "Is this a team"
  isTeam: Boolean
}

"Aggregated across played holes"
type ScorecardStat {
  "The sum of all drives"
  driveTotal(holeTypes: HolesToPlay = ALL_HOLES): Float
  "The total number of drives"
  driveCount(holeTypes: HolesToPlay = ALL_HOLES): Int
  "The longest drive"
  driveMax(holeTypes: HolesToPlay = ALL_HOLES): Float
  "The average of all drives"
  driveAverage(holeTypes: HolesToPlay = ALL_HOLES): Float
  "The highest ball speed"
  highestBallSpeed(holeTypes: HolesToPlay = ALL_HOLES): Float
  "The number of drives that hit fairway"
  fairwayHitFairway(holeTypes: HolesToPlay = ALL_HOLES): Int
  "The number of drives that hit left of the fairway"
  fairwayHitLeft(holeTypes: HolesToPlay = ALL_HOLES): Int
  "The number of drives that hit right of the fairway"
  fairwayHitRight(holeTypes: HolesToPlay = ALL_HOLES): Int
  "The number of times the player hit green in regulation"
  greenInRegulation(holeTypes: HolesToPlay = ALL_HOLES): Int
  "The number of triple bogeys or worse"
  tripleBogeysOrWorse: Int
  "The number of scrambles. A scramble is when a player misses the green in regulation but still makes par or better"
  scrambles: Int
  "The number of double bogeys"
  doubleBogeys: Int
  "The number of bogeys"
  bogeys: Int
  "The number of pars"
  pars: Int
  "The number of birdies"
  birdies: Int
  "The number of eagles"
  eagles: Int
  "The number of albatrosses"
  albatrosses: Int
  "The number of eagles or better"
  eaglesOrBetter: Int
  "The number of eagles or better"
  numberOfPutts: Int
  "The number of eagles or better"
  averagePuttsPerHole: Int
}

type TeeInfo {
  "The name of the tee"
  name: String
  "The total length of the tee"
  distance: Float
  "The par of the tee"
  par: Int
  "The slope of the tee"
  slope: Float
  "The rating of the tee"
  rating: Float
  "The gender of the tee"
  gender: String
  "The holes on the round"
  holes: [HoleInfo]
}

"Putting for the game"
type PuttingSettings {
  "The putting options"
  puttingMode: PuttingOptions
  autoGimmie: Boolean!
  gimmieDistance: Float!
  isAuto: Boolean!
  isAutoHandicap: Boolean!
  isAimed: Boolean!
  fixedPutt: Boolean!
  twoPutt: Boolean!
  isManualInput: Boolean!
  isManual: Boolean!
}

type MediaResource {
  "The url for the image"
  url: URL
  kind: ImageKinds
  "The url for the metadata"
  metaDataUrl: URL
  "Get the pixel position based on real life coordinates"
  getPixelPosition(latLonCoordinate: LatLonInputType utmCoordinate: SimpleUtmInput unityCoordinate: UnityPositionInput): UnityTransformationMetadataPixelPosition
  width: Int!
  height: Int!
  size: Float!
  sha256: String
}

enum ImageKinds {
  FLAG
  SPLASH
  THUMBNAIL
  TOP_VIEW
  SPLASH_EVENING
  SPLASH_EVENING_WEBP
  SPLASH_WEBP
  THUMBNAIL_EVENING
  THUMBNAIL_EVENING_PORTRAIT
  THUMBNAIL_WITH_TEXT
  THUMBNAIL_PORTRAIT
  THUMBNAIL_SMALL_CARD
  THUMBNAIL_LARGE_CARD
  PROMOTION
}

"The course environment"
type Environment {
  "The wind options"
  wind: Compass
  lighting: Lighting!
}

type CourseHole {
  "The default tee on the course"
  tee(gender: Gender name: String): HoleTee
  "The number of the hole"
  holeNumber: Int!
  "The name of the hole"
  name: String
  "The description of the hole"
  description: String
  "The default tee on the course"
  tees: [HoleTee!]
  "A pin"
  pin(pinDifficulty: HolePinDifficulty = EASY): HolePin
  "All pin positions"
  pins(pinDifficulty: [HolePinDifficulty]): [HolePin!]
  "All aim point positions"
  aimPoints: [TaggedPosition!]
  "All camera positions"
  cameras: [TaggedPosition!]
  "Course image. The default is the Splash image, but with the argument kind you can get others"
  image(kind: ImageKinds = TOP_VIEW): MediaResource
  "List all kinds of hole images"
  images: [MediaResource!]
  "Hole video. The default is the Promotion video, but with the argument kind you can get others"
  video(kind: ImageKinds = PROMOTION): MediaResource
  "List all kinds of hole videos"
  videos: [MediaResource!]
}

type CourseTee {
  "The name of the tee"
  name: String
  "The course par when playing from this tee"
  par: Int!
  "The length of the course when playing from this tee"
  courseDistance: Float!
  "The gender this tee is intended for."
  gender: Gender
  "An indication of the relative difficulty of a golf course for players who are not scratch players compared to players who are scratch players. The lowest Slope Rating is 55 and the highest is 155"
  slope: Int!
  "Course Rating is an evaluation of the difficulty of a golf course for scratch golfers."
  courseRating: Float!
  groupId: String
  kind: String
}

type CoursePerformance {
  "The course identifier"
  identifier: String
  "The version of the course"
  modelVersion: String
  "The platform the course is running on"
  platform: String
  "The amount of VRAM required by this course version"
  vRamUsage: Int
}

type MetadataResource {
  name: String
  platform: MetadataResourcePlatform
  identifier: String
  version: String
  url: String
  cdnUrl: String
  size: Int
  sha256: String
  type: String
}

enum MetadataResourcePlatform {
  WINDOWS
  LINUX
}

type ScorecardTemplate {
  holes: [HoleTemplate]
  courseHcp: Int
  par: Int
  totalDistance: Float
  teeName: String
  totalHcpStrokes: Int
}

type QuickPlayTarget {
  "Target definition"
  definition: QuickPlayTargetDefinition
  "Strokes"
  strokes: [QuickPlayStroke!]
}

type QuickPlayResult {
  "Total number of strokes"
  strokeCount: Int
  "Average strokes gained"
  averageStrokesGained: Float
}

type DefaultRoundSettings {
  "The fairway firmness"
  fairwayFirmness: Firmness
  "The green firmness"
  greenFirmness: Firmness
  "The pin difficulty"
  pinDifficulty: Pin
  "The wind mode"
  windSpeed: WindMode
  "Mulligans"
  mulligans: Mulligans
  "The putting mode"
  puttingMode: PuttMode
  "The gimme distance"
  gimmeDistance: NonNegativeFloat
  "The attempts per round"
  attemptsPerRound: Int
  "The attempt that is shown on the leaderboard"
  attemptsOnLeaderboard: Int
  "The green stimp for the round"
  greenStimp: Stimp
  "The lighting on the course when the round is played"
  lighting: Lighting
  defaultRoundTime: TimeSpan
}

enum DurationKind {
  Unknown
  Day
  Week
  Month
}

"Tournament round settings"
type RoundSettings {
  "Default male Tee"
  maleTee: TournamentTee
  "Default female Tee"
  femaleTee: TournamentTee
  "Default Tee"
  defaultTee: TournamentTee
  "Default Tee"
  gameSettings: RoundGameSettings
  "Holes to play"
  holesToPlay: HolesToPlay
}

enum TournamentRoundState {
  UNKNOWN
  NOT_STARTED
  STARTED
  COMPLETED
}

type TournamentEmbeddedGame {
  closestToPin: TournamentClosestToPinEmbeddedGame
  longestDrive: TournamentLongestDriveEmbeddedGame
  courseIdentifier: String
  courseVersion: String
  holes: HolesToPlay!
  maleTee: TeeSettings
  femaleTee: TeeSettings
}

type OrderOfMeritScoring {
  "Method used to distribute points. The default methods is based on the number of players entering the tournament"
  ScoreMethod: OrderOfMeritMaxScoreMethod
  "The max. number of points a player can get in this round. The number will be calculated after the first round ends."
  maxScore: Int
  "A value of 10 will increase the max points a player can get by 10% compared to the default max score."
  percentageModifier: Int
}

enum PuttMode {
  AUTO
  AUTO_TWO
  AUTO_HANDICAP
  AUTO_FIXED
  AIMED
  MANUAL
  MANUAL_INPUT
}

"Mutations on a Tournament's Embedded games"
type TournamentEmbeddedGameMutation {
  "Get Closest To Pin Game"
  closestToPin: TournamentClosestToPinEmbeddedGameMutation
  "Get Longest Drive Game"
  longestDrive: TournamentLongestDriveEmbeddedGameMutation
  courseIdentifier: String
  courseVersion: String
  holes: HolesToPlay!
  maleTee: TeeSettings
  femaleTee: TeeSettings
}

input AddScorecardInput {
  scores: [ScorecardScoreItemInput]!
  players: [ScorecardPlayerItemInput]!
}

enum VersionInfoState {
  DRAFT
  PUBLISHED
}

"A segment of a collection."
type TeamTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [Team]
  totalCount: Int!
}

"A segment of a collection."
type InvitationTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [Invitation]
  totalCount: Int!
}

type InvitationsDemographics {
  "Return which nationalities (country code) that are represented in the accepted invitations. Only includes players with a nationality"
  nationalities: [String!]
  "Return which player categories are represented in the accepted invitations. Only includes players with a player category"
  playerCategories: [PlayerCategory!]
  "Return which genders are represented in the accepted invitations. Only includes players with a gender"
  genders: [Gender!]
  "Return the player with the lowest, average and highest handicap. Only includes players with a handicap."
  handicaps: [Float]
  "Return the player with the lowest, average and highest age. Only includes players with an age."
  ages: [Float]
  invitations: [Invitation]
}

type TournamentGeoFilterIncludedExcludedType {
  "Continent codes included or excluded in the geo filter"
  continents: [String]
  "Country codes included or excluded in the geo filter"
  countries: [String]
  "Region codes included or excluded in the geo filter"
  regions: [String]
}

input CalculateTeamHandicapPlayerInput {
  playerId: ID!
  hcp: Float
}

"A segment of a collection."
type LeaderboardRecordTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [LeaderboardRecord]
  totalCount: Int!
}

"Order by options for leaderboard"
enum LeaderboardOrderBy {
  "Order by position"
  POS
  "Order by time"
  TIME
  "Order by player name"
  PLAYER_NAME
}

type LeaderboardRecord {
  playerDbId: String
  "The id for the player\/team"
  playerId: ID
  "Professional or amateur"
  category: PlayerCategory
  "The total score for this record"
  total: LeaderboardTotalScore
  "Latest round played"
  latestRound: LeaderboardRoundScoreType
  "The list of scores for the rounds for this player"
  rounds: [LeaderboardRoundScoreType!]
  scores: [KeyValuePairOfStringAndLeaderboardRoundScore!]
  isLive: Boolean!
  age: Int
  time: String
  hasScore: [LeaderboardHasScore!]
  id: String
  playername: String
  nickname: String @deprecated(reason: "Use Playername instead")
  email: String
  hcp: Float
  gender: String
  nationality: String
  picture: String
  status: InvitationStatus!
}

"The embedded game"
enum EmbeddedGameType {
  NONE
  CLOSEST_TO_PIN
  LONGEST_DRIVE
}

type RoundLeaderboardRecord {
  playerDbId: String
  playerId: ID
  score: LeaderboardRoundScoreType
  previousOrderOfMeritLeaderboardScore: OrderOfMeritLeaderboardScore
  newOrderOfMeritLeaderboardScore: OrderOfMeritLeaderboardScore
  isLive: Boolean!
  time: String
  hasScore: [LeaderboardHasScore!]
  id: String
  playername: String
  nickname: String @deprecated(reason: "Use Playername instead")
  email: String
  hcp: Float
  gender: String
  nationality: String
  picture: String
  category: String
  status: InvitationStatus!
}

"A segment of a collection."
type RoundLeaderboardRecordTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [RoundLeaderboardRecord]
  totalCount: Int!
}

"Filter players by score"
enum LeaderboardHasScore {
  "Filter players by Albatross"
  ALBATROSS
  "Filter players by Eagle"
  EAGLE
  "Filter players by Birdie"
  BIRDIE
  "Filter players by Par"
  PAR
}

type RoundLeaderboardClosestToPinRecordType {
  score: LeaderboardRoundClosestToPinScoreType
  previousOrderOfMeritLeaderboardScore: OrderOfMeritLeaderboardScore
  newOrderOfMeritLeaderboardScore: OrderOfMeritLeaderboardScore
  isLive: Boolean!
  time: String
  hasScore: [LeaderboardHasScore!]
  id: String
  playername: String
  nickname: String @deprecated(reason: "Use Playername instead")
  email: String
  hcp: Float
  gender: String
  nationality: String
  picture: String
  category: String
  status: InvitationStatus!
}

"A segment of a collection."
type RoundLeaderboardClosestToPinRecordTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [RoundLeaderboardClosestToPinRecordType]
  totalCount: Int!
}

type RoundLeaderboardLongestDriveRecordType {
  score: LeaderboardRoundLongestDriveScoreType
  previousOrderOfMeritLeaderboardScore: OrderOfMeritLeaderboardScore
  newOrderOfMeritLeaderboardScore: OrderOfMeritLeaderboardScore
  isLive: Boolean!
  time: String
  hasScore: [LeaderboardHasScore!]
  id: String
  playername: String
  nickname: String @deprecated(reason: "Use Playername instead")
  email: String
  hcp: Float
  gender: String
  nationality: String
  picture: String
  category: String
  status: InvitationStatus!
}

"A segment of a collection."
type RoundLeaderboardLongestDriveRecordTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [RoundLeaderboardLongestDriveRecordType]
  totalCount: Int!
}

type GameSummaryLeaderboardRecord {
  player: PersonInfo
  scorecardId: String
  courseIdentifier: String
  courseName: String
  continentCode: String
  continentName: String
  countryCode: String
  countryName: String
  regionCode: String
  regionName: String
  time: DateTime
  "Position on the leaderboard"
  pos: Int
  "Position label"
  posLabel: Int
  "The score for the leaderboard"
  score: Int
  "The number of pars made in this round"
  pars: Int
  "The number of birdies made in this round"
  birdies: Int
  "The number of eagles made in this round"
  eagles: Int
  "The number of albatrosses made in this round"
  albatrosses: Int
  "The number of green in regulation made in this round"
  greenInRegulations: Int
  "The number of birdies or better in a row"
  birdieStreak: Int
  "The number of eagles or better in a row"
  eagleStreak: Int
  "The number of greens in regulation in a row"
  greenInRegulationStreak: Int
}

"A segment of a collection."
type OtherLeaderboardsRecordTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [OtherLeaderboardsRecord]
  totalCount: Int!
}

"A segment of a collection."
type AggregatedClosestToPinLeaderboardRecordTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [AggregatedClosestToPinLeaderboardRecord]
  totalCount: Int!
}

type PointDistribution {
  "RoundId"
  roundId: ID
  "Round name"
  name: String
  "A list of position and projected points for that position"
  points: [PointInfo]
}

"A segment of a collection."
type ClosestToPinLeaderboardRecordTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [ClosestToPinLeaderboardRecord]
  totalCount: Int!
}

type ClosestToPinLeaderboardRecord {
  playerDbId: String
  "The id of the player"
  playerId: ID
  "The total score"
  total: ClosestToPinLeaderboardTotalScore
  "The average score"
  average: ClosestToPinLeaderboardTotalScore
  score: ClosestToPinLeaderboardRoundScoreType
  "The holes played in the tournament"
  holes: [ClosestToPinLeaderboardRoundScoreType!]
  scores: [KeyValuePairOfStringAndLeaderboardRoundScore!]
  isLive: Boolean!
  age: Int
  time: String
  hasScore: [LeaderboardHasScore!]
  id: String
  playername: String
  nickname: String @deprecated(reason: "Use Playername instead")
  email: String
  hcp: Float
  gender: String
  nationality: String
  picture: String
  category: String
  status: InvitationStatus!
}

"A segment of a collection."
type LongestDriveLeaderboardRecordTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [LongestDriveLeaderboardRecord]
  totalCount: Int!
}

type LongestDriveLeaderboardRecord {
  playerDbId: String
  "The id of the player"
  playerId: ID
  score: LeaderboardRoundLongestDriveScoreType
  scores: [KeyValuePairOfStringAndLeaderboardRoundScore!]
  isLive: Boolean!
  age: Int
  time: String
  hasScore: [LeaderboardHasScore!]
  id: String
  playername: String
  nickname: String @deprecated(reason: "Use Playername instead")
  email: String
  hcp: Float
  gender: String
  nationality: String
  picture: String
  category: String
  status: InvitationStatus!
}

"A segment of a collection."
type BullsEyeLeaderboardRecordTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [BullsEyeLeaderboardRecord]
  totalCount: Int!
}

type BullsEyeLeaderboardRecord {
  playerDbId: String
  "The id of the player"
  playerId: ID
  "The total score"
  total: BullsEyeLeaderboardTotalScore
  scores: [KeyValuePairOfStringAndLeaderboardRoundScore!]
  isLive: Boolean!
  age: Int
  time: String
  hasScore: [LeaderboardHasScore!]
  id: String
  playername: String
  nickname: String @deprecated(reason: "Use Playername instead")
  email: String
  hcp: Float
  gender: String
  nationality: String
  picture: String
  category: String
  status: InvitationStatus!
}

input HoleSponsorInputType {
  holeNumber: Int
  sponsorId: ID
}

input BaySponsorInputTypeType {
  "The id for the bay"
  bayId: NonEmptyString!
  "The id for the sponsor"
  sponsorId: NonEmptyString!
}

type ApplicationLayoutPage {
  identifier: String
  layout: String
  displayName: String
  groups: [ApplicationLayoutGroup!]
}

type ReleaseComponent {
  identifier: String
  mountPoint: String
  version: String
  isPrerelease: Boolean
  resource: ReleaseResource
  components: [ReleaseComponent]
}

input ClubFilterInput {
  and: [ClubFilterInput!]
  or: [ClubFilterInput!]
  data: ClubDataFilterInput
  type: StringOperationFilterInput
  playerId: StringOperationFilterInput
  displayName: StringOperationFilterInput
  isRetired: BooleanOperationFilterInput
  id: StringOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  lastUpdatedAt: DateTimeOperationFilterInput
  createdBy: StringOperationFilterInput
  lastUpdatedBy: StringOperationFilterInput
}

input BallFilterInput {
  and: [BallFilterInput!]
  or: [BallFilterInput!]
  data: BallDataFilterInput
  type: StringOperationFilterInput
  playerId: StringOperationFilterInput
  displayName: StringOperationFilterInput
  isRetired: BooleanOperationFilterInput
  id: StringOperationFilterInput
  createdAt: DateTimeOperationFilterInput
  lastUpdatedAt: DateTimeOperationFilterInput
  createdBy: StringOperationFilterInput
  lastUpdatedBy: StringOperationFilterInput
}

type Club implements Node {
  id: ID!
  "The name of the club head"
  clubHead: ClubHead
  type: String
  playerId: String
  displayName: String
  isRetired: Boolean!
  createdAt: DateTime!
  lastUpdatedAt: DateTime!
  createdBy: String
  lastUpdatedBy: String
}

type Ball implements Node {
  id: ID!
  ballType: String
  type: String
  playerId: String
  displayName: String
  isRetired: Boolean!
  createdAt: DateTime!
  lastUpdatedAt: DateTime!
  createdBy: String
  lastUpdatedBy: String
}

type HcpRecord {
  "The time this record was created"
  createdAt: DateTime!
  "The internal database id"
  dbId: String
  "The time the resource was last updated"
  lastUpdatedAt: DateTime!
  "The facility that owns the resource"
  facility: Facility
  "The db id of this record"
  id: String
  "The scorecard this record is based on"
  scorecard: Scorecard
  isInAvg: Boolean
  "The list of all the scorecards the current hcp index is based on"
  avgBasedOn: [HcpRecord!]
  "The list of scorecards the latest adjustment is based on"
  adjustmentBasedOn: [HcpRecord!]
  "Old Hcp"
  hcpOld: Float
  "New Hcp"
  hcpNew: Float!
  "Adjusted GrossScore"
  adjustedGrossScore: Float!
  "ScoreDifferential"
  scoreDifferential: Float!
  "TeeInfo"
  teeInfo: TeeInfoWithoutHoles
  "Adjustment"
  adjustment: Float!
}

"A segment of a collection."
type HcpHistoryCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [HcpRecord]
  totalCount: Int!
}

type PlannedRound implements Node {
  id: ID!
  "The time the resource was created"
  createdAt: DateTime!
  "The last time the resource was updated"
  lastUpdatedAt: DateTime!
  "The course"
  course: Course
  "The name of the planned round"
  name: String
  "The description of the planned round"
  description: String
  "The course identifier of the planned round"
  courseIdentifier: String
  "The default tee of the planned round"
  defaultTee: String
  "The default male tee of the planned round"
  defaultMaleTee: String
  "The default female tee of the planned round"
  defaultFemaleTee: String
  "The game type of the planned round"
  gameTypes: GameTypes
  "The holes to play of the planned round"
  holesToPlay: HolesToPlay
  "The putting mode of the planned round"
  puttingMode: PuttMode
  "The gimme distance of the planned round"
  gimmeDistance: NonNegativeFloat
  mulligans: Mulligans
  "The wind speed of the planned round"
  windSpeed: WindMode
  "The fairway firmness of the planned round"
  fairwayFirmness: Firmness
  "The green firmness of the planned round"
  greenFirmness: Firmness
  "The green speed firmness of the planned round"
  greenStimp: Stimp
  "The pin difficulty of the planned round"
  pin: Pin
}

type ActivitySummary {
  "The activity kind"
  kind: ActivityKind
  "Number of activities of this kind"
  activityCount: Int
  "Number of players with this kind of activity"
  playerCount: Int
  "The last activity of this kind"
  lastActivityTime: DateTime
}

"A segment of a collection."
type PlayerActivitySummaryTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [PlayerActivitySummary]
  totalCount: Int!
}

"A segment of a collection."
type CoachStudentTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [CoachStudent]
  totalCount: Int!
}

"A friendship"
type Friendship implements Node {
  "The global object identification"
  id: ID!
  "The friendship kind"
  kind: FriendshipKind! @deprecated(reason: "No longer used")
  "The friendship status"
  status: FriendshipStatus!
  "The friends in the friendship"
  friends: [Friend!]!
  "The time the friendship was created"
  createdAt: DateTime!
}

"A segment of a collection."
type SearchPersonInfoTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [SearchPersonInfo]
}

type FacilityUserConsentItem {
  facilityName: String
  consents: [UserConsentItem!]
}

"A segment of a collection."
type CombineLeaderboardRecordTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [CombineLeaderboardRecord]
  totalCount: Int!
}

"Sort order for facility visitors"
enum VisitorOrderByEnum {
  "Order by player name"
  playerName
  "Order by full name"
  fullName
  "Order by email"
  email
  "Text match"
  match
}

"Sort direction"
enum SortDirection {
  "Ascending"
  asc
  "Descending"
  desc
}

type DomainInfo {
  name: String
  displayName: String
}

type Role {
  "The RoleType Id"
  id: ID
  "The name of the RoleType"
  name: String
  "The display name of the RoleType"
  displayName: String
  "The users of the RoleType"
  users(skip: Int take: Int): UserRolesTypeCollectionSegment
}

"A segment of a collection."
type UserRolesTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [UserRoles]
  totalCount: Int!
}

input MaintenanceHoursInput {
  startTime: TimeSpan
  endTime: TimeSpan
}

"Get sponsor information for sponsor added to this hole"
type HoleSponsorType {
  "Hole number of the course"
  holeNumber: Int
  "Sponsor information"
  sponsor: Sponsor
}

input CourseSettingsListInputType {
  "The id of the configuration collection"
  id: String
  "The id of the future configuration"
  futureConfigurationId: String
  "The list of courses that´s gonna be deployed to the render station when this configuration is applied"
  courseList: [CourseWithSettingsBaseInputType]
}

"Mutations available for a range course instance"
type DrivingRangeConfigurationCourseInstanceMutations {
  "Change the green firmness for this course instance"
  changeGreenFirmness(greenFirmness: Firmness!): DrivingRangeConfiguration
  "Change the fairway firmness for this course instance"
  changeFairwayFirmness(fairwayFirmness: Firmness!): DrivingRangeConfiguration
  "Change the pin difficulty for this course instance"
  changePinDifficulty(pinDifficulty: Pin!): DrivingRangeConfiguration
  "Change the lighting for this course instance"
  changeLighting(lighting: Lighting!): DrivingRangeConfiguration
  "Change the green stimp for this course instance"
  changeGreenStimp(stimp: Stimp!): DrivingRangeConfiguration
  "Change all settings for this course instance"
  changeAll(greenFirmness: Firmness! fairwayFirmness: Firmness! pinDifficulty: Pin! lighting: Lighting! stimp: Stimp!): DrivingRangeConfiguration
  courseInstanceId: String
}

"Mutations available for a future configuration"
type DrivingRangeConfigurationFutureConfigurationMutationType {
  "Update the future configuration to one supplied"
  updateFutureConfiguration(courseConfiguration: CourseSettingsListInputType!): DrivingRangeConfiguration
  "Delete the future configuration"
  deleteFutureConfiguration: DrivingRangeConfiguration
  futureConfigurationId: String
}

enum MembershipAccess {
  ACCESS_FOR_ALL
  ACCESS_FOR_MEMBERS_ONLY
  ACCESS_TO_VIRTUAL_GOLF_FOR_MEMBERS_ONLY
}

input UpdatedScorecard {
  id: [ID] @deprecated(reason: "No longer supported.")
  records: [UpdatedScorecardRecordInput]
}

type WebHook implements Node {
  "The time the resource was created"
  createdAt: DateTime!
  "The internal database id"
  dbId: String!
  "The time the resource was last updated"
  lastUpdatedAt: DateTime!
  "The facility that owns the resource"
  facility: Facility
  id: ID!
  "The description of the webhook."
  description: String
  "Indicates if the webhook is activated."
  isActivated: Boolean!
  "The endpoint URL of the webhook."
  endpointUrl: String
  locations: [LocationInterfaceType!]
  "The event types that the webhook is listening to."
  eventTypes: [WebHookEventName!]
}

enum WebHookEventName {
  "A player is changed."
  TPS_SIMULATOR_CHANGE_PLAYER
  "A player is given a gimme."
  TPS_SIMULATOR_GIVEN_GIMME
  "A player picks up their ball."
  TPS_SIMULATOR_PLAYER_PICKUP
  "A player is given a mulligan."
  TPS_SIMULATOR_GIVEN_MULLIGAN
  "A simulator shot is finished."
  TPS_SIMULATOR_SHOT_FINISH
  "A simulator shot is starting."
  TPS_SIMULATOR_SHOT_STARTING
  "All events."
  ALL_EVENTS
}

type WebHookMutationData {
  "Update a WebHook"
  update(endpointUrl: String description: String eventTypes: [WebHookEventName] bayIds: [ID!] locationIds: [ID!] headers: [KeyValueInput!]): WebHook
  "Delete a WebHook"
  delete: Boolean
  "Activate a WebHook"
  activate: Boolean
  "Test a WebHook"
  test(eventType: String = "TestEventType" subject: String = "Test.Subject" data: JSON): Boolean
  id: String
}

"A segment of a collection."
type FacilityTournamentsTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [Tournament]
  totalCount: Int!
}

"The different product kinds available"
enum TrackmanProductKinds {
  INDOOR
  RANGE
}

"The context in which the course is used"
enum CourseContextKinds {
  FACILITY
  GLOBAL
}

type CoursesConfigurations {
  "The configuration currently deployed"
  currentConfiguration: DesiredCoursesConfiguration
  "The configuration that will be deployed when the next service window is active."
  futureConfiguration(useCurrentIfFutureConfigurationHasNoCourses: Boolean = false): DesiredCoursesConfiguration!
}

type CourseWithSettingsDeployed implements CourseWithSettingsInterface {
  "The identifier for this course"
  courseIdentifier: String
  "The instance id for this course"
  courseInstanceId: String
  "The version of this course binary"
  courseVersion: String
  "The metadata version for the course data ie. scorecard data."
  metadataVersion: String
  "The green firmness for this course instance"
  greenFirmness: Firmness
  "The fairway firmness for this course instance"
  fairwayFirmness: Firmness
  "The green stimp rating for this course instance"
  greenStimp: Stimp
  "The lighting for this course instance"
  lighting: Lighting
  "The pin difficulty for this course instance"
  pinTag: Pin
  "The metadata for this course"
  course: Course
  courseInfo: CoursePerformanceProperties
  courseLocks: [CourseLock]
}

type FacilityVisitor implements Node {
  "The global object identification"
  id: ID!
  "Information available for this person"
  person: PersonInfo
  "When the location was last visited"
  lastVisited: DateTime
  "Number of days the location was visited"
  visitedDays: Int
  "Consents for the facility"
  consents: [FacilityVisitorConsent]
  "Return all info abut the players TrackMan handicap"
  hcp: Hcp @deprecated(reason: "Use person.hcp")
  "Activities connected to a person"
  activities(includeHidden: Boolean kinds: [ActivityKind!] timeFrom: DateTime timeTo: DateTime skip: Int take: Int): PlayerActivityInterfaceTypeCollectionSegment
  "The scorecards for rounds played at this facility."
  scorecards(tournamentIds: [String] tournamentRoundIds: [String] courseIdentifiers: [String] fromDate: DateTime toDate: DateTime searchTournamentsText: String skip: Int take: Int): ScorecardTypeCollectionSegment
}

"A segment of a collection."
type WebHooksCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [WebHook]
  totalCount: Int!
}

type SafetyBorderConfigurationMutations {
  "Update the safety border notifications settings"
  setNetConfiguration(configuration: NetNotificationConfigurationInput!): NetNotificationConfiguration
  "Change the location PIN code"
  setPinCode(pinCode: String!): Boolean
}

"Allow profile to be shown or searched"
enum AllowProfileSearch {
  "Don't allow my profile to be shown or searched"
  Nobody
  "Only allow my profile to be shown or searched by the players I have played with"
  PlayedWith
  "Allow my profile to be shown or searched by anyone"
  Anyone
}

type PurchaseResponseType {
  "The internal id for the purchase"
  purchaseId: String
  "The internal status for the purchase"
  status: String
}

input PurchaseInputType {
  "The order-id from the app store"
  OrderId: String
  "App store product identifier"
  ProductIdentifier: String
  "The app store where the product was purchased"
  Source: String
  "The date and time for purchase"
  TransactionDate: DateTime
  "The validation token from the app store for the purchase"
  PurchaseToken: String
  "??"
  OriginalJson: String
  "??"
  ReceiptUrl: String
}

"The IPv4 scalar type represents a valid a IPv4 address as defined in RFC791"
scalar IPv4

type BroadcastNotificationDetails {
  state: String
  target: String
  result: [KeyValuePairOfStringAndInt64!]
}

input PartnerConsentLocalizedInput {
  "The country code"
  cultureCode: NonEmptyString
  "The key of the partner's consent"
  infoUrl: String
  "The title of the consent"
  title: String
  "The description of the consent"
  description: String
}

"Returns all received emails"
type EmailHistory {
  "Subject of the email"
  subject: String
  "Receiver of the email"
  receiverEmail: String
  "Sender of the email"
  senderEmail: String
  "State of the email"
  state: String
  "Time when the email was received"
  time: DateTime
}

"A segment of a collection."
type EventLogItemTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [EventLog]
  totalCount: Int!
}

type UpdatePlayerHcpCommandResult {
  "The list of all the scorecards the current hcp index is based on"
  succeeded: [PlayerHcpUpdate!]
  "The list of all the scorecards the current hcp index is based on"
  failed: [PlayerHcpUpdate!]
}

type Point3D {
  x: Float
  y: Float
  z: Float
}

"A segment of a collection."
type NetTypeCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [Net]
  totalCount: Int!
}

input NetVersionFilter {
  "Filter by one or more Tags"
  tags: [String]
  "Specify whether to returned enabled, disabled or all launch areas regardless of status"
  isEnabled: Boolean
  "Filter by the draft or published state of the launch area. If unspecified, only published launch areas will be returned by default."
  publishState: PublishStateFilterType = PUBLISHED
}

"A segment of a collection."
type TargetVersionsCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [RangeTarget]
  totalCount: Int!
}

input TargetVersionFilter {
  "Filter by one or more Tags"
  tags: [String]
  "Specify whether to return enabled, disabled or all targets regardless of status"
  isEnabled: Boolean
  "Filter by the draft or published state of the target. If unspecified, only published targets will be returned by default."
  publishState: PublishStateFilterType = PUBLISHED
}

"A segment of a collection."
type LaunchAreaVersionsCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [LaunchAreaType]
  totalCount: Int!
}

input LaunchAreaVersionFilter {
  "Filter by one or more Tags"
  tags: [String]
  "Specify whether to return enabled, disabled or all launch areas regardless of status"
  isEnabled: Boolean
  "Filter by the draft or published state of the launch area. If unspecified, only published launch areas will be returned by default."
  publishState: PublishStateFilterType = PUBLISHED
}

"A segment of a collection."
type RadarVersionsCollectionSegment {
  "Information to aid in pagination."
  pageInfo: CollectionSegmentInfo!
  "A flattened list of the items."
  items: [Radar]
  totalCount: Int!
}

input RadarVersionFilter {
  "Filter by one or more Tags"
  tags: [String]
  "Specify whether to return enabled, disabled or all targets regardless of status"
  isEnabled: Boolean
  "Filter by the draft or published state of the target. If unspecified, only published targets will be returned by default."
  publishState: PublishStateFilterType = PUBLISHED
}

enum SortEnumType {
  ASC
  DESC
}

enum RangeEntityTypesEnumType {
  BAY
  TARGET
  RADAR
  NET
  LAUNCH_AREA
}

type RangeConfigurationBay {
  dbId: String!
  modificationStatus: EntityModificationStatusType
  bay: RangeBay
}

enum EntityModificationStatusType {
  UNCHANGED
  ADDED
  MODIFIED
  DELETED
}

type RangeConfigurationLaunchArea {
  dbId: String!
  modificationStatus: EntityModificationStatusType
  launchArea: LaunchAreaType
}

type RangeConfigurationNet {
  dbId: String!
  modificationStatus: EntityModificationStatusType
  net: Net
}

type RangeConfigurationTarget {
  dbId: String!
  modificationStatus: EntityModificationStatusType
  target: RangeTarget
}

type RangeConfigurationRadar {
  dbId: String!
  modificationStatus: EntityModificationStatusType
  radar: Radar
}

type NetNotificationConfiguration {
  dbId: String
  rules: [NetNotificationRule]
}

type NetNotificationDefaultMessages {
  alertType: NetAlertType!
  message: String
}

enum PublishStateFilterType {
  PUBLISHED
  DRAFT
  BOTH
}

"Stroke information"
interface StrokeV2Interface {
  time: DateTime
}

"The information of the bay in net incident"
type NetIncidentBay {
  "The Id of the bay"
  dbId: String
  "The name of the bay"
  name: String
  "The type of the bay"
  type: String
  "The location of the bay"
  location: SiteLocationModel
}

type TrackerMessagePlayer {
  "The id of the player"
  id: String
  "The name of the player"
  name: String
  "Indicate whether the player is a temporary player or not"
  isTempAccount: Boolean
}

type SiteLocationModel {
  "X,Y,Z position based on the site coordinate system"
  sitePoint: [Float]
  "The location based on the world latitude and longitude"
  worldPoint: LatLonAlt
}

type MeasurementDetailImpactLocation {
  measurements: Measurements
  clubConfiguration: ClubConfiguration
  cameraConfiguration: CameraConfiguration
  data: [KeyValuePairOfStringAndObject!]
}

type TargetStroke {
  "Score for this target"
  score: Float
  totalLength: Float
  totalSide: Float
  lengthToTarget: Float
  distanceFromPin: Float
  total: Float
  "Stroke data"
  stroke: Stroke
  measurementId: UUID
  data: [KeyValuePairOfStringAndObject!]
}

type DrivingRangeMetadataImage {
  path: String
  uri: String
  width: Int!
  height: Int!
}

"Data for a shot on a Scorecard"
type ScorecardShot implements Node {
  id: ID!
  "The shot number. Note: penalty shots is added"
  shotNumber: Int
  "The lie the ball was launched from"
  launchLie: String
  "The shot videos"
  videos(kinds: [RecordedHoleVideoKind!] includeHidden: Boolean = false): [RecordedHoleVideo!]
  "The Total ball flight and roll"
  total: Float
  "The club that was used"
  club: String
  "The position the ball was launched from"
  launchPosition: Position
  "The time the ball was launched"
  launchTime: DateTime
  "The position of the point that the shot was aimed at"
  aimPoint: Position
  "The lie of the final ball position"
  finalLie: String
  "The final ball position after the shot"
  finalPosition: Position
  "The time the ball was laying still"
  finalTime: DateTime
  "The time the ball was flying\/rolling"
  movingTimeInSeconds: TimeSpan
  "The shot result"
  shotResult: String
  "The number of shots added (penalty shots)"
  shotsToAdd: Int
  "The position of the ball after a drop"
  dropPosition: Position
  measurement(shotMeasurementKind: ShotMeasurementKind = MEASUREMENT): ShotMeasurement
}

type Position {
  x: Float!
  y: Float!
  z: Float!
  worldLocation: LatLon
  imageTransformationKinds(forVideos: Boolean = false): [String]
  imageTransformation(kind: String = "TopView" forVideos: Boolean = false): UnityTransformationMetadataPixelPosition
}

type BallPositionValidation {
  "Is the ball position data valid"
  isBallPositionDataValid: Boolean
  "What type of shot was it"
  shotResult: String
  "Result of the validation"
  reason: String
}

type HoleInfo {
  "The length of the hole from the tee"
  distance: Float
  "The hole number"
  holeNumber: Int!
  "The par of the hole from the tee"
  par: Int
  "The stroke index of the hole from the tee"
  strokeIndex: Int
}

"Putting options for the game"
enum PuttingOptions {
  AUTO_TOUR_PRO
  AUTO_BY_HANDICAP
  AUTO_TWO_PUTT
  AUTO_FIXED
  MANUAL
  MANUAL_AIMED
  MANUAL_INPUT
}

type UnityTransformationMetadataPixelPosition {
  x: Int!
  y: Int!
  xPct: Float!
  yPct: Float!
}

input SimpleUtmInput {
  gridZone: String
  easting: Float!
  northing: Float!
}

input UnityPositionInput {
  x: Float!
  y: Float!
  z: Float!
}

"Compass"
enum Compass {
  N
  NE
  E
  SE
  S
  SW
  W
  NW
}

type HoleTee {
  groupId: String
  par: Int!
  strokeIndex: Int!
  distance: Float!
  worldLocation: LatLon
  "The position the tee"
  position: Position
}

type HolePin {
  region: String
  difficulty: HolePinDifficulty
  worldLocation: LatLon
  "The position the tee"
  position: Position
}

enum HolePinDifficulty {
  EASY
  MEDIUM
  HARD
}

type TaggedPosition {
  tags: [String]
  worldLocation: LatLon
  "The position the tee"
  position: Position
}

type HoleTemplate {
  holeNumber: Int
  distance: Float
  par: Int
  hcpStroke: Int
  strokeIndex: Int
  teeName: String
  image(kind: String = "TopView"): ImageResource
  images: [MediaResource]
}

type QuickPlayTargetDefinition {
  "Target type"
  type: QuickPlayTargetType
  "Unit system"
  unitSystem: UnitSystem
  "Green layout"
  greenLayout: Int
  "Distance to target"
  distance: Float
  "Minimum distance to target"
  distanceFrom: Float
  "Maximum distance to target"
  distanceTo: Float
}

type QuickPlayStroke {
  "Stroke sequence number"
  strokeNumber: Int
  "Measurement id"
  measurementId: String
  "Distance to target"
  distanceToTarget: Float
  "Distance from pin"
  fromPin: Float
  "Side distance from pin"
  fromPinSide: Float
  "Length distance from pin"
  fromPinLength: Float
  "Score for this stroke"
  score: Float
  "Strokes gained for this stroke"
  strokesGained: Float
  "Final lie for this stroke"
  finalLie: PerformanceCenterLies
}

type TournamentTee {
  groupId: String
  kind: String
  name: String
  par: Int!
  courseRating: Float!
  slope: Int!
  courseDistance: Float!
  gender: String
}

type RoundGameSettings {
  "The fairway firmness"
  fairwayFirmness: Firmness
  "The green firmness"
  greenFirmness: Firmness
  "The pin difficulty"
  pinDifficulty: Pin
  "The wind mode"
  windSpeed: WindMode
  "Mulligans"
  mulligans: Mulligans
  "The putting mode"
  puttingMode: PuttMode
  "The gimme distance"
  gimmeDistance: NonNegativeFloat
  "The attempts per round"
  attemptsPerRound: Int
  "The attempt that is shown on the leaderboard"
  attemptsOnLeaderboard: Int
  "The green stimp for the round"
  greenStimp: Stimp
  "The lighting on the course when the round is played"
  lighting: Lighting
}

type TournamentClosestToPinEmbeddedGame {
  availableHoles: [Int]
  holes: [Int]
  courseIdentifier: String
  courseVersion: String
  selectedHoles: HolesToPlay!
  maleTee: TeeSettings
  femaleTee: TeeSettings
}

type TournamentLongestDriveEmbeddedGame {
  "Holes that can be selected for the embedded game"
  availableHoles: [Int]
  "Holes that has been selected for the embedded game"
  holes: [Int]
  courseIdentifier: String
  courseVersion: String
  selectedHoles: HolesToPlay!
}

"Method used to distribute order of merit points"
enum OrderOfMeritMaxScoreMethod {
  "Max points is based on the number of players"
  DEFAULT
  "Add a percentage to the max score calculated from the number of players"
  PERCENTAGE
  "Max score is selected by the tournament admin\/manager"
  CUSTOM
}

"Mutations on a Closest To Pin Embedded games"
type TournamentClosestToPinEmbeddedGameMutation {
  "Apply new list of holes"
  changeHoles(holesToPlay: [Int]): TournamentClosestToPinEmbeddedGame
  courseIdentifier: String
  courseVersion: String
  selectedHoles: HolesToPlay!
  maleTee: TeeSettings
  femaleTee: TeeSettings
  holes: [Int!]
}

"Mutations on a Longest Drive Embedded games"
type TournamentLongestDriveEmbeddedGameMutation {
  "Apply new list of holes"
  changeHoles(holesToPlay: [Int]): TournamentLongestDriveEmbeddedGame
  courseIdentifier: String
  courseVersion: String
  selectedHoles: HolesToPlay!
  holes: [Int!]
}

input ScorecardScoreItemInput {
  hole: PositiveInt!
  score: PositiveInt!
}

input ScorecardPlayerItemInput {
  id: ID!
  hcp: Float
}

"A Team"
type Team implements Node {
  "The global object identification"
  id: ID!
  "name of the team"
  name: String
  "The members in the team"
  members: [Member!]!
  "The time the team was created"
  createdAt: DateTime!
}

"Number of holes played on last played round"
type LeaderboardTotalScore {
  "Player position on the leaderboard"
  pos: Int
  posLabel: String
  score: Float
  toPar: Int
  state: TournamentPlayerRoundState
  thru: Int
  "Last played round number"
  roundNumber: Int
}

"Number of holes played on last played round"
type LeaderboardRoundScoreType {
  "Player position on the leaderboard"
  pos: Int
  posLabel: String
  score: Float
  toPar: Int
  state: TournamentPlayerRoundState
  thru: Int
  "Last played round number"
  roundNumber: Int
  "Round state"
  roundState: TournamentRoundState
  scorecardId: ID
  scorecardDbId: String
  scorecard: Scorecard
  previousOomPos: Int
  projectedOomPos: Int
  isCountingScore: Boolean
}

type LeaderboardRoundClosestToPinScoreType {
  "Player position on the leaderboard"
  pos: Int
  posLabel: String
  state: TournamentPlayerRoundState!
  finalPosition: Position
  "The hole"
  hole: ScorecardHole
  distanceToPin: Float
  roundNumber: Int
  holeNumber: Int!
  tournamentRound: TournamentRound
  leaderboardRoundScore: LeaderboardRoundScore
  leaderboardPlayerInfo: LeaderboardRecord
  orderOfMeritInfo: LeaderboardOrderOfMeritInfo
}

type LeaderboardRoundLongestDriveScoreType {
  "Player position on the leaderboard"
  pos: Int
  posLabel: String
  state: TournamentPlayerRoundState!
  finalPosition: Position
  "The hole"
  hole: ScorecardHole
  driveDistance: Float
  "Score for player"
  score: Decimal
  "Normalized score for player"
  scoreNormalized: Decimal
  "Total distance of all shots"
  totalDistanceAllShots: Decimal
  roundNumber: Int
  holeNumber: Int!
  tournamentRound: TournamentRound
  leaderboardRoundScore: LeaderboardRoundScore
  leaderboardPlayerInfo: LeaderboardRecord
  orderOfMeritInfo: LeaderboardOrderOfMeritInfo
}

type OtherLeaderboardsRecord {
  playerDbId: String
  "The id of the player"
  playerId: ID
  "The result"
  result: OtherLeaderboardsTotalScore
  scores: [KeyValuePairOfStringAndLeaderboardRoundScore!]
  isLive: Boolean!
  age: Int
  time: String
  hasScore: [LeaderboardHasScore!]
  id: String
  playername: String
  nickname: String @deprecated(reason: "Use Playername instead")
  email: String
  hcp: Float
  gender: String
  nationality: String
  picture: String
  category: String
  status: InvitationStatus!
}

type AggregatedClosestToPinLeaderboardRecord {
  playerDbId: String
  "The id of the player"
  playerId: ID
  "The total score"
  total: ClosestToPinLeaderboardRoundScoreType
  "The holes played in the tournament"
  holes: [ClosestToPinLeaderboardHoleScoreWithoutPosType!]
  scores: [KeyValuePairOfStringAndLeaderboardRoundScore!]
  isLive: Boolean!
  age: Int
  time: String
  hasScore: [LeaderboardHasScore!]
  id: String
  playername: String
  nickname: String @deprecated(reason: "Use Playername instead")
  email: String
  hcp: Float
  gender: String
  nationality: String
  picture: String
  category: String
  status: InvitationStatus!
}

type PointInfo {
  "Position on the leaderboard"
  position: Int
  "Points for that position on the leaderboard"
  points: Float
}

type ClosestToPinLeaderboardTotalScore {
  distanceToPin: Float
  distanceToPinWithPenalty: Float
  state: TournamentPlayerRoundState
}

type ClosestToPinLeaderboardRoundScoreType {
  distanceToPin: Float
  distanceToPinWithPenalty: Float
  state: TournamentPlayerRoundState
  "The hole played for this result"
  holeNumber: Int!
  "The finishing lie for the shot"
  lie: String
  "The total distance for the shot"
  distance: Float
  "The penalty for the shot (if any)"
  penalty: Float
  scorecardId: String
  "The hole"
  hole: ScorecardHole
  filterPos: Int
  filterPosLabel: String
  pos: Int
  posLabel: String
}

type BullsEyeLeaderboardTotalScore {
  distanceToPin: Float
  pos: Int
  posLabel: String
  filterPos: Int
  filterPosLabel: String
  score: Float
  state: TournamentPlayerRoundState
  "Value1 for player"
  value1: Decimal
  "Value1 for player"
  value2: Decimal
  "Value1 for player"
  value1Normalized: Decimal
  "Value1 for player"
  value2Normalized: Decimal
  "Average distance to pin"
  averageDistanceToPin: Decimal
}

type ApplicationLayoutGroup {
  identifier: String
  layout: String
  displayName: String
  items: [ApplicationLayoutGroupItemInterface!]
}

input ClubDataFilterInput {
  and: [ClubDataFilterInput!]
  or: [ClubDataFilterInput!]
  clubHead: ClubHeadFilterInput
}

input StringOperationFilterInput {
  and: [StringOperationFilterInput!]
  or: [StringOperationFilterInput!]
  eq: String
  neq: String
  contains: String
  ncontains: String
  in: [String]
  nin: [String]
  startsWith: String
  nstartsWith: String
  endsWith: String
  nendsWith: String
}

input BooleanOperationFilterInput {
  eq: Boolean
  neq: Boolean
}

input DateTimeOperationFilterInput {
  eq: DateTime
  neq: DateTime
  in: [DateTime]
  nin: [DateTime]
  gt: DateTime
  ngt: DateTime
  gte: DateTime
  ngte: DateTime
  lt: DateTime
  nlt: DateTime
  lte: DateTime
  nlte: DateTime
}

input BallDataFilterInput {
  and: [BallDataFilterInput!]
  or: [BallDataFilterInput!]
  type: StringOperationFilterInput
}

type PlayerActivitySummary {
  "Information about this player"
  player: PersonInfo
  "Number of activities of this kind"
  activityCount: Int
  "The kinds of activities for this player"
  activityKinds: [ActivityKind]
  "The last activity of this kind"
  lastActivityTime: DateTime
}

type CoachStudent implements Node {
  "The global object identification"
  id: ID!
  "Information available for this player"
  player: PersonInfo
  "When the coach was last visited"
  lastVisitTime: DateTime
  "Number of days the coach has visited"
  visitCount: Int
  "Activities connected to a person"
  activities(includeHidden: Boolean kinds: [ActivityKind!] timeFrom: DateTime timeTo: DateTime skip: Int take: Int): PlayerActivityInterfaceTypeCollectionSegment
}

"The friendship kind"
enum FriendshipKind {
  "Friendship with only one friend"
  individual
  "Friendship with one or more friends"
  team
}

"The friendship status"
enum FriendshipStatus {
  "The friendship request has been sent"
  sent
  "The friendship request has been received"
  received
  "The friendship is accepted"
  accepted
  "The friendship is withdrawn"
  withdrawn
  "The friendship is declined"
  declined
  "The friendship is cancelled"
  cancelled
  "No friendship"
  none
}

"Friend in a friendship"
type Friend {
  "Information about this person"
  person: PersonInfo
  "Friendship status for friend"
  status: FriendshipStatus!
}

type SearchPersonInfo {
  "Information available for this person"
  person: PersonInfo
  "friend"
  friend: Friendship
}

type CombineLeaderboardRecord {
  playerDbId: String
  "The id of the player"
  playerId: ID
  "The total score"
  score: Float
  activity: CombineTestActivity
  age: Int
  time: String
  hasScore: [LeaderboardHasScore!]
  id: String
  playername: String
  nickname: String @deprecated(reason: "Use Playername instead")
  email: String
  hcp: Float
  gender: String
  nationality: String
  picture: String
  category: String
}

input CourseWithSettingsBaseInputType {
  "The identifier for this course"
  courseIdentifier: NonEmptyString!
  "The instance id for this course"
  courseInstanceId: String
  "The metadata version for the course data ie. scorecard data."
  metadataVersion: NonEmptyString!
  "The green firmness for this course instance"
  greenFirmness: Firmness
  "The fairway firmness for this course instance"
  fairwayFirmness: Firmness
  "The green stimp rating for this course instance"
  greenStimp: Stimp
  "The lighting for this course instance"
  lighting: Lighting
  "The pin difficulty for this course instance"
  pinTag: Pin
}

input UpdatedScorecardRecordInput {
  "List of players on the scorecard"
  players: [UpdatedPlayerInput]
  "Updated holes"
  holes: [UpdatedScorecardHoleInput]
}

type DesiredCoursesConfiguration {
  id: ID
  "The courses added to this configuration"
  coursesAndSettings: [CourseWithSettings!]
  "Server VRAM capacity display value"
  serverVramCapacityDisplay: String
  "Server VRAM capacity In MB"
  serverVramCapacityInMegabytes: Int
  "Facility configuration VRam capacity display value"
  facilityConfigurationVramCapacityDisplay: String
  "Facility configuration VRam capacity In MB"
  facilityConfigurationVramCapacityInMegabytes: Int
  "Facility configuration VRam capacity display value"
  trackManConfigurationVramCapacityDisplay: String
  "Facility configuration VRam capacity in MB"
  trackManConfigurationVramCapacityInMegabytes: Int
  "Facility configuration VRam used display value"
  facilityConfigurationVramUsedDisplay: String
  "Facility configuration VRam used in MB"
  facilityConfigurationVramUsedInMegabytes: Int
  "VRAM used display value for facility and TrackMan configurations"
  facilityAndTmConfigurationsVramUsedDisplay: String
  "VRAM used in MB for facility and TrackMan configurations"
  facilityAndTmConfigurationsVramUsedInMegabytes: Int
  "VRAM left display value for facility configurations"
  facilityConfigurationVramAvailableDisplay: String
  "VRAM left in MB for facility configurations"
  facilityConfigurationVramAvailableInMegabytes: Int
}

interface CourseWithSettingsInterface {
  "The identifier for this course"
  courseIdentifier: String
  "The instance id for this course"
  courseInstanceId: String
  "The metadata version for the course data ie. scorecard data."
  metadataVersion: String
  "The green firmness for this course instance"
  greenFirmness: Firmness
  "The fairway firmness for this course instance"
  fairwayFirmness: Firmness
  "The green stimp rating for this course instance"
  greenStimp: Stimp
  "The lighting for this course instance"
  lighting: Lighting
  "The pin difficulty for this course instance"
  pinTag: Pin
}

type CoursePerformanceProperties {
  calculateVramUsageEstimate(min: Int! med: Int! max: Int!): Int!
  resourceId: String
  resourceIdentifier: String
  resourceVersion: String
  resourcePlatform: String
  ramSizeAverageInGigabytes: Float!
  ramSizeMaxInGigabytes: Float!
  vramUsageLoadTexture1InMegabytes: Int!
  vramUsageAverageTexture1InMegabytes: Int!
  vramUsageMaxTexture1InMegabytes: Int!
  vramUsageLoadTexture05InMegabytes: Int!
  vramUsageAverageTexture05InMegabytes: Int!
  vramUsageMaxTexture05InMegabytes: Int!
  vramUsageLoadTexture025InMegabytes: Int!
  vramUsageAverageTexture025InMegabytes: Int!
  vramUsageMaxTexture025InMegabytes: Int!
  textureResolutionInUse: String
  getCourseVramUsageInMegabytesForRange: Int!
  id: String
  createdAt: DateTime!
  lastUpdatedAt: DateTime!
  createdBy: String
  lastUpdatedBy: String
}

type CourseLock {
  "Lock Id"
  lockId: String
  "Lock Type"
  lockType: String
  "Tournament Id"
  tournamentId: String
  "Tournament Name"
  tournamentName: String
  "Round Id"
  roundId: String
  "Round Number"
  roundNumber: String
  "Start Time"
  startTime: DateTime
  "End Time"
  endTime: DateTime
}

type FacilityVisitorConsent {
  "The kind of the consent"
  kind: String
  "Consent accepted or not"
  accepted: Boolean
}

input NetNotificationConfigurationInput {
  "The rules of the configuration"
  rules: [staffNotifications]!
}

"Returns an event log"
type EventLog {
  "Id of the event"
  id: String
  "Event that happened"
  event: String
  "Details of the event"
  eventDetails: String
  "Recipients of the event"
  recipients: [EventLogRecipient]
  "Time when the event was created"
  time: DateTime
  "All event data"
  eventData: JSON
}

type PlayerHcpUpdate {
  "DbId of the player"
  playerId: String
  "DbId of the scorecard"
  scorecardId: String
  "The date the scorecard was created"
  scorecardCreated: DateTime
  "Old Hcp"
  hcpOld: Float
  "New Hcp"
  hcpNew: Float
  "Exceptional score adjustment"
  exceptionalScoreAdjustment: Float
  "Messages for the current hcp update"
  messages: String
  "Hcp Cap"
  hcpCap: HcpCap
}

type NetNotificationRule {
  dbId: String
  isActive: Boolean
  triggerBall: Int
  appNotification: NetAlertType!
  appNotificationMessage: String
  kioskAppNotification: NetAlertType
  kioskAppNotificationMessage: String
  staffNotifications: [StaffNotification]
}

type RecordedHoleVideo {
  launchTimeInSeconds: Float
  finalTimeInSeconds: Float
  videoUrl: URL
  videoKind: RecordedHoleVideoKind
  isHidden: Boolean
}

"The kind of video"
enum RecordedHoleVideoKind {
  COMBINED_VIDEO
  MOBILE_VIDEO
  SCREEN_RECORDING
}

type ShotMeasurement {
  "The speed of the ball when it was hit"
  ballSpeed: Float
  "The actual side distance"
  carrySideActual: Float
  "The actual carry distance"
  carryActual: Float
  "The direction in which the ball was launched"
  launchDirection: Float
  "The maximum height reached by the ball"
  maxHeight: Float
  "The distance the ball was carried in the air before it hit the ground"
  carry: Float
  "The total distance the ball traveled"
  total: Float
  "The side distance of the carry relative to the target line"
  carrySide: Float
  "The angle at which the ball was launched"
  launchAngle: Float
  "The last data point recorded for the ball's flight"
  lastData: Float
  "The rate of spin on the ball"
  spinRate: Float
  "The axis on which the ball is spinning"
  spinAxis: Float
  "The time taken to complete the backswing"
  backswingTime: Float
  "The time taken to complete the forward swing"
  forwardswingTime: Float
  "The tempo of the swing"
  tempo: Float
  "The length of the stroke"
  strokeLength: Float
  "The lie of the club at impact"
  dynamicLie: Float
  "The offset of the impact point from the center of the club face"
  impactOffset: Float
  "The height of the impact point above the ground"
  impactHeight: Float
  "The distance the ball skidded after impact"
  skidDistance: Float
  "The percentage of the ball's distance that was roll"
  rollPercentage: Float
  "The speed of the ball after impact"
  rollSpeed: Float
  "The drop in speed after impact"
  speedDrop: Float
  "The deceleration of the ball after impact"
  rollDeceleration: Float
  "The effective stimp of the green"
  effectiveStimp: Float
  "The flat stimp of the green"
  flatStimp: Float
  "The break of the green"
  break: Float
  "The number of bounces the ball took"
  bounces: Float
  "The distance the ball traveled at entry speed"
  entrySpeedDistance: Float
  "The elevation of the shot"
  elevation: Float
  "The side slope percentage"
  slopePercentageSide: Float
  "The rise slope percentage"
  slopePercentageRise: Float
  "The total break of the green"
  totalBreak: Float
  "The angle of attack of the club"
  attackAngle: Float
  "The path of the club"
  clubPath: Float
  "The speed of the club"
  clubSpeed: Float
  "The dynamic loft of the club"
  dynamicLoft: Float
  "The angle of the club face"
  faceAngle: Float
  "The angle between the club face and the club path"
  faceToPath: Float
  "The smash factor of the shot"
  smashFactor: Float
  "The gyro spin angle of the shot"
  gyroSpinAngle: Float
  "The spin loft of the shot"
  spinLoft: Float
  "The direction of the swing"
  swingDirection: Float
  "The plane of the swing"
  swingPlane: Float
  "The radius of the swing"
  swingRadius: Float
  "The tilt of the D plane"
  dPlaneTilt: Float
  "The distance to the low point of the swing"
  lowPointDistance: Float
  "The height of the low point of the swing"
  lowPointHeight: Float
  "The side distance to the low point of the swing"
  lowPointSide: Float
  "The height of the landing"
  landingHeight: Float
  "The total side distance"
  totalSide: Float
  "The side distance"
  side: Float
  "The angle of the landing"
  landingAngle: Float
  "The hang time of the shot"
  hangTime: Float
  "The curve of the shot"
  curve: Float
  "The actual total distance"
  totalActual: Float
  "The actual total side distance"
  totalSideActual: Float
  "The actual curve of the shot"
  curveActual: Float
  "The actual landing angle"
  landingAngleActual: Float
  "The actual spin axis"
  spinAxisActual: Float
  "Distance from the bay to the selected target"
  targetDistance: Float
  "The distance from the ball carry landing position to the pin"
  distanceFromPin: Float
  "The distance from the ball total landing position to the pin"
  distanceFromPinTotal: Float
}

"The kind of shot measurement"
enum ShotMeasurementKind {
  MEASUREMENT
  NORMALIZED_MEASUREMENT
  PRO_BALL_MEASUREMENT
}

enum QuickPlayTargetType {
  FIXED
  INTERVAL
}

enum UnitSystem {
  METRIC
  IMPERIAL
}

enum PerformanceCenterLies {
  BUSHES
  CONCRETE
  DEEPROUGH
  EARTH
  FAIRWAY
  FRINGE
  GREEN
  HOLE_CUP
  HOLE_LIP
  LEAVES
  MULCH
  PIN
  PINESTRAW
  ROCK
  ROUGH
  SAND
  SCRUB
  SEMIROUGH
  TEE
  TREE
  WATER
  WOOD
}

"Member in a team"
type Member {
  "Information about this person"
  person: PersonInfo
}

enum TournamentPlayerRoundState {
  NOT_PLAYED
  STARTED
  PLAYED
  NO_SHOW
  DID_NOT_FINISH
}

type OtherLeaderboardsTotalScore {
  scorecardId: ID
  scorecardDbId: String
  scorecard: Scorecard
  state: TournamentPlayerRoundState
  pos: Int
  posLabel: String
  score: Float
}

type ClosestToPinLeaderboardHoleScoreWithoutPosType {
  distanceToPin: Float
  distanceToPinWithPenalty: Float
  state: TournamentPlayerRoundState
  "The hole played for this result"
  holeNumber: Int!
  "The finishing lie for the shot"
  lie: String
  "The total distance for the shot"
  distance: Float
  "The penalty for the shot (if any)"
  penalty: Float
  scorecardId: String
  "The hole"
  hole: ScorecardHole
}

input ClubHeadFilterInput {
  and: [ClubHeadFilterInput!]
  or: [ClubHeadFilterInput!]
  type: StringOperationFilterInput
  kind: StringOperationFilterInput
}

input UpdatedPlayerInput {
  "Player id (not team id)"
  id: String!
  "Player handicap"
  hcp: Float @deprecated(reason: "No longer supported.")
}

input UpdatedScorecardHoleInput {
  "Hole number"
  holeNumber: Int!
  "Gross score"
  score: Int!
}

type CourseWithSettings implements CourseWithSettingsInterface {
  "The identifier for this course"
  courseIdentifier: String
  "The instance id for this course"
  courseInstanceId: String
  "The version of this course binary"
  courseVersion: String
  "The metadata version for the course data ie. scorecard data."
  metadataVersion: String
  "The green firmness for this course instance"
  greenFirmness: Firmness
  "The fairway firmness for this course instance"
  fairwayFirmness: Firmness
  "The green stimp rating for this course instance"
  greenStimp: Stimp
  "The lighting for this course instance"
  lighting: Lighting
  "The pin difficulty for this course instance"
  pinTag: Pin
  "The metadata for this course"
  course: Course
  courseInfo: CoursePerformanceProperties
  courseLocks: [CourseLock]
  "The kind of the configuration this course belongs to"
  kind: CoursesConfigurationKinds
  "Is this course deployed"
  isDeployed: Boolean
}

input staffNotifications {
  id: String
  isActive: Boolean
  triggerBall: Int
  appNotification: NetAlertType!
  appNotificationMessage: String
  kioskAppNotification: NetAlertType
  kioskAppNotificationMessage: String
  staffNotifications: [name]
}

"Return recipient of an event"
type EventLogRecipient {
  "Id of the recipient"
  id: String
  "Name of the recipient"
  name: String
  "Email of the recipient"
  email: String
}

"Indicate type of alert"
enum NetAlertType {
  NONE
  PLEASE_BE_CAREFUL
  STAFF_HAS_BEEN_NOTIFIED
  BLOCK
}

type StaffNotification {
  id: String
  email: EmailAddress
  phoneNumber: String
  name: String
}

enum CoursesConfigurationKinds {
  FACILITY
  TRACK_MAN
}

input name {
  id: String
  email: EmailAddress
  phoneNumber: String
  name: String
}

type Target {
  id: UUID!
  siteLocation: [Float!]
}

type KeyValuePairOfStringAndDouble__ {
  key: String!
  value: [Float!]!
}

type TournamentHole {
  holeNumber: Int!
  pinId: String
}

type SystemInfoVersion {
  cloudApiVersion: String
  iOsAppsVersion: String
  iPadAppsVersion: String
  androidAppsVersion: String
}

type SimpleClaim {
  type: String
  value: String
}

type ClubData {
  name: String
  kind: String
  loft: Float!
  lie: Float!
  hoselPoint: HoselPoint
  data: [KeyValuePairOfStringAndObject!]
}

type StrokeTag {
  value: String
  group: String
  origin: String
  data: [KeyValuePairOfStringAndObject!]
}

type Measurement {
  id: UUID!
  time: DateTime!
  kind: String
  teePosition: [Float!]
  targetPosition: [Float!]
  playerDexterity: String
  detectedClubCategory: String
  backswingTime: Float
  forwardswingTime: Float
  tempo: Float
  strokeLength: Float
  dynamicLie: Float
  impactOffset: Float
  impactHeight: Float
  skidDistance: Float
  rollPercentage: Float
  rollSpeed: Float
  speedDrop: Float
  rollDeceleration: Float
  effectiveStimp: Float
  flatStimp: Float
  break: Float
  bounces: Float
  entrySpeedDistance: Float
  elevation: Float
  slopePercentageSide: Float
  slopePercentageRise: Float
  totalBreak: Float
  attackAngle: Float
  launchDirection: Float
  ballSpeed: Float
  clubPath: Float
  clubSpeed: Float
  dynamicLoft: Float
  faceAngle: Float
  faceToPath: Float
  launchAngle: Float
  smashFactor: Float
  spinAxis: Float
  gyroSpinAngle: Float
  spinLoft: Float
  spinRate: Float
  swingDirection: Float
  swingPlane: Float
  swingRadius: Float
  dPlaneTilt: Float
  lowPointDistance: Float
  lowPointHeight: Float
  lowPointSide: Float
  maxHeight: Float
  landingHeight: Float
  carry: Float
  total: Float
  carrySide: Float
  totalSide: Float
  side: Float
  landingAngle: Float
  hangTime: Float
  lastData: Float
  curve: Float
  carryActual: Float
  totalActual: Float
  carrySideActual: Float
  totalSideActual: Float
  curveActual: Float
  landingAngleActual: Float
  spinAxisActual: Float
  reducedAccuracy: [String]
  ballTrajectory: [Trajectory]
  clubTrajectory: [Trajectory]
  data: [KeyValuePairOfStringAndObject!]
}

type KeyValuePairOfStringAndObject {
  key: String!
}

type Player {
  id: UUID!
  name: String
  email: String
  data: [KeyValuePairOfStringAndObject!]
}

type Client {
  name: String
  version: String
  operatingSystem: String
  data: [KeyValuePairOfStringAndObject!]
}

type User {
  id: UUID!
  name: String
  email: String
  data: [KeyValuePairOfStringAndObject!]
}

type Group {
  id: UUID!
  kind: String
  name: String
  data: [KeyValuePairOfStringAndObject!]
}

type ExpiredLicense {
  invalidMeasurements: [String]
  data: [KeyValuePairOfStringAndObject!]
}

type UtmModel3DCoordinate {
  modelOrigin: [Float!]
  siteOrigin: [Float!]
  siteReference: [Float!]
  transform: [Float!]
}

type HitArea {
  vertices: [[Float!]]
  name: String
  tags: [KeyValue!]
  image: DrivingRangeMetadataImage
  camera: Camera
  type: String
}

type HeightPoint {
  id: String
  name: String
  height: Float!
}

type TeamPlayerInfo {
  teamNumber: String
  color: String
  players: [PlayerInfo]
  isInitialized: Boolean
  hcp: Float
  courseHcp: Float
  tee: String
  gender: String
  isGuest: Boolean
  isGhost: Boolean
  isTournamentScore: Boolean
  progressMessageId: String
  birthday: DateTime
  numberOfRounds: Int
  category: String
  id: String
  name: String
}

type DefaultTees {
  male: String
  female: String
  course: String
}

type LeaderboardPlayer {
  id: String
  sessionId: String
  nickname: String
  isAnonymous: Boolean!
  isGuestPlayer: Boolean!
  isBayHost: Boolean!
  bayId: String
  colorArgb: Int
  colorHex: String
}

type PlayerType {
  id: String
  name: String
  email: String
  hcp: Int
  gender: String
  dexterity: String
  nationality: String
  birthday: DateTime
  playerCategory: PlayerCategoryType
  data: [KeyValuePairOfStringAndObject!]
}

type ClientType {
  name: String
  version: String
  data: [KeyValuePairOfStringAndObject!]
}

type UserType {
  id: String
  name: String
  email: String
  data: [KeyValuePairOfStringAndObject!]
}

type GroupType {
  id: String
  kind: String
  name: String
  data: [KeyValuePairOfStringAndObject!]
}

type LayoutResource {
  key: String
  identifier: String
  version: String
  type: String
  subType: String
  uri: String
  displayName: String
}

type TrackManResource {
  identifier: String
  type: String
  version: String
  title: String
  url: URL
  sha256: String
  size: Int!
  platform: String
  id: String
  createdAt: DateTime!
  lastUpdatedAt: DateTime!
  createdBy: String
  lastUpdatedBy: String
}

type ReleaseResource {
  identifier: String
  version: String
  url: String
  size: Long!
}

type LeaderboardRecordTag {
  id: String
  type: String
  name: String
}

type KeyValuePairOfStringAndDouble {
  key: String!
  value: Float!
}

type GeoLocation {
  ipAddess: String
  cityName: String
  regionName: String
  regionCode: String
  countryName: String
  countryCode: String
  continentName: String
  continentCode: String
  latitude: Float
  longitude: Float
}

type TupleOfDoubleAndDouble {
  item1: Float!
  item2: Float!
}

input VersionIdInput {
  id: String
  version: String
}

type OutsideTeeArea {
  optimalTeeArea: [[Float!]]
  data: [KeyValuePairOfStringAndObject!]
}

type VideoIssuesPayload {
  videoIssues: VideoIssues
  data: [KeyValuePairOfStringAndObject!]
}

type TrackerNoiseNotification {
  maxAge: Float!
  acceptableLevelExceeded: Boolean!
  measuredLevel: [Float!]
  noisyChannels: [Int!]
  data: [KeyValuePairOfStringAndObject!]
}

type TargetStatistics {
  avgScore: Float
  avgTotal: Float
  avgTotalSide: Float
  avgDistanceFromPin: Float
  data: [KeyValuePairOfStringAndObject!]
}

type StrokeTrajectory {
  clone: StrokeTrajectory
  kind: String
  xFit: [Float!]
  yFit: [Float!]
  zFit: [Float!]
  spinRateFit: [Float!]
  spinRateEffectiveFit: [Float!]
  timeInterval: [Float!]
  timeIntervalActual: [Float!]
  measuredTimeInterval: [Float!]
  validTimeInterval: [Float!]
  trackingPercentage: Float
}

type Camera {
  position: [Float!]
  lookAt: [Float!]
  up: [Float!]
  fieldOfView: Float!
  roll: Float!
}

type TeeSettings {
  name: String
}

type KeyValuePairOfStringAndLeaderboardRoundScore {
  key: String!
  value: LeaderboardRoundScore!
}

type OrderOfMeritLeaderboardScore {
  score: Float!
  pos: Int
  posLabel: String
}

type ClubHead {
  type: String
  kind: String
}

type TeeInfoWithoutHoles {
  name: String
  slope: Float!
  rating: Float!
  par: Float!
  distance: Float!
  gender: String
}

type KeyValuePairOfStringAndInt64 {
  key: String!
  value: Long!
}

type Measurements {
  impactOffset: Float!
  impactHeight: Float!
  dynamicLoft: Float!
  dynamicLie: Float!
  faceAngle: Float!
  hoselPoint: [Float!]
  hoselAngle: Float!
  dexterity: String
  data: [KeyValuePairOfStringAndObject!]
}

type ClubConfiguration {
  hoselOffset: [Float!]
  staticLoft: Float!
  staticLie: Float!
  roll: Float!
  bulge: Float!
  ballCompression: Float!
  data: [KeyValuePairOfStringAndObject!]
}

type CameraConfiguration {
  tiltPanRoll: [Float!]
  translation: [Float!]
  data: [KeyValuePairOfStringAndObject!]
}

type ImageResource {
  cdnUri: URL
  metaUri: URL
  metaCdnUri: URL
  width: Int!
  height: Int!
  size: Float!
  sha256: String
  kind: String
  uri: URL
}

type LeaderboardRoundScore {
  time: String
  pos: Int
  posLabel: String
  filterPos: Int
  filterPosLabel: String
  sortPos: Int
  score: Float
  distance: Float
  distanceToPin: Float
  distanceToPinWithPenalty: Float
  penalty: Float
  shotNumber: Int
  lie: String
  playerName: String
  scorecardId: String
  roundId: String
  state: TournamentPlayerRoundState!
  toPar: Int
  thru: Int
  isCountingScore: Boolean!
  values: [KeyValuePairOfStringAndDouble!]
}

type LeaderboardOrderOfMeritInfo {
  previousPos: Int
  newPos: Int
}

enum HcpCap {
  NONE
  SOFT_CAP
  HARD_CAP
}

type VideoIssues {
  videoTooDark: VideoIssue
  videoTooBright: VideoIssue
  videoFlickering: VideoIssue
  videoIssueWarnings: [String]
  data: [KeyValuePairOfStringAndObject!]
}

type PlayerCategoryType {
  id: String
  name: String
  data: [KeyValuePairOfStringAndObject!]
}

type Trajectory {
  kind: String
  xFit: [Float!]
  yFit: [Float!]
  zFit: [Float!]
  spinRateFit: [Float!]
  timeInterval: [Float!]
  validTimeInterval: [Float!]
  measuredTimeInterval: [Float!]
  data: [KeyValuePairOfStringAndObject!]
}

type HoselPoint {
  horizontal: Float!
  vertical: Float!
  data: [KeyValuePairOfStringAndObject!]
}

type VideoIssue {
  data: [KeyValuePairOfStringAndObject!]
}

input AcceptConsentInput {
  key: String!
}

union AcceptConsentError = DefaultError | MissingMandatoryFieldError

type AcceptConsentPayload {
  userConsent: UserConsentItem
  errors: [AcceptConsentError!]
}

input RevokeConsentInput {
  key: String!
}

union RevokeConsentError = DefaultError | MissingMandatoryFieldError

type RevokeConsentPayload {
  userConsent: UserConsentItem
  errors: [RevokeConsentError!]
}

input SetUserPropertiesInput {
  application: String!
  addProperties: [ApplicationPropertySettingInput]
  removeProperties: [String]
}

union SetUserPropertiesError = DefaultError | DuplicateRecordError | MissingMandatoryFieldError

type SetUserPropertiesPayload {
  properties: [ApplicationPropertySetting]
  errors: [SetUserPropertiesError!]
}

input DuplicateInfoScreenInput {
  existingId: ID!
}

union DuplicateInfoScreenError = DefaultError | EntityNotFoundError

type DuplicateInfoScreenPayload {
  infoScreen: InfoScreen
  errors: [DuplicateInfoScreenError!]
}

type CreateOAuthClientApplicationPayload {
  application: Application
}

union CreateServiceAccountError = DefaultError | MissingMandatoryFieldError | CreateUserFailedError

type CreateServiceAccountPayload {
  serviceAccount: ServiceAccount
  errors: [CreateServiceAccountError!]
}

input AddRangeNetInput {
  isEnabled: Boolean
  description: String
  name: String!
  locationId: ID!
  poles: [NetPoleInput!]!
}

union AddRangeNetError = DefaultError | EntityNotFoundError | MissingMandatoryFieldError | NumericValueOutOfRangeError | ActiveConfigurationNotFoundError | NumericValueShouldBePositiveOrZeroError

type AddRangeNetPayload {
  net: Net
  errors: [AddRangeNetError!]
}

input UpdateRangeNetInput {
  isEnabled: Boolean
  description: String
  id: ID!
  name: String!
  poles: [NetPoleInput!]!
}

union UpdateRangeNetError = DefaultError | EntityNotFoundError | EntityNotModifiableError | ConcurrencyViolationError | MissingMandatoryFieldError | NumericValueOutOfRangeError | NumericValueShouldBePositiveOrZeroError

type UpdateRangeNetPayload {
  net: Net
  errors: [UpdateRangeNetError!]
}

input RemoveRangeNetsInput {
  netIds: [ID!]!
}

union RemoveRangeNetsError = DefaultError | EntityNotFoundError | EntityNotModifiableError | MissingMandatoryFieldError

type RemoveRangeNetsPayload {
  nets: [Net]
  errors: [RemoveRangeNetsError!]
}

input EnableRangeNetsInput {
  netIds: [ID!]!
}

union EnableRangeNetsError = DefaultError

type EnableRangeNetsPayload {
  result: AppMutationResult
  errors: [EnableRangeNetsError!]
}

input DisableRangeNetsInput {
  netIds: [ID!]!
}

union DisableRangeNetsError = DefaultError

type DisableRangeNetsPayload {
  result: AppMutationResult
  errors: [DisableRangeNetsError!]
}

input RevertRangeNetInput {
  netId: ID!
}

union RevertRangeNetError = DefaultError | MissingMandatoryFieldError | EntityNotFoundError

type RevertRangeNetPayload {
  result: AppMutationResult
  errors: [RevertRangeNetError!]
}

input AddRangeTargetInput {
  locationId: ID!
  name: String!
  description: String
  color: String
  worldCoordinate: WorldCoord!
  annotations: [KeyValueInput]
  isHidden: Boolean!
  isEnabled: Boolean!
  targetType: Type!
}

union AddRangeTargetError = DefaultError | EntityNotFoundError | MissingMandatoryFieldError | NumericValueOutOfRangeError

type AddRangeTargetPayload {
  rangeTarget: RangeTarget
  errors: [AddRangeTargetError!]
}

input UpdateRangeTargetInput {
  id: ID!
  name: String!
  description: String
  color: String
  worldCoordinate: WorldCoord!
  annotations: [KeyValueInput]
  isHidden: Boolean!
  isEnabled: Boolean!
  targetType: Type!
}

union UpdateRangeTargetError = DefaultError | MissingMandatoryFieldError | EntityNotFoundError | EntityNotModifiableError | ConcurrencyViolationError | NumericValueOutOfRangeError

type UpdateRangeTargetPayload {
  rangeTarget: RangeTarget
  errors: [UpdateRangeTargetError!]
}

input RemoveRangeTargetsInput {
  targetIds: [ID!]!
}

union RemoveRangeTargetsError = DefaultError | EntityNotFoundError | EntityNotModifiableError | MissingMandatoryFieldError

type RemoveRangeTargetsPayload {
  targets: [RangeTarget]
  errors: [RemoveRangeTargetsError!]
}

input EnableRangeTargetsInput {
  targetIds: [ID!]!
}

union EnableRangeTargetsError = DefaultError

type EnableRangeTargetsPayload {
  result: AppMutationResult
  errors: [EnableRangeTargetsError!]
}

input DisableRangeTargetsInput {
  targetIds: [ID!]!
}

union DisableRangeTargetsError = DefaultError

type DisableRangeTargetsPayload {
  result: AppMutationResult
  errors: [DisableRangeTargetsError!]
}

input ChangeRangeTargetsColorInput {
  targetIds: [ID!]!
  color: String!
}

union ChangeRangeTargetsColorError = DefaultError | EntityNotFoundError | EntityNotModifiableError | ConcurrencyViolationError | MissingMandatoryFieldError

type ChangeRangeTargetsColorPayload {
  result: AppMutationResult
  errors: [ChangeRangeTargetsColorError!]
}

input ChangeRangeTargetsTypeInput {
  targetIds: [ID!]!
  type: String!
}

union ChangeRangeTargetsTypeError = DefaultError | EntityNotFoundError | EntityNotModifiableError | ConcurrencyViolationError | MissingMandatoryFieldError

type ChangeRangeTargetsTypePayload {
  result: AppMutationResult
  errors: [ChangeRangeTargetsTypeError!]
}

input ChangeRangeTargetsVisibilityInput {
  targetIds: [ID!]!
  isHidden: Boolean!
}

union ChangeRangeTargetsVisibilityError = DefaultError | EntityNotFoundError | EntityNotModifiableError | ConcurrencyViolationError | MissingMandatoryFieldError

type ChangeRangeTargetsVisibilityPayload {
  result: AppMutationResult
  errors: [ChangeRangeTargetsVisibilityError!]
}

input RevertRangeTargetInput {
  targetIds: ID!
}

union RevertRangeTargetError = DefaultError | EntityNotFoundError | MissingMandatoryFieldError

type RevertRangeTargetPayload {
  result: AppMutationResult
  errors: [RevertRangeTargetError!]
}

input AddRangeSectionInput {
  name: String!
  locationId: ID!
}

union AddRangeSectionError = DefaultError | EntityNotFoundError | DuplicateRecordError | MissingMandatoryFieldError

type AddRangeSectionPayload {
  section: Section
  errors: [AddRangeSectionError!]
}

input UpdateRangeSectionInput {
  id: ID!
  name: String!
}

union UpdateRangeSectionError = DefaultError | EntityNotFoundError | DuplicateRecordError | EntityNotModifiableError | MissingMandatoryFieldError

type UpdateRangeSectionPayload {
  section: Section
  errors: [UpdateRangeSectionError!]
}

input RemoveRangeSectionsInput {
  sectionIds: [ID!]!
}

union RemoveRangeSectionsError = DefaultError | EntityNotFoundError | EntityNotModifiableError | MissingMandatoryFieldError

type RemoveRangeSectionsPayload {
  result: AppMutationResult
  errors: [RemoveRangeSectionsError!]
}

input AddRangeBayInput {
  locationId: ID!
  name: String!
  description: String
  worldCoordinate: WorldCoord!
  annotations: [KeyValueInput]
  availability: BayAvailability!
  sectionId: ID
  isKioskOnly: Boolean!
  isEnabled: Boolean!
  bayNumber: Int
}

union AddRangeBayError = DefaultError | EntityNotFoundError | MissingMandatoryFieldError | NumericValueOutOfRangeError

type AddRangeBayPayload {
  rangeBay: RangeBay
  errors: [AddRangeBayError!]
}

input UpdateRangeBayInput {
  id: ID!
  name: String!
  description: String
  worldCoordinate: WorldCoord!
  annotations: [KeyValueInput]
  availability: BayAvailability!
  sectionId: ID
  isKioskOnly: Boolean!
  isEnabled: Boolean
  bayNumber: Int
}

union UpdateRangeBayError = DefaultError | EntityNotFoundError | EntityNotModifiableError | ConcurrencyViolationError | MissingMandatoryFieldError | NumericValueOutOfRangeError

type UpdateRangeBayPayload {
  rangeBay: RangeBay
  errors: [UpdateRangeBayError!]
}

input ChangeRangeBayKioskOnlyFlagInput {
  bayIds: [ID!]!
  isKioskOnly: Boolean!
}

union ChangeRangeBayKioskOnlyFlagError = DefaultError | EntityNotFoundError | EntityNotModifiableError | ConcurrencyViolationError | MissingMandatoryFieldError

type ChangeRangeBayKioskOnlyFlagPayload {
  result: AppMutationResult
  errors: [ChangeRangeBayKioskOnlyFlagError!]
}

input ChangeRangeBayAvailabilityInput {
  bayIds: [ID!]!
  availability: BayAvailability!
}

union ChangeRangeBayAvailabilityError = DefaultError | EntityNotFoundError | EntityNotModifiableError | ConcurrencyViolationError | MissingMandatoryFieldError

type ChangeRangeBayAvailabilityPayload {
  result: AppMutationResult
  errors: [ChangeRangeBayAvailabilityError!]
}

input RemoveRangeBaysInput {
  bayIds: [ID!]!
}

union RemoveRangeBaysError = DefaultError | EntityNotFoundError | EntityNotModifiableError | MissingMandatoryFieldError

type RemoveRangeBaysPayload {
  bays: [RangeBay]
  errors: [RemoveRangeBaysError!]
}

input EnableRangeBaysInput {
  bayIds: [ID!]!
}

union EnableRangeBaysError = DefaultError

type EnableRangeBaysPayload {
  result: AppMutationResult
  errors: [EnableRangeBaysError!]
}

input DisableRangeBaysInput {
  bayIds: [ID!]!
}

union DisableRangeBaysError = DefaultError

type DisableRangeBaysPayload {
  result: AppMutationResult
  errors: [DisableRangeBaysError!]
}

input RevertRangeBayInput {
  bayId: ID!
}

union RevertRangeBayError = DefaultError | EntityNotFoundError | MissingMandatoryFieldError

type RevertRangeBayPayload {
  result: AppMutationResult
  errors: [RevertRangeBayError!]
}

input AddRangeLaunchAreaInput {
  locationId: ID!
  name: String!
  description: String
  isEnabled: Boolean
  vertices: [LaunchAreaCoordinatesInput!]!
}

union AddRangeLaunchAreaError = DefaultError | MissingMandatoryFieldError | EntityNotFoundError | NumericValueOutOfRangeError | ActiveConfigurationNotFoundError

type AddRangeLaunchAreaPayload {
  launchArea: LaunchAreaType
  errors: [AddRangeLaunchAreaError!]
}

input UpdateRangeLaunchAreaInput {
  id: ID!
  name: String!
  description: String
  isEnabled: Boolean
  vertices: [LaunchAreaCoordinatesInput!]!
}

union UpdateRangeLaunchAreaError = DefaultError | MissingMandatoryFieldError | EntityNotFoundError | EntityNotModifiableError | ConcurrencyViolationError | NumericValueOutOfRangeError

type UpdateRangeLaunchAreaPayload {
  launchArea: LaunchAreaType
  errors: [UpdateRangeLaunchAreaError!]
}

input RemoveRangeLaunchAreasInput {
  launchAreaIds: [ID!]!
}

union RemoveRangeLaunchAreasError = DefaultError | EntityNotFoundError | EntityNotModifiableError | MissingMandatoryFieldError

type RemoveRangeLaunchAreasPayload {
  launchAreas: [LaunchAreaType]
  errors: [RemoveRangeLaunchAreasError!]
}

input EnableRangeLaunchAreasInput {
  launchAreaIds: [ID!]!
}

union EnableRangeLaunchAreasError = DefaultError

type EnableRangeLaunchAreasPayload {
  result: AppMutationResult
  errors: [EnableRangeLaunchAreasError!]
}

input DisableRangeLaunchAreasInput {
  launchAreaIds: [ID!]!
}

union DisableRangeLaunchAreasError = DefaultError

type DisableRangeLaunchAreasPayload {
  result: AppMutationResult
  errors: [DisableRangeLaunchAreasError!]
}

input RevertRangeLaunchAreaInput {
  launchAreaId: ID!
}

union RevertRangeLaunchAreaError = DefaultError | MissingMandatoryFieldError | EntityNotFoundError

type RevertRangeLaunchAreaPayload {
  result: AppMutationResult
  errors: [RevertRangeLaunchAreaError!]
}

input AddRangeRadarInput {
  locationId: ID!
  name: String!
  serialNumber: Int
  worldCoordinate: WorldCoord!
  canConfirm: Boolean!
  isEnabled: Boolean!
}

union AddRangeRadarError = DefaultError | EntityNotFoundError | MissingMandatoryFieldError | NumericValueOutOfRangeError

type AddRangeRadarPayload {
  radar: Radar
  errors: [AddRangeRadarError!]
}

input UpdateRangeRadarInput {
  id: ID!
  name: String!
  serialNumber: Int
  worldCoordinate: WorldCoord!
  uri: String!
  canConfirm: Boolean!
  isEnabled: Boolean!
}

union UpdateRangeRadarError = DefaultError | MissingMandatoryFieldError | EntityNotFoundError | EntityNotModifiableError | ConcurrencyViolationError | NumericValueOutOfRangeError

type UpdateRangeRadarPayload {
  radar: Radar
  errors: [UpdateRangeRadarError!]
}

input RemoveRangeRadarInput {
  radarIds: [ID!]!
}

union RemoveRangeRadarError = DefaultError | EntityNotFoundError | EntityNotModifiableError | MissingMandatoryFieldError

type RemoveRangeRadarPayload {
  radars: [Radar]
  errors: [RemoveRangeRadarError!]
}

input EnableRangeRadarsInput {
  radarIds: [ID!]!
}

union EnableRangeRadarsError = DefaultError

type EnableRangeRadarsPayload {
  result: AppMutationResult
  errors: [EnableRangeRadarsError!]
}

input DisableRangeRadarsInput {
  radarIds: [ID!]!
}

union DisableRangeRadarsError = DefaultError

type DisableRangeRadarsPayload {
  result: AppMutationResult
  errors: [DisableRangeRadarsError!]
}

input RevertRangeRadarInput {
  radarIds: ID!
}

union RevertRangeRadarError = DefaultError | EntityNotFoundError | MissingMandatoryFieldError

type RevertRangeRadarPayload {
  result: AppMutationResult
  errors: [RevertRangeRadarError!]
}

input PublishRangeConfigurationInput {
  locationId: ID!
  description: String!
  originWorldCoordinate: WorldCoord
  referenceWorldCoordinate: WorldCoord
  bays: [String!]
  targets: [String!]
  nets: [String!]
  radars: [String!]
  launchAreas: [String!]
}

union PublishRangeConfigurationError = DefaultError | MissingMandatoryFieldError | EntityNotFoundError | NothingToPublishError | BaseRadarNotSetError

type PublishRangeConfigurationPayload {
  configuration: RangeConfigurationType
  errors: [PublishRangeConfigurationError!]
}